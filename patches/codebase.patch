diff -Nuar clean-build/CMakeLists.txt temp-build/CMakeLists.txt
--- clean-build/CMakeLists.txt	2014-08-02 06:53:50.000000000 -0400
+++ temp-build/CMakeLists.txt	2014-07-31 07:17:21.000000000 -0400
@@ -38,11 +38,11 @@
 else()
   option(PCH                "Use precompiled headers"               OFF)
 endif()
+option(TOOLS                "Build Tools"                           ON)
 # TODO: options that should be checked/created:
 #option(CLI                  "With CLI"                              ON)
 #option(RA                   "With Remote Access"                    OFF)
 #option(SQL                  "Copy SQL files"                        OFF)
-#option(TOOLS                "Build tools"                           OFF)
 
 # Output description of this script
 message("")
@@ -59,6 +59,7 @@
     TBB_USE_EXTERNAL        Use external TBB
     USE_STD_MALLOC          Use standard malloc instead of TBB
     ACE_USE_EXTERNAL        Use external ACE
+    TOOLS                   Build dbc/map/vmap/mmap extraction tools
   To set an option simply type -D<OPTION>=<VALUE> after 'cmake <srcs>'.
   Also, you can specify the generator with -G. see 'cmake --help' for more details
   For example: cmake .. -DDEBUG=1 -DCMAKE_INSTALL_PREFIX=/opt/mangos"
@@ -306,11 +307,12 @@
 #   message(STATUS "Install SQL-files     : No  (default)")
 # endif()
 
-# if(TOOLS)
-#   message(STATUS "Build map/vmap tools  : Yes")
-# else()
-#   message(STATUS "Build map/vmap tools  : No  (default)")
-# endif()
+if(TOOLS)
+   message(STATUS "Build map/vmap tools  : Yes (default)")
+   add_subdirectory(maptools)
+else()
+   message(STATUS "Build map/vmap tools  : No")
+endif()
 
 # Some small tweaks for Visual Studio 7 and above.
 if(MSVC)
diff -Nuar clean-build/dep/recastnavigation/CMakeLists.txt temp-build/dep/recastnavigation/CMakeLists.txt
--- clean-build/dep/recastnavigation/CMakeLists.txt	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/dep/recastnavigation/CMakeLists.txt	2014-07-31 07:17:22.000000000 -0400
@@ -16,4 +16,4 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 #
 add_subdirectory(Detour)
-#add_subdirectory(Recast)
+add_subdirectory(Recast)
diff -Nuar clean-build/dep/recastnavigation/Recast/CMakeLists.txt temp-build/dep/recastnavigation/Recast/CMakeLists.txt
--- clean-build/dep/recastnavigation/Recast/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/dep/recastnavigation/Recast/CMakeLists.txt	2014-07-31 07:17:22.000000000 -0400
@@ -0,0 +1,18 @@
+#
+# This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+add_subdirectory(Source)
diff -Nuar clean-build/dep/recastnavigation/Recast/Source/CMakeLists.txt temp-build/dep/recastnavigation/Recast/Source/CMakeLists.txt
--- clean-build/dep/recastnavigation/Recast/Source/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/dep/recastnavigation/Recast/Source/CMakeLists.txt	2014-07-31 07:17:22.000000000 -0400
@@ -0,0 +1,39 @@
+#
+# This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+set(recast_SRCS
+    RecastAlloc.cpp
+    RecastArea.cpp
+    RecastContour.cpp
+    Recast.cpp
+    RecastFilter.cpp
+    RecastMesh.cpp
+    RecastMeshDetail.cpp
+    RecastRasterization.cpp
+    RecastRegion.cpp
+)
+
+include_directories(
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast/Include
+)
+
+add_library(recast STATIC
+  ${recast_SRCS}
+)
diff -Nuar clean-build/dep/tbb/build/vs100project/version_string.tmp temp-build/dep/tbb/build/vs100project/version_string.tmp
--- clean-build/dep/tbb/build/vs100project/version_string.tmp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/dep/tbb/build/vs100project/version_string.tmp	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-#define __TBB_VERSION_STRINGS "Empty"
diff -Nuar clean-build/dep/tbb/build/vsproject/version_string.tmp temp-build/dep/tbb/build/vsproject/version_string.tmp
--- clean-build/dep/tbb/build/vsproject/version_string.tmp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/dep/tbb/build/vsproject/version_string.tmp	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-#define __TBB_VERSION_STRINGS "Empty"
diff -Nuar clean-build/maptools/CMakeLists.txt temp-build/maptools/CMakeLists.txt
--- clean-build/maptools/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/CMakeLists.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,45 @@
+include_directories(
+    ${CMAKE_SOURCE_DIR}/src
+    ${CMAKE_SOURCE_DIR}/src/shared
+    ${CMAKE_SOURCE_DIR}/src/framework
+    ${CMAKE_SOURCE_DIR}/src/game
+    ${CMAKE_SOURCE_DIR}/src/game/vmap
+    ${CMAKE_SOURCE_DIR}/dep/include
+    ${CMAKE_SOURCE_DIR}/dep/include/zlib
+    ${CMAKE_SOURCE_DIR}/dep/include/g3dlite
+    ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour/Include
+    ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast/Include
+    ${CMAKE_BINARY_DIR}
+)
+
+add_library(vmap_mt
+    ${CMAKE_SOURCE_DIR}/src/game/vmap/BIH.cpp
+    ${CMAKE_SOURCE_DIR}/src/game/vmap/VMapManager2.cpp
+    ${CMAKE_SOURCE_DIR}/src/game/vmap/MapTree.cpp
+    ${CMAKE_SOURCE_DIR}/src/game/vmap/TileAssembler.cpp
+    ${CMAKE_SOURCE_DIR}/src/game/vmap/WorldModel.cpp
+    ${CMAKE_SOURCE_DIR}/src/game/vmap/ModelInstance.cpp
+    )
+
+add_library(zlib_mt
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/adler32.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/compress.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/crc32.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/deflate.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/example.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/infback.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/inffast.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/inflate.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/inftrees.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/trees.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/uncompr.c
+    ${CMAKE_SOURCE_DIR}/dep/src/zlib/zutil.c
+)
+
+target_link_libraries(vmap_mt g3dlite zlib_mt)
+
+add_subdirectory(map_extractor)
+add_subdirectory(vmap_extractor)
+add_subdirectory(vmap_assembler)
+add_subdirectory(mmap_generator)
+
diff -Nuar clean-build/maptools/map_extractor/CMakeLists.txt temp-build/maptools/map_extractor/CMakeLists.txt
--- clean-build/maptools/map_extractor/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/CMakeLists.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,19 @@
+add_subdirectory (map_loadlib)
+add_subdirectory (libmpq03)
+
+include_directories (
+    ${CMAKE_CURRENT_SOURCE_DIR}/libmpq03
+    ${CMAKE_CURRENT_SOURCE_DIR}/map_loadlib
+)
+
+link_directories (
+    ${CMAKE_CURRENT_SOURCE_DIR}/libmpq03
+    ${CMAKE_CURRENT_SOURCE_DIR}/map_loadlib
+)
+
+add_executable (map_extractor dbcfile.cpp mpq_libmpq.cpp System.cpp)
+
+target_link_libraries (map_extractor mpq03 map_loadlib zlib_mt)
+
+install(TARGETS map_extractor DESTINATION ${CMAKE_INSTALL_PREFIX}/maptools)
+
diff -Nuar clean-build/maptools/map_extractor/dbcfile.cpp temp-build/maptools/map_extractor/dbcfile.cpp
--- clean-build/maptools/map_extractor/dbcfile.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/dbcfile.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,82 @@
+#define _CRT_SECURE_NO_DEPRECATE
+
+#include "dbcfile.h"
+#include "mpq_libmpq.h"
+
+DBCFile::DBCFile(const std::string& filename):
+    filename(filename),
+    data(0)
+{
+}
+
+bool DBCFile::open()
+{
+    MPQFile f(filename.c_str());
+    char header[4];
+    unsigned int na, nb, es, ss;
+
+    if (f.read(header, 4) != 4)                             // Number of records
+        return false;
+
+    if (header[0] != 'W' || header[1] != 'D' || header[2] != 'B' || header[3] != 'C')
+        return false;
+
+    if (f.read(&na, 4) != 4)                                // Number of records
+        return false;
+    if (f.read(&nb, 4) != 4)                                // Number of fields
+        return false;
+    if (f.read(&es, 4) != 4)                                // Size of a record
+        return false;
+    if (f.read(&ss, 4) != 4)                                // String size
+        return false;
+
+    recordSize = es;
+    recordCount = na;
+    fieldCount = nb;
+    stringSize = ss;
+    if (fieldCount * 4 != recordSize)
+        return false;
+
+    data = new unsigned char[recordSize * recordCount + stringSize];
+    stringTable = data + recordSize * recordCount;
+
+    size_t data_size = recordSize * recordCount + stringSize;
+    if (f.read(data, data_size) != data_size)
+        return false;
+    f.close();
+    return true;
+}
+DBCFile::~DBCFile()
+{
+    delete [] data;
+}
+
+DBCFile::Record DBCFile::getRecord(size_t id)
+{
+    assert(data);
+    return Record(*this, data + id * recordSize);
+}
+
+size_t DBCFile::getMaxId()
+{
+    assert(data);
+
+    size_t maxId = 0;
+    for (size_t i = 0; i < getRecordCount(); ++i)
+    {
+        if (maxId < getRecord(i).getUInt(0))
+            maxId = getRecord(i).getUInt(0);
+    }
+    return maxId;
+}
+
+DBCFile::Iterator DBCFile::begin()
+{
+    assert(data);
+    return Iterator(*this, data);
+}
+DBCFile::Iterator DBCFile::end()
+{
+    assert(data);
+    return Iterator(*this, stringTable);
+}
diff -Nuar clean-build/maptools/map_extractor/dbcfile.h temp-build/maptools/map_extractor/dbcfile.h
--- clean-build/maptools/map_extractor/dbcfile.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/dbcfile.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,120 @@
+#ifndef DBCFILE_H
+#define DBCFILE_H
+#include <cassert>
+#include <string>
+
+class DBCFile
+{
+    public:
+        DBCFile(const std::string& filename);
+        ~DBCFile();
+
+        // Open database. It must be openened before it can be used.
+        bool open();
+
+        // Database exceptions
+        class Exception
+        {
+            public:
+                Exception(const std::string& message): message(message)
+                { }
+                virtual ~Exception()
+                { }
+                const std::string& getMessage() {return message;}
+            private:
+                std::string message;
+        };
+        class NotFound: public Exception
+        {
+            public:
+                NotFound(): Exception("Key was not found")
+                { }
+        };
+        // Iteration over database
+        class Iterator;
+        class Record
+        {
+            public:
+                float getFloat(size_t field) const
+                {
+                    assert(field < file.fieldCount);
+                    return *reinterpret_cast<float*>(offset + field * 4);
+                }
+                unsigned int getUInt(size_t field) const
+                {
+                    assert(field < file.fieldCount);
+                    return *reinterpret_cast<unsigned int*>(offset + field * 4);
+                }
+                int getInt(size_t field) const
+                {
+                    assert(field < file.fieldCount);
+                    return *reinterpret_cast<int*>(offset + field * 4);
+                }
+                const char* getString(size_t field) const
+                {
+                    assert(field < file.fieldCount);
+                    size_t stringOffset = getUInt(field);
+                    assert(stringOffset < file.stringSize);
+                    return reinterpret_cast<char*>(file.stringTable + stringOffset);
+                }
+            private:
+                Record(DBCFile& file, unsigned char* offset): file(file), offset(offset) {}
+                unsigned char* offset;
+                DBCFile& file;
+
+                friend class DBCFile;
+                friend class DBCFile::Iterator;
+        };
+        /** Iterator that iterates over records
+        */
+        class Iterator
+        {
+            public:
+                Iterator(DBCFile& file, unsigned char* offset):
+                    record(file, offset) {}
+                /// Advance (prefix only)
+                Iterator& operator++()
+                {
+                    record.offset += record.file.recordSize;
+                    return *this;
+                }
+                /// Return address of current instance
+                Record const& operator*() const { return record; }
+                const Record* operator->() const
+                {
+                    return &record;
+                }
+                /// Comparison
+                bool operator==(const Iterator& b) const
+                {
+                    return record.offset == b.record.offset;
+                }
+                bool operator!=(const Iterator& b) const
+                {
+                    return record.offset != b.record.offset;
+                }
+            private:
+                Record record;
+        };
+
+        // Get record by id
+        Record getRecord(size_t id);
+        /// Get begin iterator over records
+        Iterator begin();
+        /// Get begin iterator over records
+        Iterator end();
+        /// Trivial
+        size_t getRecordCount() const { return recordCount;}
+        size_t getFieldCount() const { return fieldCount; }
+        size_t getMaxId();
+    private:
+        std::string filename;
+        size_t recordSize;
+        size_t recordCount;
+        size_t fieldCount;
+        size_t stringSize;
+        unsigned char* data;
+        unsigned char* stringTable;
+};
+
+#endif
diff -Nuar clean-build/maptools/map_extractor/libmpq03/CMakeLists.txt temp-build/maptools/map_extractor/libmpq03/CMakeLists.txt
--- clean-build/maptools/map_extractor/libmpq03/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/CMakeLists.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,4 @@
+add_library (mpq03 common.cpp explode.cpp extract.cpp huffman.cpp mpq.cpp parser.cpp wave.cpp)
+
+target_link_libraries (mpq03 zlib_mt)
+
diff -Nuar clean-build/maptools/map_extractor/libmpq03/common.cpp temp-build/maptools/map_extractor/libmpq03/common.cpp
--- clean-build/maptools/map_extractor/libmpq03/common.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/common.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,881 @@
+/*
+ *  common.c -- shared functions used by mpq-tools.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  $Id: common.c,v 1.12 2004/02/12 00:42:54 mbroemme Exp $
+ */
+#define _CRT_SECURE_NO_DEPRECATE
+//#include <dirent.h>
+#include <sys/stat.h>
+
+#ifndef WIN32
+#include <unistd.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include "mpq.h"
+#include "common.h"
+#include <ctype.h>
+
+unsigned int libmpq_lseek(mpq_archive* mpq_a, unsigned int pos)
+{
+#ifdef WIN32
+    return (unsigned int)_lseeki64(mpq_a->fd, pos, SEEK_SET);
+#elif defined(__APPLE__)
+    return (unsigned int)lseek(mpq_a->fd, pos, SEEK_SET);
+#else
+    return (unsigned int)lseek64(mpq_a->fd, pos, SEEK_SET);
+#endif
+}
+
+/*
+ *  This function decrypts a MPQ block.
+ */
+int libmpq_decrypt_block(mpq_archive* mpq_a, unsigned int* block, unsigned int length, unsigned int seed1)
+{
+    unsigned int seed2 = 0xEEEEEEEE;
+    unsigned int ch;
+
+    /* Round to unsigned int's */
+    length >>= 2;
+    while (length-- > 0)
+    {
+        seed2    += mpq_a->buf[0x400 + (seed1 & 0xFF)];
+        ch        = *block ^ (seed1 + seed2);
+        seed1     = ((~seed1 << 0x15) + 0x11111111) | (seed1 >> 0x0B);
+        seed2     = ch + seed2 + (seed2 << 5) + 3;
+        *block++  = ch;
+    }
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This function decrypts the hashtable for the
+ *  file informations.
+ */
+int libmpq_decrypt_hashtable(mpq_archive* mpq_a, unsigned char* pbKey)
+{
+    unsigned int seed1 = 0x7FED7FED;
+    unsigned int seed2 = 0xEEEEEEEE;
+    unsigned int ch;            /* One key character */
+    unsigned int* pdwTable = (unsigned int*)(mpq_a->hashtable);
+    unsigned int length = mpq_a->header->hashtablesize * 4;
+
+    /* Prepare seeds */
+    while (*pbKey != 0)
+    {
+        ch = toupper(*pbKey++);
+        seed1 = mpq_a->buf[0x300 + ch] ^ (seed1 + seed2);
+        seed2 = ch + seed1 + seed2 + (seed2 << 5) + 3;
+    }
+
+    /* Decrypt it */
+    seed2 = 0xEEEEEEEE;
+    while (length-- > 0)
+    {
+        seed2 += mpq_a->buf[0x400 + (seed1 & 0xFF)];
+        ch     = *pdwTable ^ (seed1 + seed2);
+        seed1  = ((~seed1 << 0x15) + 0x11111111) | (seed1 >> 0x0B);
+        seed2  = ch + seed2 + (seed2 << 5) + 3;
+        *pdwTable++ = ch;
+    }
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This function decrypts the blocktable.
+ */
+int libmpq_decrypt_blocktable(mpq_archive* mpq_a, unsigned char* pbKey)
+{
+    unsigned int seed1 = 0x7FED7FED;
+    unsigned int seed2 = 0xEEEEEEEE;
+    unsigned int ch;            /* One key character */
+    unsigned int* pdwTable = (unsigned int*)(mpq_a->blocktable);
+    unsigned int length = mpq_a->header->blocktablesize * 4;
+
+    /* Prepare seeds */
+    while (*pbKey != 0)
+    {
+        ch = toupper(*pbKey++);
+        seed1 = mpq_a->buf[0x300 + ch] ^ (seed1 + seed2);
+        seed2 = ch + seed1 + seed2 + (seed2 << 5) + 3;
+    }
+
+    /* Decrypt it */
+    seed2 = 0xEEEEEEEE;
+    while (length-- > 0)
+    {
+        seed2 += mpq_a->buf[0x400 + (seed1 & 0xFF)];
+        ch     = *pdwTable ^ (seed1 + seed2);
+        seed1  = ((~seed1 << 0x15) + 0x11111111) | (seed1 >> 0x0B);
+        seed2  = ch + seed2 + (seed2 << 5) + 3;
+        *pdwTable++ = ch;
+    }
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+int libmpq_read_listfile(mpq_archive* mpq_a, FILE* fp)
+{
+    int mpq_size;
+    int mpq_ht_size;
+    int mpq_bt_size;
+    int mpq_blocksize;
+    int mpq_files;
+    int mpq_csize;
+    int mpq_fsize;
+    int entries;
+    char listdb_version[10];
+    char libmpq_version[10];
+    int listdb_temp_version = 0;
+    int libmpq_temp_version = 0;
+
+    /* first check header and version */
+    if (libmpq_conf_get_value(fp, "LIBMPQ_VERSION", mpq_a->mpq_l->mpq_version, LIBMPQ_CONF_TYPE_CHAR, sizeof(mpq_a->mpq_l->mpq_version)))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    else
+    {
+
+        /* copy to temp buffer for removing . characters */
+        sprintf(listdb_version, (char*)mpq_a->mpq_l->mpq_version);
+
+        /* remove . characters from listfile version */
+        libmpq_conf_delete_char(listdb_version, ".");
+
+        /* get libmpq version */
+        sprintf(libmpq_version, "%i%i%i", LIBMPQ_MAJOR_VERSION, LIBMPQ_MINOR_VERSION, LIBMPQ_PATCH_VERSION);
+
+        /* convert to number */
+        listdb_temp_version = atoi(listdb_version);
+        libmpq_temp_version = atoi(libmpq_version);
+
+        /* check if installed libmpq version is valid for listfile version */
+        if ((libmpq_temp_version < listdb_temp_version) || (libmpq_temp_version == 0) || (listdb_temp_version == 0))
+        {
+            return LIBMPQ_CONF_EFILE_VERSION;
+        }
+    }
+
+    /* check listfile header, the following entries must be set */
+    if (libmpq_conf_get_value(fp, "MPQ_SIZE", &mpq_size, LIBMPQ_CONF_TYPE_INT, 0))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    if (libmpq_conf_get_value(fp, "MPQ_HASHTABLE_SIZE", &mpq_ht_size, LIBMPQ_CONF_TYPE_INT, 0))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    if (libmpq_conf_get_value(fp, "MPQ_BLOCKTABLE_SIZE", &mpq_bt_size, LIBMPQ_CONF_TYPE_INT, 0))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    if (libmpq_conf_get_value(fp, "MPQ_BLOCKSIZE", &mpq_blocksize, LIBMPQ_CONF_TYPE_INT, 0))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    if (libmpq_conf_get_value(fp, "MPQ_FILES", &mpq_files, LIBMPQ_CONF_TYPE_INT, 0))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    if (libmpq_conf_get_value(fp, "MPQ_COMPRESSED_SIZE", &mpq_csize, LIBMPQ_CONF_TYPE_INT, 0))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    if (libmpq_conf_get_value(fp, "MPQ_UNCOMPRESSED_SIZE", &mpq_fsize, LIBMPQ_CONF_TYPE_INT, 0))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    if (libmpq_conf_get_value(fp, "MPQ_NAME", mpq_a->mpq_l->mpq_name, LIBMPQ_CONF_TYPE_CHAR, PATH_MAX))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+    if (libmpq_conf_get_value(fp, "MPQ_TYPE", mpq_a->mpq_l->mpq_type, LIBMPQ_CONF_TYPE_CHAR, sizeof(mpq_a->mpq_l->mpq_type)))
+    {
+        return LIBMPQ_CONF_EFILE_CORRUPT;
+    }
+
+    /* these are optional parameters, if they are empty we set the struct members empty */
+    libmpq_conf_get_value(fp, "MPQ_GAME", mpq_a->mpq_l->mpq_game, LIBMPQ_CONF_TYPE_CHAR, sizeof(mpq_a->mpq_l->mpq_game));
+    libmpq_conf_get_value(fp, "MPQ_GAME_VERSION", mpq_a->mpq_l->mpq_game_version, LIBMPQ_CONF_TYPE_CHAR, sizeof(mpq_a->mpq_l->mpq_game_version));
+
+    /* check if we found a valid listfile for the given archive */
+    if (mpq_a->header->hashtablesize == mpq_ht_size && mpq_a->header->blocktablesize == mpq_bt_size && mpq_a->blocksize == mpq_blocksize && libmpq_archive_info(mpq_a, LIBMPQ_MPQ_ARCHIVE_SIZE) == mpq_size && libmpq_archive_info(mpq_a, LIBMPQ_MPQ_NUMFILES) == mpq_files && libmpq_archive_info(mpq_a, LIBMPQ_MPQ_COMPRESSED_SIZE) == mpq_csize && libmpq_archive_info(mpq_a, LIBMPQ_MPQ_UNCOMPRESSED_SIZE) == mpq_fsize)
+    {
+
+        /* check if the filelist is correct */
+        if (!libmpq_conf_get_array(fp, "FILE_NAMES", (char***)&mpq_a->mpq_l->mpq_files, &entries))
+        {
+
+            /* we have a corrupt filelist, so return */
+            return LIBMPQ_CONF_EFILE_LIST_CORRUPT;
+        }
+        else
+        {
+
+            /* now check if filelist entries matches number of files in the archive. */
+            if (entries != libmpq_archive_info(mpq_a, LIBMPQ_MPQ_NUMFILES))
+            {
+                libmpq_free_listfile((char**)mpq_a->mpq_l->mpq_files);
+                mpq_a->mpq_l->mpq_files = NULL;
+                return LIBMPQ_CONF_EFILE_LIST_CORRUPT;
+            }
+        }
+    }
+
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This function frees up the space reserved by libmpq_get_listfile()
+ */
+int libmpq_free_listfile(char** filelist)
+{
+    int i = 0;
+    while (filelist[i])
+    {
+        free(filelist[i++]);
+    }
+    free(filelist);
+
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This function reads the directory and the subdirectories
+ *  of the listfile database and adds a entry to the lisfile
+ *  array.
+ */
+/*int libmpq_detect_listfile_rec(char path[PATH_MAX], char ***filelist, int *fl_count, int *fl_size) {
+    char nextpath[PATH_MAX];
+    DIR *dp = opendir(path);
+    FILE *fp;
+    struct dirent *entry;
+    struct stat statbuf;
+    char buf[LIBMPQ_CONF_BUFSIZE];
+
+    if (dp == NULL) {
+        return LIBMPQ_CONF_EOPEN_DIR;
+    } else {
+        while ((entry = readdir(dp)) != NULL) {
+            if (strncmp(entry->d_name, ".", 1) == 0 || strncmp(entry->d_name, "..", 2) == 0) {
+                continue;
+            }
+            if (strnlen(path, PATH_MAX) + strnlen(entry->d_name, PATH_MAX) + 2 > sizeof nextpath) {
+                continue;
+            }
+
+            snprintf(nextpath, PATH_MAX, "%s/%s", path, entry->d_name);
+
+            // check if file extension matches listdb file extension
+            if (strncmp(&entry->d_name[strlen(entry->d_name) - strlen(LIBMPQ_CONF_EXT)], LIBMPQ_CONF_EXT, strlen(LIBMPQ_CONF_EXT)) == 0) {
+
+                // check if it is really a listdb file
+                if ((fp = fopen(nextpath, "r")) != NULL ) {
+                    while (fgets(buf, LIBMPQ_CONF_BUFSIZE, fp) != NULL) {
+                        char *line;
+
+                        buf[strlen(buf) - 1] = '\0';
+
+                        // skip whitespace
+                        for (line = buf; isspace(*line); line++) {
+                            continue;
+                        }
+
+                        // skip empty line
+                        if (line[0] == '\0') {
+                            continue;
+                        }
+
+                        // skip comments
+                        if (line[0] == '#') {
+                            continue;
+                        }
+
+                        //search for listdb header; dirty but works :)
+                        if (!strncasecmp(line, LIBMPQ_CONF_HEADER, strlen(LIBMPQ_CONF_HEADER))) {
+
+                            // set the next filelist entry to a copy of the file path
+                            (*filelist)[(*fl_count)++] = strdup(nextpath);
+
+                            // increase the array size
+                            if ((*fl_count) == (*fl_size)) {
+                                (*filelist) = realloc((*filelist), ((*fl_size) + LIBMPQ_CONF_FL_INCREMENT) * sizeof(char *));
+                                (*fl_size) += LIBMPQ_CONF_FL_INCREMENT;
+                            }
+
+                            // header found so we could stop reading the file.
+                            break;
+                        }
+                    }
+                    fclose(fp);
+                }
+            }
+
+            if (stat(nextpath, &statbuf) < 0) {
+                continue;
+            }
+
+            // if entry ia a subdirectory, read it
+            if (S_ISDIR(statbuf.st_mode)) {
+                libmpq_detect_listfile_rec(nextpath, filelist, fl_count, fl_size);
+            }
+        }
+        closedir(dp);
+    }
+
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+*/
+
+/*
+ *  This functions tries to get file decryption key. The trick comes from block
+ *  positions which are stored at the begin of each compressed file. We know the
+ *  file size, that means we know number of blocks that means we know the first
+ *  int value in block position. And if we know encrypted and decrypted value,
+ *  we can find the decryption key.
+ */
+int libmpq_detect_fileseed(mpq_archive* mpq_a, unsigned int* block, unsigned int decrypted)
+{
+    unsigned int saveseed1;
+    unsigned int temp = *block ^ decrypted;     /* temp = seed1 + seed2 */
+    int i = 0;
+    temp -= 0xEEEEEEEE;             /* temp = seed1 + mpq_a->buf[0x400 + (seed1 & 0xFF)] */
+
+    for (i = 0; i < 0x100; i++)             /* Try all 255 possibilities */
+    {
+        unsigned int seed1;
+        unsigned int seed2 = 0xEEEEEEEE;
+        unsigned int ch;
+
+        /* Try the first unsigned int's (We exactly know the value) */
+        seed1  = temp - mpq_a->buf[0x400 + i];
+        seed2 += mpq_a->buf[0x400 + (seed1 & 0xFF)];
+        ch     = block[0] ^ (seed1 + seed2);
+
+        if (ch != decrypted)
+        {
+            continue;
+        }
+
+        /* Add 1 because we are decrypting block positions */
+        saveseed1 = seed1 + 1;
+
+        /*
+         *  If OK, continue and test the second value. We don't know exactly the value,
+         *  but we know that the second one has lower 16 bits set to zero
+         *  (no compressed block is larger than 0xFFFF bytes)
+         */
+        seed1  = ((~seed1 << 0x15) + 0x11111111) | (seed1 >> 0x0B);
+        seed2  = ch + seed2 + (seed2 << 5) + 3;
+        seed2 += mpq_a->buf[0x400 + (seed1 & 0xFF)];
+        ch     = block[1] ^ (seed1 + seed2);
+        if ((ch & 0xFFFF0000) == 0)
+        {
+            return saveseed1;
+        }
+    }
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This function initialize the decryption buffer
+ */
+int libmpq_init_buffer(mpq_archive* mpq_a)
+{
+    unsigned int seed   = 0x00100001;
+    unsigned int index1 = 0;
+    unsigned int index2 = 0;
+    int i;
+
+    memset(mpq_a->buf, 0, sizeof(mpq_a->buf));
+
+    /* Initialize the decryption buffer. */
+    for (index1 = 0; index1 < 0x100; index1++)
+    {
+        for (index2 = index1, i = 0; i < 5; i++, index2 += 0x100)
+        {
+            unsigned int temp1, temp2;
+            seed  = (seed * 125 + 3) % 0x2AAAAB;
+            temp1 = (seed & 0xFFFF) << 0x10;
+
+            seed  = (seed * 125 + 3) % 0x2AAAAB;
+            temp2 = (seed & 0xFFFF);
+
+            mpq_a->buf[index2] = (temp1 | temp2);
+        }
+    }
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This functions fills the mpq_hash structure with the
+ *  hashtable found in the MPQ file. The hashtable will
+ *  be decrypted for later use.
+ */
+int libmpq_read_hashtable(mpq_archive* mpq_a)
+{
+    unsigned int bytes = 0;
+    int rb = 0;
+
+    /*
+     *  Allocate memory. Note that the block table should be as large as the
+     *  hash table. (for later file additions)
+     */
+    mpq_a->hashtable = (mpq_hash*)malloc(sizeof(mpq_hash) * mpq_a->header->hashtablesize);
+
+    if (!mpq_a->hashtable)
+    {
+        return LIBMPQ_EALLOCMEM;
+    }
+
+    /* Read the hash table into the buffer */
+    bytes = mpq_a->header->hashtablesize * sizeof(mpq_hash);
+
+    libmpq_lseek(mpq_a, mpq_a->header->hashtablepos);
+
+    rb = _read(mpq_a->fd, mpq_a->hashtable, bytes);
+    if (rb != bytes)
+    {
+        return LIBMPQ_EFILE_CORRUPT;
+    }
+
+    /* Decrypt hash table and check if it is correctly decrypted */
+    mpq_hash* mpq_h_end = mpq_a->hashtable + mpq_a->header->hashtablesize;
+    mpq_hash* mpq_h     = NULL;
+
+    libmpq_decrypt_hashtable(mpq_a, (unsigned char*)"(hash table)");
+
+    /* Check hash table if is correctly decrypted */
+    for (mpq_h = mpq_a->hashtable; mpq_h < mpq_h_end; mpq_h++)
+    {
+        if (mpq_h->locale != 0xFFFFFFFF && (mpq_h->locale & 0xFFFF0000) != 0)
+        {
+            return LIBMPQ_EFILE_FORMAT;
+        }
+
+        /* Remember the highest block table entry */
+        if (mpq_h->blockindex < LIBMPQ_HASH_ENTRY_DELETED && mpq_h->blockindex > 0)
+        {
+            mpq_a->maxblockindex = mpq_h->blockindex;
+        }
+    }
+
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This functions fills the mpq_block structure with the
+ *  blocktable found in the MPQ file. The blocktable will
+ *  be decrypted for later use.
+ *
+ *  NOTICE: Some MPQs have decrypted block table, e.g.
+ *          cracked Diablo versions.
+ */
+int libmpq_read_blocktable(mpq_archive* mpq_a)
+{
+    unsigned int bytes = 0;
+    int rb = 0;
+
+    /*
+     *  Allocate memory. Note that the block table should be as large as the
+     *  hash table. (for later file additions)
+     */
+    mpq_a->blocktable = (mpq_block*)malloc(sizeof(mpq_block) * mpq_a->header->hashtablesize);
+    mpq_a->blockbuf   = (unsigned char*)malloc(mpq_a->blocksize);
+
+    if (!mpq_a->blocktable || !mpq_a->blockbuf)
+    {
+        return LIBMPQ_EALLOCMEM;
+    }
+
+    /* Read the block table into the buffer */
+    bytes = mpq_a->header->blocktablesize * sizeof(mpq_block);
+    memset(mpq_a->blocktable, 0, mpq_a->header->blocktablesize * sizeof(mpq_block));
+
+    libmpq_lseek(mpq_a, mpq_a->header->blocktablepos);
+
+    rb = _read(mpq_a->fd, mpq_a->blocktable, bytes);
+    if (rb != bytes)
+    {
+        return LIBMPQ_EFILE_CORRUPT;
+    }
+
+    /*
+     *  Decrypt block table. Some MPQs don't have encrypted block table,
+     *  e.g. cracked Diablo version. We have to check if block table is
+     *  already decrypted
+     */
+    mpq_block* mpq_b_end     = mpq_a->blocktable + mpq_a->maxblockindex + 1;
+    mpq_block* mpq_b         = NULL;
+    unsigned int archivesize = mpq_a->header->archivesize + mpq_a->mpqpos;
+
+    if (mpq_a->header->offset != mpq_a->blocktable->filepos)
+    {
+        libmpq_decrypt_blocktable(mpq_a, (unsigned char*)"(block table)");
+    }
+    for (mpq_b = mpq_a->blocktable; mpq_b < mpq_b_end; mpq_b++)
+    {
+        if (mpq_b->filepos > archivesize || mpq_b->csize > archivesize)
+        {
+            if ((mpq_a->flags & LIBMPQ_FLAG_PROTECTED) == 0)
+            {
+                return LIBMPQ_EFILE_FORMAT;
+            }
+        }
+        mpq_b->filepos += mpq_a->mpqpos;
+    }
+
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+int libmpq_file_read_block(mpq_archive* mpq_a, mpq_file* mpq_f, unsigned int blockpos, char* buffer, unsigned int blockbytes)
+{
+    unsigned char* tempbuf = NULL;          /* Buffer for reading compressed data from the file */
+    unsigned int readpos;               /* Reading position from the file */
+    unsigned int toread = 0;            /* Number of bytes to read */
+    unsigned int blocknum;              /* Block number (needed for decrypt) */
+    unsigned int bytesread = 0;         /* Total number of bytes read */
+    unsigned int nblocks;               /* Number of blocks to load */
+    unsigned int i;
+
+    /* Test parameters. Block position and block size must be block-aligned, block size nonzero */
+    if ((blockpos & (mpq_a->blocksize - 1)) || blockbytes == 0)
+    {
+        return 0;
+    }
+
+    /* Check the end of file */
+    if ((blockpos + blockbytes) > mpq_f->mpq_b->fsize)
+    {
+        blockbytes = mpq_f->mpq_b->fsize - blockpos;
+    }
+    blocknum = blockpos   / mpq_a->blocksize;
+    nblocks  = blockbytes / mpq_a->blocksize;
+    if (blockbytes % mpq_a->blocksize)
+    {
+        nblocks++;
+    }
+
+    /* If file has variable block positions, we have to load them */
+    if ((mpq_f->mpq_b->flags & LIBMPQ_FILE_COMPRESSED) && mpq_f->blockposloaded == FALSE)
+    {
+        unsigned int nread;
+
+        if (mpq_f->mpq_b->filepos != mpq_a->filepos)
+        {
+            libmpq_lseek(mpq_a, mpq_f->mpq_b->filepos);
+        }
+
+        /* Read block positions from begin of file. */
+        nread = (mpq_f->nblocks + 1) * sizeof(int);
+        nread = _read(mpq_a->fd, mpq_f->blockpos, nread);
+
+        /*
+         *  If the archive is protected some way, perform additional check
+         *  Sometimes, the file appears not to be encrypted, but it is.
+         */
+        /*if (mpq_f->blockpos[0] != nread) {
+            mpq_f->mpq_b->flags |= LIBMPQ_FILE_ENCRYPTED;
+        }*/
+
+        if ((mpq_f->mpq_b->flags & LIBMPQ_FILE_HAS_METADATA) == 0)
+        {
+            if (mpq_f->blockpos[0] != nread)
+            {
+                mpq_f->mpq_b->flags |= LIBMPQ_FILE_ENCRYPTED;
+            }
+        }
+
+        /* Decrypt loaded block positions if necessary */
+        if (mpq_f->mpq_b->flags & LIBMPQ_FILE_ENCRYPTED)
+        {
+
+            /* If we don't know the file seed, try to find it. */
+            if (mpq_f->seed == 0)
+            {
+                mpq_f->seed = libmpq_detect_fileseed(mpq_a, mpq_f->blockpos, nread);
+            }
+
+            /* If we don't know the file seed, sorry but we cannot extract the file. */
+            if (mpq_f->seed == 0)
+            {
+                return 0;
+            }
+
+            /* Decrypt block positions */
+            libmpq_decrypt_block(mpq_a, mpq_f->blockpos, nread, mpq_f->seed - 1);
+
+            /*
+             *  Check if the block positions are correctly decrypted
+             *  I don't know why, but sometimes it will result invalid
+             *  block positions on some files.
+             */
+            if (mpq_f->blockpos[0] != nread)
+            {
+
+                /* Try once again to detect file seed and decrypt the blocks */
+                libmpq_lseek(mpq_a, mpq_f->mpq_b->filepos);
+
+                nread = _read(mpq_a->fd, mpq_f->blockpos, (mpq_f->nblocks + 1) * sizeof(int));
+                mpq_f->seed = libmpq_detect_fileseed(mpq_a, mpq_f->blockpos, nread);
+                libmpq_decrypt_block(mpq_a, mpq_f->blockpos, nread, mpq_f->seed - 1);
+
+                /* Check if the block positions are correctly decrypted. */
+                if (mpq_f->blockpos[0] != nread)
+                {
+                    return 0;
+                }
+            }
+        }
+
+        /* Update mpq_f's variables */
+        mpq_f->blockposloaded = TRUE;
+        mpq_a->filepos        = mpq_f->mpq_b->filepos + nread;
+    }
+
+    /* Get file position and number of bytes to read */
+    readpos = blockpos;
+    toread  = blockbytes;
+
+    if (mpq_f->mpq_b->flags & LIBMPQ_FILE_COMPRESSED)
+    {
+        readpos = mpq_f->blockpos[blocknum];
+        toread  = mpq_f->blockpos[blocknum + nblocks] - readpos;
+    }
+
+    readpos += mpq_f->mpq_b->filepos;
+
+    /* Get work buffer for store read data */
+    if ((tempbuf = (unsigned char*)malloc(toread)) == NULL)
+    {
+        /* Hmmm... We should add a better error handling here :) */
+        return 0;
+    }
+
+    /* Set file pointer, if necessary. */
+    if (mpq_a->filepos != readpos)
+    {
+        mpq_a->filepos = libmpq_lseek(mpq_a, readpos);
+    }
+
+    /* 15018F87 - Read all requested blocks. */
+    bytesread = _read(mpq_a->fd, tempbuf, toread);
+    mpq_a->filepos = readpos + bytesread;
+
+    /* Block processing part. */
+    unsigned int blockstart = 0;            /* Index of block start in work buffer. */
+    unsigned int blocksize  = min(blockbytes, mpq_a->blocksize);
+    unsigned int index      = blocknum;     /* Current block index. */
+    bytesread = 0;                  /* Clear read byte counter */
+
+    /* Walk through all blocks. */
+    for (i = 0; i < nblocks; i++, index++)
+    {
+        int outlength = mpq_a->blocksize;
+
+        /* Get current block length */
+        if (mpq_f->mpq_b->flags & LIBMPQ_FILE_COMPRESSED)
+        {
+            blocksize = mpq_f->blockpos[index + 1] - mpq_f->blockpos[index];
+        }
+
+        /* If block is encrypted, we have to decrypt it. */
+        if (mpq_f->mpq_b->flags & LIBMPQ_FILE_ENCRYPTED)
+        {
+            if (mpq_f->seed == 0)
+            {
+                return 0;
+            }
+            libmpq_decrypt_block(mpq_a, (unsigned int*)&tempbuf[blockstart], blocksize, mpq_f->seed + index);
+        }
+
+        /*
+         *  If the block is really compressed, recompress it.
+         *  WARNING: Some block may not be compressed, it can
+         *  only be determined by comparing uncompressed and
+         *  compressed size!
+         */
+        if (blocksize < blockbytes)
+        {
+
+            /* Is the file compressed with PKWARE Data Compression Library? */
+            if (mpq_f->mpq_b->flags & LIBMPQ_FILE_COMPRESS_PKWARE)
+            {
+                libmpq_pkzip_decompress(buffer, &outlength, (char*)&tempbuf[blockstart], blocksize);
+            }
+
+            /*
+             *  Is it a file compressed by Blizzard's multiple compression ?
+             *  Note that Storm.dll v 1.0.9 distributed with Warcraft III
+             *  passes the full path name of the opened archive as the new
+             *  last parameter.
+             */
+            if (mpq_f->mpq_b->flags & LIBMPQ_FILE_COMPRESS_MULTI)
+            {
+                libmpq_multi_decompress(buffer, &outlength, (char*)&tempbuf[blockstart], blocksize);
+            }
+            bytesread += outlength;
+            buffer    += outlength;
+        }
+        else
+        {
+            memcpy(buffer, tempbuf, blocksize);
+            bytesread += blocksize;
+            buffer    += blocksize;
+        }
+        blockstart += blocksize;
+    }
+
+    /* Delete input buffer, if necessary. */
+    free(tempbuf);
+
+    return bytesread;
+}
+
+int libmpq_file_read_file(mpq_archive* mpq_a, mpq_file* mpq_f, unsigned int filepos, char* buffer, unsigned int toread)
+{
+    unsigned int bytesread = 0;         /* Number of bytes read from the file */
+    unsigned int blockpos;              /* Position in the file aligned to the whole blocks */
+    unsigned int loaded = 0;
+
+    /* File position is greater or equal to file size? */
+    if (filepos >= mpq_f->mpq_b->fsize)
+    {
+        return 0;
+    }
+
+    /* If to few bytes in the file remaining, cut them */
+    if ((mpq_f->mpq_b->fsize - filepos) < toread)
+    {
+        toread = (mpq_f->mpq_b->fsize - filepos);
+    }
+
+    /* Block position in the file */
+    blockpos = filepos & ~(mpq_a->blocksize - 1);
+
+    /*
+     *  Load the first block, if noncomplete. It may be loaded in the cache buffer.
+     *  We have to check if this block is loaded. If not, load it.
+     */
+    if ((filepos % mpq_a->blocksize) != 0)
+    {
+        /* Number of bytes remaining in the buffer */
+        unsigned int tocopy;
+        unsigned int loaded = mpq_a->blocksize;
+
+        /* Check if data are loaded in the cache */
+        if (mpq_f->accessed == FALSE || blockpos != mpq_a->blockpos)
+        {
+
+            /* Load one MPQ block into archive buffer */
+            loaded = libmpq_file_read_block(mpq_a, mpq_f, blockpos, (char*)mpq_a->blockbuf, mpq_a->blocksize);
+            if (loaded == 0)
+            {
+                return 0;
+            }
+
+            /* Save lastly accessed file and block position for later use */
+            mpq_f->accessed = TRUE;
+            mpq_a->blockpos = blockpos;
+            mpq_a->bufpos   = filepos % mpq_a->blocksize;
+        }
+        tocopy = loaded - mpq_a->bufpos;
+        if (tocopy > toread)
+        {
+            tocopy = toread;
+        }
+
+        /* Copy data from block buffer into target buffer */
+        memcpy(buffer, mpq_a->blockbuf + mpq_a->bufpos, tocopy);
+
+        /* Update pointers */
+        toread        -= tocopy;
+        bytesread     += tocopy;
+        buffer        += tocopy;
+        blockpos      += mpq_a->blocksize;
+        mpq_a->bufpos += tocopy;
+
+        /* If all, return. */
+        if (toread == 0)
+        {
+            return bytesread;
+        }
+    }
+
+    /* Load the whole ("middle") blocks only if there are more or equal one block */
+    if (toread > mpq_a->blocksize)
+    {
+        unsigned int blockbytes = toread & ~(mpq_a->blocksize - 1);
+        loaded = libmpq_file_read_block(mpq_a, mpq_f, blockpos, buffer, blockbytes);
+        if (loaded == 0)
+        {
+            return 0;
+        }
+
+        /* Update pointers */
+        toread    -= loaded;
+        bytesread += loaded;
+        buffer    += loaded;
+        blockpos  += loaded;
+
+        /* If all, return. */
+        if (toread == 0)
+        {
+            return bytesread;
+        }
+    }
+
+    /* Load the terminating block */
+    if (toread > 0)
+    {
+        unsigned int tocopy = mpq_a->blocksize;
+
+        /* Check if data are loaded in the cache */
+        if (mpq_f->accessed == FALSE || blockpos != mpq_a->blockpos)
+        {
+
+            /* Load one MPQ block into archive buffer */
+            tocopy = libmpq_file_read_block(mpq_a, mpq_f, blockpos, (char*)mpq_a->blockbuf, mpq_a->blocksize);
+            if (tocopy == 0)
+            {
+                return 0;
+            }
+
+            /* Save lastly accessed file and block position for later use */
+            mpq_f->accessed = TRUE;
+            mpq_a->blockpos = blockpos;
+        }
+        mpq_a->bufpos  = 0;
+
+        /* Check number of bytes read */
+        if (tocopy > toread)
+        {
+            tocopy = toread;
+        }
+
+        memcpy(buffer, mpq_a->blockbuf, tocopy);
+        bytesread     += tocopy;
+        mpq_a->bufpos  = tocopy;
+    }
+
+    /* Return what we've read */
+    return bytesread;
+}
diff -Nuar clean-build/maptools/map_extractor/libmpq03/common.h temp-build/maptools/map_extractor/libmpq03/common.h
--- clean-build/maptools/map_extractor/libmpq03/common.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/common.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,74 @@
+/*
+ *  common.h -- defines and structs used by the config files.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  $Id: common.h,v 1.4 2004/02/12 00:41:55 mbroemme Exp $
+ */
+
+#define LIBMPQ_CONF_FL_INCREMENT    512         /* i hope we did not need more :) */
+#define LIBMPQ_CONF_EXT         ".conf"         /* listdb file seems to be valid with this extension */
+#define LIBMPQ_CONF_HEADER      "LIBMPQ_VERSION"    /* listdb file must include this entry to be valid */
+#define LIBMPQ_CONF_BUFSIZE     4096            /* maximum number of bytes a line in the file could contain */
+
+#define LIBMPQ_CONF_TYPE_CHAR       1           /* value in config file is from type char */
+#define LIBMPQ_CONF_TYPE_INT        2           /* value in config file is from type int */
+
+#define LIBMPQ_CONF_EOPEN_DIR       -1          /* error on open directory */
+#define LIBMPQ_CONF_EVALUE_NOT_FOUND    -2          /* value for the option was not found */
+
+#if defined( __GNUC__ )
+#include <sys/types.h>
+#include <unistd.h>
+
+#define _lseek  lseek
+#define _read   read
+#define _open   open
+#define _write  write
+#define _close  close
+#define _strdup strdup
+
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+#else
+#include <io.h>
+#endif
+
+#ifdef O_LARGEFILE
+#define MPQ_FILE_OPEN_FLAGS (O_RDONLY | O_BINARY | O_LARGEFILE)
+#else
+#define MPQ_FILE_OPEN_FLAGS (O_RDONLY | O_BINARY)
+#endif
+
+#ifndef min
+#define min(a, b) ((a < b) ? a : b)
+#endif
+
+int libmpq_init_buffer(mpq_archive* mpq_a);
+int libmpq_read_hashtable(mpq_archive* mpq_a);
+int libmpq_read_blocktable(mpq_archive* mpq_a);
+int libmpq_file_read_file(mpq_archive* mpq_a, mpq_file* mpq_f, unsigned int filepos, char* buffer, unsigned int toread);
+int libmpq_read_listfile(mpq_archive* mpq_a, FILE* fp);
+
+int libmpq_conf_get_value(FILE* fp, char* search_value, void* return_value, int type, int size);
+char* libmpq_conf_delete_char(char* buf, char* chars);
+int libmpq_conf_get_array(FILE* fp, char* search_value, char** *filelist, int* entries);
+int libmpq_free_listfile(char** filelist);
+int libmpq_read_listfile(mpq_archive* mpq_a, FILE* fp);
+
+unsigned int libmpq_lseek(mpq_archive* mpq_a, unsigned int pos);
diff -Nuar clean-build/maptools/map_extractor/libmpq03/explode.cpp temp-build/maptools/map_extractor/libmpq03/explode.cpp
--- clean-build/maptools/map_extractor/libmpq03/explode.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/explode.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,504 @@
+/*
+ *  explode.c -- explode function of PKWARE data compression library.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of pkware.cpp included
+ *  in stormlib. The C++ version belongs to the following authors,
+ *
+ *  Ladislav Zezula <ladik.zezula.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <assert.h>
+#include <string.h>
+
+#include "mpq.h"
+#include "explode.h"
+
+/* Tables */
+static unsigned char pkzip_dist_bits[] =
+{
+    0x02, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
+};
+
+static unsigned char pkzip_dist_code[] =
+{
+    0x03, 0x0D, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3E, 0x1E, 0x2E, 0x0E, 0x36, 0x16, 0x26, 0x06, 0x3A,
+    0x1A, 0x2A, 0x0A, 0x32, 0x12, 0x22, 0x42, 0x02, 0x7C, 0x3C, 0x5C, 0x1C, 0x6C, 0x2C, 0x4C, 0x0C,
+    0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04, 0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
+    0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50, 0x90, 0x10, 0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00
+};
+
+static unsigned char pkzip_clen_bits[] =
+{
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
+};
+
+static unsigned short pkzip_len_base[] =
+{
+    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
+    0x0008, 0x000A, 0x000E, 0x0016, 0x0026, 0x0046, 0x0086, 0x0106
+};
+
+static unsigned char pkzip_slen_bits[] =
+{
+    0x03, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07
+};
+
+static unsigned char pkzip_len_code[] =
+{
+    0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14, 0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00
+};
+
+static unsigned char pkzip_bits_asc[] =
+{
+    0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x0C, 0x0C, 0x07, 0x0C, 0x0C,
+    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+    0x04, 0x0A, 0x08, 0x0C, 0x0A, 0x0C, 0x0A, 0x08, 0x07, 0x07, 0x08, 0x09, 0x07, 0x06, 0x07, 0x08,
+    0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x07, 0x07, 0x08, 0x08, 0x0C, 0x0B, 0x07, 0x09, 0x0B,
+    0x0C, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x08, 0x08, 0x06, 0x0B, 0x09, 0x06, 0x07, 0x06, 0x06,
+    0x07, 0x0B, 0x06, 0x06, 0x06, 0x07, 0x09, 0x08, 0x09, 0x09, 0x0B, 0x08, 0x0B, 0x09, 0x0C, 0x08,
+    0x0C, 0x05, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05, 0x0B, 0x07, 0x05, 0x06, 0x05, 0x05,
+    0x06, 0x0A, 0x05, 0x05, 0x05, 0x05, 0x08, 0x07, 0x08, 0x08, 0x0A, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C,
+    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
+    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
+    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
+    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+    0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D,
+    0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D
+};
+
+static unsigned short pkzip_code_asc[] =
+{
+    0x0490, 0x0FE0, 0x07E0, 0x0BE0, 0x03E0, 0x0DE0, 0x05E0, 0x09E0,
+    0x01E0, 0x00B8, 0x0062, 0x0EE0, 0x06E0, 0x0022, 0x0AE0, 0x02E0,
+    0x0CE0, 0x04E0, 0x08E0, 0x00E0, 0x0F60, 0x0760, 0x0B60, 0x0360,
+    0x0D60, 0x0560, 0x1240, 0x0960, 0x0160, 0x0E60, 0x0660, 0x0A60,
+    0x000F, 0x0250, 0x0038, 0x0260, 0x0050, 0x0C60, 0x0390, 0x00D8,
+    0x0042, 0x0002, 0x0058, 0x01B0, 0x007C, 0x0029, 0x003C, 0x0098,
+    0x005C, 0x0009, 0x001C, 0x006C, 0x002C, 0x004C, 0x0018, 0x000C,
+    0x0074, 0x00E8, 0x0068, 0x0460, 0x0090, 0x0034, 0x00B0, 0x0710,
+    0x0860, 0x0031, 0x0054, 0x0011, 0x0021, 0x0017, 0x0014, 0x00A8,
+    0x0028, 0x0001, 0x0310, 0x0130, 0x003E, 0x0064, 0x001E, 0x002E,
+    0x0024, 0x0510, 0x000E, 0x0036, 0x0016, 0x0044, 0x0030, 0x00C8,
+    0x01D0, 0x00D0, 0x0110, 0x0048, 0x0610, 0x0150, 0x0060, 0x0088,
+    0x0FA0, 0x0007, 0x0026, 0x0006, 0x003A, 0x001B, 0x001A, 0x002A,
+    0x000A, 0x000B, 0x0210, 0x0004, 0x0013, 0x0032, 0x0003, 0x001D,
+    0x0012, 0x0190, 0x000D, 0x0015, 0x0005, 0x0019, 0x0008, 0x0078,
+    0x00F0, 0x0070, 0x0290, 0x0410, 0x0010, 0x07A0, 0x0BA0, 0x03A0,
+    0x0240, 0x1C40, 0x0C40, 0x1440, 0x0440, 0x1840, 0x0840, 0x1040,
+    0x0040, 0x1F80, 0x0F80, 0x1780, 0x0780, 0x1B80, 0x0B80, 0x1380,
+    0x0380, 0x1D80, 0x0D80, 0x1580, 0x0580, 0x1980, 0x0980, 0x1180,
+    0x0180, 0x1E80, 0x0E80, 0x1680, 0x0680, 0x1A80, 0x0A80, 0x1280,
+    0x0280, 0x1C80, 0x0C80, 0x1480, 0x0480, 0x1880, 0x0880, 0x1080,
+    0x0080, 0x1F00, 0x0F00, 0x1700, 0x0700, 0x1B00, 0x0B00, 0x1300,
+    0x0DA0, 0x05A0, 0x09A0, 0x01A0, 0x0EA0, 0x06A0, 0x0AA0, 0x02A0,
+    0x0CA0, 0x04A0, 0x08A0, 0x00A0, 0x0F20, 0x0720, 0x0B20, 0x0320,
+    0x0D20, 0x0520, 0x0920, 0x0120, 0x0E20, 0x0620, 0x0A20, 0x0220,
+    0x0C20, 0x0420, 0x0820, 0x0020, 0x0FC0, 0x07C0, 0x0BC0, 0x03C0,
+    0x0DC0, 0x05C0, 0x09C0, 0x01C0, 0x0EC0, 0x06C0, 0x0AC0, 0x02C0,
+    0x0CC0, 0x04C0, 0x08C0, 0x00C0, 0x0F40, 0x0740, 0x0B40, 0x0340,
+    0x0300, 0x0D40, 0x1D00, 0x0D00, 0x1500, 0x0540, 0x0500, 0x1900,
+    0x0900, 0x0940, 0x1100, 0x0100, 0x1E00, 0x0E00, 0x0140, 0x1600,
+    0x0600, 0x1A00, 0x0E40, 0x0640, 0x0A40, 0x0A00, 0x1200, 0x0200,
+    0x1C00, 0x0C00, 0x1400, 0x0400, 0x1800, 0x0800, 0x1000, 0x0000
+};
+
+/* Local variables */
+static char copyright[] = "PKWARE Data Compression Library for Win32\r\n"
+                          "Copyright 1989-1995 PKWARE Inc.  All Rights Reserved\r\n"
+                          "Patent No. 5,051,745\r\n"
+                          "PKWARE Data Compression Library Reg. U.S. Pat. and Tm. Off.\r\n"
+                          "Version 1.11\r\n";
+
+/* Local functions */
+static void libmpq_pkzip_gen_decode_tabs(long count, unsigned char* bits, unsigned char* code, unsigned char* buf2)
+{
+    long i;
+
+    for (i = count - 1; i >= 0; i--)        /* EBX - count */
+    {
+        unsigned long idx1 = code[i];
+        unsigned long idx2 = 1 << bits[i];
+        do
+        {
+            buf2[idx1] = (unsigned char)i;
+            idx1      += idx2;
+        }
+        while (idx1 < 0x100);
+    }
+}
+
+static void libmpq_pkzip_gen_asc_tabs(pkzip_data_cmp* mpq_pkzip)
+{
+    unsigned short* code_asc = &pkzip_code_asc[0xFF];
+    unsigned long acc, add;
+    unsigned short count;
+
+    for (count = 0x00FF; code_asc >= pkzip_code_asc; code_asc--, count--)
+    {
+        unsigned char* bits_asc = mpq_pkzip->bits_asc + count;
+        unsigned char bits_tmp = *bits_asc;
+
+        if (bits_tmp <= 8)
+        {
+            add = (1 << bits_tmp);
+            acc = *code_asc;
+            do
+            {
+                mpq_pkzip->offs_2c34[acc] = (unsigned char)count;
+                acc += add;
+            }
+            while (acc < 0x100);
+        }
+        else
+        {
+            if ((acc = (*code_asc & 0xFF)) != 0)
+            {
+                mpq_pkzip->offs_2c34[acc] = 0xFF;
+                if (*code_asc & 0x3F)
+                {
+                    bits_tmp -= 4;
+                    *bits_asc = bits_tmp;
+                    add = (1 << bits_tmp);
+                    acc = *code_asc >> 4;
+                    do
+                    {
+                        mpq_pkzip->offs_2d34[acc] = (unsigned char)count;
+                        acc += add;
+                    }
+                    while (acc < 0x100);
+                }
+                else
+                {
+                    bits_tmp -= 6;
+                    *bits_asc = bits_tmp;
+                    add = (1 << bits_tmp);
+                    acc = *code_asc >> 6;
+                    do
+                    {
+                        mpq_pkzip->offs_2e34[acc] = (unsigned char)count;
+                        acc += add;
+                    }
+                    while (acc < 0x80);
+                }
+            }
+            else
+            {
+                bits_tmp -= 8;
+                *bits_asc = bits_tmp;
+                add = (1 << bits_tmp);
+                acc = *code_asc >> 8;
+                do
+                {
+                    mpq_pkzip->offs_2eb4[acc] = (unsigned char)count;
+                    acc += add;
+                }
+                while (acc < 0x100);
+            }
+        }
+    }
+}
+
+/*
+ *  Skips given number of bits in bit buffer. Result is stored in mpq_pkzip->bit_buf
+ *  If no data in input buffer, returns true
+ */
+static int libmpq_pkzip_skip_bits(pkzip_data_cmp* mpq_pkzip, unsigned long bits)
+{
+    /* If number of bits required is less than number of (bits in the buffer) ? */
+    if (bits <= mpq_pkzip->extra_bits)
+    {
+        mpq_pkzip->extra_bits -= bits;
+        mpq_pkzip->bit_buf >>= bits;
+        return 0;
+    }
+
+    /* Load input buffer if necessary */
+    mpq_pkzip->bit_buf >>= mpq_pkzip->extra_bits;
+    if (mpq_pkzip->in_pos == mpq_pkzip->in_bytes)
+    {
+        mpq_pkzip->in_pos = sizeof(mpq_pkzip->in_buf);
+        if ((mpq_pkzip->in_bytes = mpq_pkzip->read_buf((char*)mpq_pkzip->in_buf, &mpq_pkzip->in_pos, mpq_pkzip->param)) == 0)
+        {
+            return 1;
+        }
+        mpq_pkzip->in_pos = 0;
+    }
+
+    /* Update bit buffer */
+    mpq_pkzip->bit_buf |= (mpq_pkzip->in_buf[mpq_pkzip->in_pos++] << 8);
+    mpq_pkzip->bit_buf >>= (bits - mpq_pkzip->extra_bits);
+    mpq_pkzip->extra_bits = (mpq_pkzip->extra_bits - bits) + 8;
+    return 0;
+}
+
+/*
+ *  Decompress the imploded data using coded literals.
+ *  Returns: 0x000 - 0x0FF : One byte from compressed file.
+ *           0x100 - 0x305 : Copy previous block (0x100 = 1 byte)
+ *           0x306         : Out of buffer (?)
+ */
+static unsigned long libmpq_pkzip_explode_lit(pkzip_data_cmp* mpq_pkzip)
+{
+    unsigned long bits;             /* Number of bits to skip */
+    unsigned long value;                /* Position in buffers */
+
+    /* Test the current bit in byte buffer. If is not set, simply return the next byte. */
+    if (mpq_pkzip->bit_buf & 1)
+    {
+
+        /* Skip current bit in the buffer. */
+        if (libmpq_pkzip_skip_bits(mpq_pkzip, 1))
+        {
+            return 0x306;
+        }
+
+        /* The next bits are position in buffers. */
+        value = mpq_pkzip->pos2[(mpq_pkzip->bit_buf & 0xFF)];
+
+        /* Get number of bits to skip */
+        if (libmpq_pkzip_skip_bits(mpq_pkzip, mpq_pkzip->slen_bits[value]))
+        {
+            return 0x306;
+        }
+        if ((bits = mpq_pkzip->clen_bits[value]) != 0)
+        {
+            unsigned long val2 = mpq_pkzip->bit_buf & ((1 << bits) - 1);
+            if (libmpq_pkzip_skip_bits(mpq_pkzip, bits))
+            {
+                if ((value + val2) != 0x10E)
+                {
+                    return 0x306;
+                }
+            }
+            value = mpq_pkzip->len_base[value] + val2;
+        }
+        return value + 0x100;           /* Return number of bytes to repeat */
+    }
+
+    /* Skip one bit */
+    if (libmpq_pkzip_skip_bits(mpq_pkzip, 1))
+    {
+        return 0x306;
+    }
+
+    /* If the binary compression type, read 8 bits and return them as one byte. */
+    if (mpq_pkzip->cmp_type == LIBMPQ_PKZIP_CMP_BINARY)
+    {
+        value = mpq_pkzip->bit_buf & 0xFF;
+        if (libmpq_pkzip_skip_bits(mpq_pkzip, 8))
+        {
+            return 0x306;
+        }
+        return value;
+    }
+
+    /* When ASCII compression ... */
+    if (mpq_pkzip->bit_buf & 0xFF)
+    {
+        value = mpq_pkzip->offs_2c34[mpq_pkzip->bit_buf & 0xFF];
+        if (value == 0xFF)
+        {
+            if (mpq_pkzip->bit_buf & 0x3F)
+            {
+                if (libmpq_pkzip_skip_bits(mpq_pkzip, 4))
+                {
+                    return 0x306;
+                }
+                value = mpq_pkzip->offs_2d34[mpq_pkzip->bit_buf & 0xFF];
+            }
+            else
+            {
+                if (libmpq_pkzip_skip_bits(mpq_pkzip, 6))
+                {
+                    return 0x306;
+                }
+                value = mpq_pkzip->offs_2e34[mpq_pkzip->bit_buf & 0x7F];
+            }
+        }
+    }
+    else
+    {
+        if (libmpq_pkzip_skip_bits(mpq_pkzip, 8))
+        {
+            return 0x306;
+        }
+        value = mpq_pkzip->offs_2eb4[mpq_pkzip->bit_buf & 0xFF];
+    }
+    return libmpq_pkzip_skip_bits(mpq_pkzip, mpq_pkzip->bits_asc[value]) ? 0x306 : value;
+}
+
+/*
+ *  Retrieves the number of bytes to move back.
+ */
+static unsigned long libmpq_pkzip_explode_dist(pkzip_data_cmp* mpq_pkzip, unsigned long length)
+{
+    unsigned long pos  = mpq_pkzip->pos1[(mpq_pkzip->bit_buf & 0xFF)];
+    unsigned long skip = mpq_pkzip->dist_bits[pos]; /* Number of bits to skip */
+
+    /* Skip the appropriate number of bits */
+    if (libmpq_pkzip_skip_bits(mpq_pkzip, skip) == 1)
+    {
+        return 0;
+    }
+    if (length == 2)
+    {
+        pos = (pos << 2) | (mpq_pkzip->bit_buf & 0x03);
+        if (libmpq_pkzip_skip_bits(mpq_pkzip, 2) == 1)
+        {
+            return 0;
+        }
+    }
+    else
+    {
+        pos = (pos << mpq_pkzip->dsize_bits) | (mpq_pkzip->bit_buf & mpq_pkzip->dsize_mask);
+
+        /* Skip the bits */
+        if (libmpq_pkzip_skip_bits(mpq_pkzip, mpq_pkzip->dsize_bits) == 1)
+        {
+            return 0;
+        }
+    }
+    return pos + 1;
+}
+
+static unsigned long libmpq_pkzip_expand(pkzip_data_cmp* mpq_pkzip)
+{
+    unsigned int copy_bytes;            /* Number of bytes to copy */
+    unsigned long one_byte;             /* One byte from compressed file */
+    unsigned long result;
+
+    mpq_pkzip->out_pos = 0x1000;            /* Initialize output buffer position */
+
+    /* If end of data or error, terminate decompress */
+    while ((result = one_byte = libmpq_pkzip_explode_lit(mpq_pkzip)) < 0x305)
+    {
+
+        /* If one byte is greater than 0x100, means "Repeat n - 0xFE bytes" */
+        if (one_byte >= 0x100)
+        {
+            unsigned char* source;      /* ECX */
+            unsigned char* target;      /* EDX */
+            unsigned long copy_length = one_byte - 0xFE;
+            unsigned long move_back;
+
+            /* Get length of data to copy */
+            if ((move_back = libmpq_pkzip_explode_dist(mpq_pkzip, copy_length)) == 0)
+            {
+                result = 0x306;
+                break;
+            }
+
+            /* Target and source pointer */
+            target = &mpq_pkzip->out_buf[mpq_pkzip->out_pos];
+            source = target - move_back;
+            mpq_pkzip->out_pos += copy_length;
+            while (copy_length-- > 0)
+            {
+                *target++ = *source++;
+            }
+        }
+        else
+        {
+            mpq_pkzip->out_buf[mpq_pkzip->out_pos++] = (unsigned char)one_byte;
+        }
+
+        /*
+         * If number of extracted bytes has reached 1/2 of output buffer,
+         * flush output buffer.
+         */
+        if (mpq_pkzip->out_pos >= 0x2000)
+        {
+
+            /* Copy decompressed data into user buffer. */
+            copy_bytes = 0x1000;
+            mpq_pkzip->write_buf((char*)&mpq_pkzip->out_buf[0x1000], &copy_bytes, mpq_pkzip->param);
+
+            /* If there are some data left, keep them alive */
+            memcpy(mpq_pkzip->out_buf, &mpq_pkzip->out_buf[0x1000], mpq_pkzip->out_pos - 0x1000);
+            mpq_pkzip->out_pos -= 0x1000;
+        }
+    }
+    copy_bytes = mpq_pkzip->out_pos - 0x1000;
+    mpq_pkzip->write_buf((char*)&mpq_pkzip->out_buf[0x1000], &copy_bytes, mpq_pkzip->param);
+    return result;
+}
+
+/*
+ * Main exploding function.
+ */
+unsigned int libmpq_pkzip_explode(
+    unsigned int (*read_buf)(char* buf, unsigned  int* size, void* param),
+    void (*write_buf)(char* buf, unsigned  int* size, void* param),
+    char*        work_buf,
+    void*        param)
+{
+
+    pkzip_data_cmp* mpq_pkzip = (pkzip_data_cmp*)work_buf;
+
+    /* Set the whole work buffer to zeros */
+    memset(mpq_pkzip, 0, sizeof(pkzip_data_cmp));
+
+    /* Initialize work struct and load compressed data */
+    mpq_pkzip->read_buf   = read_buf;
+    mpq_pkzip->write_buf  = write_buf;
+    mpq_pkzip->param      = param;
+    mpq_pkzip->in_pos     = sizeof(mpq_pkzip->in_buf);
+    mpq_pkzip->in_bytes   = mpq_pkzip->read_buf((char*)mpq_pkzip->in_buf, &mpq_pkzip->in_pos, mpq_pkzip->param);
+    if (mpq_pkzip->in_bytes <= 4)
+    {
+        return LIBMPQ_PKZIP_CMP_BAD_DATA;
+    }
+    mpq_pkzip->cmp_type   = mpq_pkzip->in_buf[0];   /* Get the compression type */
+    mpq_pkzip->dsize_bits = mpq_pkzip->in_buf[1];   /* Get the dictionary size */
+    mpq_pkzip->bit_buf    = mpq_pkzip->in_buf[2];   /* Initialize 16-bit bit buffer */
+    mpq_pkzip->extra_bits = 0;          /* Extra (over 8) bits */
+    mpq_pkzip->in_pos     = 3;          /* Position in input buffer */
+
+    /* Test for the valid dictionary size */
+    if (4 > mpq_pkzip->dsize_bits || mpq_pkzip->dsize_bits > 6)
+    {
+        return LIBMPQ_PKZIP_CMP_INV_DICTSIZE;
+    }
+    mpq_pkzip->dsize_mask = 0xFFFF >> (0x10 - mpq_pkzip->dsize_bits);   /* Shifted by 'sar' instruction */
+    if (mpq_pkzip->cmp_type != LIBMPQ_PKZIP_CMP_BINARY)
+    {
+        if (mpq_pkzip->cmp_type != LIBMPQ_PKZIP_CMP_ASCII)
+        {
+            return LIBMPQ_PKZIP_CMP_INV_MODE;
+        }
+        memcpy(mpq_pkzip->bits_asc, pkzip_bits_asc, sizeof(mpq_pkzip->bits_asc));
+        libmpq_pkzip_gen_asc_tabs(mpq_pkzip);
+    }
+    memcpy(mpq_pkzip->slen_bits, pkzip_slen_bits, sizeof(mpq_pkzip->slen_bits));
+    libmpq_pkzip_gen_decode_tabs(0x10, mpq_pkzip->slen_bits, pkzip_len_code, mpq_pkzip->pos2);
+    memcpy(mpq_pkzip->clen_bits, pkzip_clen_bits, sizeof(mpq_pkzip->clen_bits));
+    memcpy(mpq_pkzip->len_base, pkzip_len_base, sizeof(mpq_pkzip->len_base));
+    memcpy(mpq_pkzip->dist_bits, pkzip_dist_bits, sizeof(mpq_pkzip->dist_bits));
+    libmpq_pkzip_gen_decode_tabs(0x40, mpq_pkzip->dist_bits, pkzip_dist_code, mpq_pkzip->pos1);
+    if (libmpq_pkzip_expand(mpq_pkzip) != 0x306)
+    {
+        return LIBMPQ_PKZIP_CMP_NO_ERROR;
+    }
+    return LIBMPQ_PKZIP_CMP_ABORT;
+}
diff -Nuar clean-build/maptools/map_extractor/libmpq03/explode.h temp-build/maptools/map_extractor/libmpq03/explode.h
--- clean-build/maptools/map_extractor/libmpq03/explode.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/explode.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,88 @@
+/*
+ *  explode.h -- header file for PKWARE data decompression library
+ *               used by mpq-tools.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of pklib.h included
+ *  in stormlib. The C++ version belongs to the following authors,
+ *
+ *  Ladislav Zezula <ladik.zezula.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _EXPLODE_H
+#define _EXPLODE_H
+
+#define LIBMPQ_PKZIP_EXP_BUFFER_SIZE    12596       /* Size of decompress buffer */
+#define LIBMPQ_PKZIP_CMP_BINARY     0       /* Binary compression */
+#define LIBMPQ_PKZIP_CMP_ASCII      1       /* Ascii compression */
+#define LIBMPQ_PKZIP_CMP_NO_ERROR   0
+#define LIBMPQ_PKZIP_CMP_INV_DICTSIZE   1
+#define LIBMPQ_PKZIP_CMP_INV_MODE   2
+#define LIBMPQ_PKZIP_CMP_BAD_DATA   3
+#define LIBMPQ_PKZIP_CMP_ABORT      4
+
+/* Compression structure (size: 12596 bytes on x86-32) */
+typedef struct
+{
+    unsigned long   offs0000;       /* 0000 */
+    unsigned long   cmp_type;       /* 0004 - Compression type (LIBMPQ_PZIP_CMP_BINARY or LIBMPQ_PKZIP_CMP_ASCII) */
+    unsigned long   out_pos;        /* 0008 - Position in output buffer */
+    unsigned long   dsize_bits;     /* 000C - Dict size (4, 5, 6 for 0x400, 0x800, 0x1000) */
+    unsigned long   dsize_mask;     /* 0010 - Dict size bitmask (0x0F, 0x1F, 0x3F for 0x400, 0x800, 0x1000) */
+    unsigned long   bit_buf;        /* 0014 - 16-bit buffer for processing input data */
+    unsigned long   extra_bits;     /* 0018 - Number of extra (above 8) bits in bit buffer */
+    unsigned int    in_pos;         /* 001C - Position in in_buf */
+    unsigned long   in_bytes;       /* 0020 - Number of bytes in input buffer */
+    void*        param;         /* 0024 - Custom parameter */
+    unsigned int (*read_buf)(char* buf, unsigned  int* size, void* param);      /* 0028 */
+    void (*write_buf)(char* buf, unsigned  int* size, void* param);         /* 002C */
+    unsigned char   out_buf[0x2000];    /* 0030 - Output circle buffer. Starting position is 0x1000 */
+    unsigned char   offs_2030[0x204];   /* 2030 - ??? */
+    unsigned char   in_buf[0x800];      /* 2234 - Buffer for data to be decompressed */
+    unsigned char   pos1[0x100];        /* 2A34 - Positions in buffers */
+    unsigned char   pos2[0x100];        /* 2B34 - Positions in buffers */
+    unsigned char   offs_2c34[0x100];   /* 2C34 - Buffer for */
+    unsigned char   offs_2d34[0x100];   /* 2D34 - Buffer for */
+    unsigned char   offs_2e34[0x80];    /* 2EB4 - Buffer for */
+    unsigned char   offs_2eb4[0x100];   /* 2EB4 - Buffer for */
+    unsigned char   bits_asc[0x100];    /* 2FB4 - Buffer for */
+    unsigned char   dist_bits[0x40];    /* 30B4 - Numbers of bytes to skip copied block length */
+    unsigned char   slen_bits[0x10];    /* 30F4 - Numbers of bits for skip copied block length */
+    unsigned char   clen_bits[0x10];    /* 3104 - Number of valid bits for copied block */
+    unsigned short  len_base[0x10];     /* 3114 - Buffer for */
+} pkzip_data_cmp;
+// __attribute__ ((packed)) pkzip_data_cmp;
+
+typedef struct
+{
+    char*        in_buf;    /* Pointer to input data buffer */
+    unsigned int    in_pos;     /* Current offset in input data buffer */
+    int     in_bytes;   /* Number of bytes in the input buffer */
+    char*        out_buf;   /* Pointer to output data buffer */
+    unsigned int    out_pos;    /* Position in the output buffer */
+    int     max_out;    /* Maximum number of bytes in the output buffer */
+} pkzip_data;
+
+extern unsigned int libmpq_pkzip_explode(
+    unsigned int (*read_buf)(char* buf, unsigned int* size, void* param),
+    void (*write_buf)(char* buf, unsigned int* size, void* param),
+    char*        work_buf,
+    void*        param
+);
+
+#endif                  /* _EXPLODE_H */
diff -Nuar clean-build/maptools/map_extractor/libmpq03/extract.cpp temp-build/maptools/map_extractor/libmpq03/extract.cpp
--- clean-build/maptools/map_extractor/libmpq03/extract.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/extract.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,283 @@
+/*
+ *  extract.c -- global extracting function for all known file compressions
+ *               in a MPQ archive.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#define HAVE_LIBZ
+#ifdef HAVE_LIBZ
+#include <zlib.h>
+#endif
+
+#include "mpq.h"
+#include "explode.h"
+#include "huffman.h"
+
+#include "wave.h"
+
+/*
+ *  Support functions for PKWARE data compression library.
+ *
+ *  Function loads data from the input buffer. Used by mpq_pkzip
+ *  "implode" and "explode" function as user-defined callback.
+ *  Returns number of bytes loaded.
+ *
+ *  char * buf          - Pointer to a buffer where to store loaded data
+ *  unsigned int * size - Max. number of bytes to read
+ *  void * param        - Custom pointer, parameter of implode/explode
+ */
+static unsigned int libmpq_pkzip_read_input_data(char* buf, unsigned int* size, void* param)
+{
+    pkzip_data* info = (pkzip_data*)param;
+    unsigned int max_avail = (info->in_bytes - info->in_pos);
+    unsigned int to_read = *size;
+
+    /* Check the case when not enough data available */
+    if (to_read > max_avail)
+    {
+        to_read = max_avail;
+    }
+
+    /* Load data and increment offsets */
+    memcpy(buf, info->in_buf + info->in_pos, to_read);
+    info->in_pos += to_read;
+
+    return to_read;
+}
+
+/*
+ *  Support functions for PKWARE data compression library.
+ *
+ *  Function for store output data. Used by mpq_pkzip "implode" and
+ *  "explode" as user-defined callback.
+ *
+ *  char * buf          - Pointer to data to be written
+ *  unsigned int * size - Number of bytes to write
+ *  void * param        - Custom pointer, parameter of implode/explode
+ */
+static void libmpq_pkzip_write_output_data(char* buf, unsigned int* size, void* param)
+{
+    pkzip_data* info = (pkzip_data*)param;
+    unsigned int max_write = (info->max_out - info->out_pos);
+    unsigned int to_write = *size;
+
+    /* Check the case when not enough space in the output buffer */
+    if (to_write > max_write)
+    {
+        to_write = max_write;
+    }
+
+    /* Write output data and increments offsets */
+    memcpy(info->out_buf + info->out_pos, buf, to_write);
+    info->out_pos += to_write;
+}
+
+int libmpq_pkzip_decompress(char* out_buf, int* out_length, char* in_buf, int in_length)
+{
+    pkzip_data info;                    /* Data information */
+    char* work_buf = (char*)malloc(LIBMPQ_PKZIP_EXP_BUFFER_SIZE);   /* mpq_pkzip work buffer */
+
+    /* Fill data information structure */
+    info.in_buf   = in_buf;
+    info.in_pos   = 0;
+    info.in_bytes = in_length;
+    info.out_buf  = out_buf;
+    info.out_pos  = 0;
+    info.max_out  = *out_length;
+
+    /* Do the decompression */
+    libmpq_pkzip_explode(libmpq_pkzip_read_input_data, libmpq_pkzip_write_output_data, work_buf, &info);
+    *out_length = info.out_pos;
+    free(work_buf);
+    return 0;
+}
+
+int libmpq_wave_decompress_mono(char* out_buf, int* out_length, char* in_buf, int in_length)
+{
+    *out_length = libmpq_wave_decompress((unsigned char*)out_buf, *out_length, (unsigned char*)in_buf, in_length, 1);
+    return 1;
+}
+
+int libmpq_wave_decompress_stereo(char* out_buf, int* out_length, char* in_buf, int in_length)
+{
+    *out_length = libmpq_wave_decompress((unsigned char*)out_buf, *out_length, (unsigned char*)in_buf, in_length, 2);
+    return 1;
+}
+
+int libmpq_zlib_decompress(char* out_buf, int* out_length, char* in_buf, int in_length)
+{
+#ifdef HAVE_LIBZ
+    z_stream z;                 /* Stream information for zlib */
+    int result;
+
+    /* Fill the stream structure for zlib */
+    z.next_in   = (Bytef*)in_buf;
+    z.avail_in  = (uInt)in_length;
+    z.total_in  = in_length;
+    z.next_out  = (Bytef*)out_buf;
+    z.avail_out = *out_length;
+    z.total_out = 0;
+    z.zalloc    = NULL;
+    z.zfree     = NULL;
+
+    /* Initialize the decompression structure. Storm.dll uses zlib version 1.1.3 */
+    if ((result = inflateInit(&z)) == 0)
+    {
+
+        /* Call zlib to decompress the data */
+        result = inflate(&z, Z_FINISH);
+        *out_length = z.total_out;
+        inflateEnd(&z);
+    }
+    return result;
+#else
+    memset(out_buf, '0', *out_length);
+    return 0;
+#endif
+}
+
+/*
+ *  Huffmann decompression routine. The in_length parameter is not used, but needs
+ *  to be specified due to compatibility reasons.
+ *
+ *  1500F5F0
+ */
+int libmpq_huff_decompress(char* out_buf, int* out_length, char* in_buf, int in_length)
+{
+    struct huffman_tree*     ht = (huffman_tree*)malloc(sizeof(struct huffman_tree));
+    struct huffman_input_stream* is = (huffman_input_stream*)malloc(sizeof(struct huffman_input_stream));
+    struct huffman_tree_item*    hi = (huffman_tree_item*)malloc(sizeof(struct huffman_tree_item));
+    memset(ht, 0, sizeof(struct huffman_tree));
+    memset(is, 0, sizeof(struct huffman_input_stream));
+    memset(hi, 0, sizeof(struct huffman_tree_item));
+
+    /* Initialize input stream */
+    is->bit_buf  = *(unsigned long*)in_buf;
+    in_buf      += sizeof(unsigned long);
+    is->in_buf   = (unsigned char*)in_buf;
+    is->bits     = 32;
+
+    /* Initialize the Huffmann tree for decompression */
+    libmpq_huff_init_tree(ht, hi, LIBMPQ_HUFF_DECOMPRESS);
+
+    *out_length = libmpq_huff_do_decompress(ht, is, (unsigned char*)out_buf, *out_length);
+
+    free(hi);
+    free(is);
+    free(ht);
+    return 0;
+}
+
+int libmpq_multi_decompress(char* out_buf, int* pout_length, char* in_buf, int in_length)
+{
+    char*        temp_buf = NULL;       /* Temporary storage for decompressed data */
+    char*        work_buf = NULL;       /* Where to store decompressed data */
+    int     out_length = *pout_length;  /* For storage number of output bytes */
+    unsigned    fDecompressions1;       /* Decompressions applied to the block */
+    unsigned    fDecompressions2;       /* Just another copy of decompressions applied to the block */
+    int     count = 0;          /* Counter for every use */
+    int     entries = (sizeof(dcmp_table) / sizeof(decompress_table));
+    int     i;
+
+    /* If the input length is the same as output, do nothing. */
+    if (in_length == out_length)
+    {
+        if (in_buf == out_buf)
+        {
+            return 1;
+        }
+        memcpy(out_buf, in_buf, in_length);
+        return 1;
+    }
+
+    /* Get applied compression types and decrement data length */
+    fDecompressions1 = fDecompressions2 = (unsigned char) * in_buf++;
+    in_length--;
+
+    /* Search decompression table type and get all types of compression */
+    for (i = 0; i < entries; i++)
+    {
+        /* We have to apply this decompression? */
+        if (fDecompressions1 & dcmp_table[i].mask)
+        {
+            count++;
+        }
+
+        /* Clear this flag from temporary variable. */
+        fDecompressions2 &= ~dcmp_table[i].mask;
+    }
+
+    /*
+     *  Check if there is some method unhandled
+     *  (E.g. compressed by future versions)
+     */
+    if (fDecompressions2 != 0)
+    {
+        printf("Unknown Compression\n");
+        return 0;
+    }
+
+    /* If there is more than only one compression, we have to allocate extra buffer */
+    if (count >= 2)
+    {
+        temp_buf = (char*)malloc(out_length);
+    }
+
+    /* Apply all decompressions */
+    for (i = 0, count = 0; i < entries; i++)
+    {
+
+        /* If not used this kind of compression, skip the loop */
+        if (fDecompressions1 & dcmp_table[i].mask)
+        {
+
+            /* If odd case, use target buffer for output, otherwise use allocated tempbuf */
+            work_buf = (count++ & 1) ? temp_buf : out_buf;
+            out_length = *pout_length;
+
+            /* Decompress buffer using corresponding function */
+            dcmp_table[i].decompress(work_buf, &out_length, in_buf, in_length);
+
+            /* Move output length to src length for next compression */
+            in_length = out_length;
+            in_buf = work_buf;
+        }
+    }
+
+    /* If output buffer is not the same like target buffer, we have to copy data */
+    if (work_buf != out_buf)
+    {
+        memcpy(out_buf, in_buf, out_length);
+    }
+    *pout_length = out_length;
+
+    /* Delete temporary buffer, if necessary */
+    if (temp_buf != NULL)
+    {
+        free(temp_buf);
+    }
+    return 1;
+}
diff -Nuar clean-build/maptools/map_extractor/libmpq03/huffman.cpp temp-build/maptools/map_extractor/libmpq03/huffman.cpp
--- clean-build/maptools/map_extractor/libmpq03/huffman.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/huffman.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,947 @@
+/*
+ *  huffman.c -- functions do decompress files in MPQ files which
+ *               uses a modified huffman version.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  Differences between C++ and C version:
+ *
+ *    - Removed the object oriented stuff.
+ *    - Replaced the goto things with some better C code.
+ *
+ *  This source was adepted from the C++ version of huffman.cpp included
+ *  in stormlib. The C++ version belongs to the following authors,
+ *
+ *  Ladislav Zezula <ladik.zezula.net>
+ *  ShadowFlare <BlakFlare@hotmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include <stdlib.h>
+#include <string.h>
+
+#include "mpq.h"
+#include "huffman.h"
+
+unsigned char table1502A630[] =
+{
+
+    /* Data for compression type 0x00 */
+    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
+    0x00, 0x00,
+
+    /* Data for compression type 0x01 */
+    0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08, 0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04, 0x03, 0x05,
+    0x0E, 0x0B, 0x14, 0x13, 0x13, 0x09, 0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02,
+    0x0D, 0x07, 0x09, 0x06, 0x06, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02,
+    0x09, 0x06, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04,
+    0x08, 0x03, 0x04, 0x07, 0x09, 0x05, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02,
+    0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
+    0x06, 0x0A, 0x08, 0x08, 0x06, 0x07, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03,
+    0x04, 0x03, 0x07, 0x07, 0x09, 0x06, 0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02,
+    0x0A, 0x02, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05, 0x02, 0x03,
+    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01,
+    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x04, 0x07, 0x09, 0x08, 0x0C, 0x02,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03,
+    0x04, 0x01, 0x02, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
+    0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x4B,
+    0x00, 0x00,
+
+    /* Data for compression type 0x02 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x23, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x06, 0x0E, 0x10, 0x04,
+    0x06, 0x08, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01,
+    0x01, 0x04, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x03, 0x03, 0x02,
+    0x03, 0x01, 0x03, 0x06, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01,
+    0x01, 0x29, 0x07, 0x16, 0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03, 0x17, 0x10, 0x26, 0x2A,
+    0x10, 0x01, 0x23, 0x23, 0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00,
+
+    /* Data for compression type 0x03 */
+    0xFF, 0x0B, 0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02, 0x02, 0x01, 0x04, 0x02, 0x01, 0x03,
+    0x09, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
+    0x05, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+    0x02, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
+    0x0A, 0x04, 0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01,
+    0x05, 0x02, 0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03,
+    0x01, 0x03, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x05, 0x01, 0x03, 0x01, 0x03, 0x03,
+    0x02, 0x01, 0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+    0x02, 0x02, 0x01, 0x0A, 0x02, 0x05, 0x01, 0x01, 0x02, 0x07, 0x02, 0x17, 0x01, 0x05, 0x01, 0x01,
+    0x0E, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+    0x06, 0x02, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
+    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11,
+    0x00, 0x00,
+
+    /* Data for compression type 0x04 */
+    0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64, 0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00,
+
+    /* Data for compression type 0x05 */
+    0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B, 0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88, 0x80, 0x82,
+    0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B, 0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41, 0x37, 0x37,
+    0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21, 0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10, 0x0D, 0x0D,
+    0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04, 0x19, 0x18,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00,
+
+    /* Data for compression type 0x06 */
+    0xC3, 0xCB, 0xF5, 0x41, 0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xBF, 0xCC, 0xF2, 0x40, 0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x7A, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00,
+
+    /* Data for compression type 0x07 */
+    0xC3, 0xD9, 0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB, 0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xBD, 0xD9, 0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE, 0xF0, 0x2C, 0xFB, 0x5C, 0xFF, 0x18,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x70, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00,
+
+    /* Data for compression type 0x08 */
+    0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18, 0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10,
+    0xEE, 0xAF, 0xE4, 0x2C, 0xEA, 0x5A, 0xDE, 0x15, 0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18, 0xE7, 0x95, 0xD8, 0x23, 0xDB, 0x49, 0xD0, 0x11,
+    0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15, 0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF, 0x13,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x5F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00
+};
+
+/* Gets previous Huffman tree item (?) */
+struct huffman_tree_item* libmpq_huff_get_prev_item(struct huffman_tree_item* hi, long value)
+{
+    if (PTR_INT(hi->prev) < 0)
+    {
+        return PTR_NOT(hi->prev);
+    }
+    if (value < 0)
+    {
+        value = hi - hi->next->prev;
+    }
+    return hi->prev + value;
+}
+
+/* 1500BC90 */
+static void libmpq_huff_remove_item(struct huffman_tree_item* hi)
+{
+    struct huffman_tree_item* temp;         /* EDX */
+
+    if (hi->next != NULL)
+    {
+        temp = hi->prev;
+        if (PTR_INT(temp) <= 0)
+        {
+            temp = PTR_NOT(temp);
+        }
+        else
+        {
+            temp += (hi - hi->next->prev);
+        }
+        temp->next          = hi->next;
+        hi->next->prev      = hi->prev;
+        hi->next = hi->prev = NULL;
+    }
+}
+
+static void libmpq_huff_insert_item(struct huffman_tree_item** p_item, struct huffman_tree_item* item, unsigned long where, struct huffman_tree_item* item2)
+{
+    struct huffman_tree_item* next = item->next;    /* EDI - next to the first item */
+    struct huffman_tree_item* prev = item->prev;    /* ESI - prev to the first item */
+    struct huffman_tree_item* prev2;        /* Pointer to previous item */
+    long next2;                 /* Pointer to the next item */
+
+    /* The same code like in mpq_huff_remove_item(); */
+    if (next != 0)                  /* If the first item already has next one */
+    {
+        if (PTR_INT(prev) < 0)
+        {
+            prev = PTR_NOT(prev);
+        }
+        else
+        {
+            prev += (item - next->prev);
+        }
+
+        /*
+         * 150083C1
+         * Remove the item from the tree
+         */
+        prev->next = next;
+        next->prev = prev;
+
+        /* Invalidate 'prev' and 'next' pointer */
+        item->next = 0;
+        item->prev = 0;
+    }
+
+    if (item2 == NULL)                  /* EDX - If the second item is not entered, */
+    {
+        item2 = PTR_PTR(&p_item[1]);        /* take the first tree item */
+    }
+
+    switch (where)
+    {
+        case SWITCH_ITEMS:          /* Switch the two items */
+            item->next  = item2->next;  /* item2->next (Pointer to pointer to first) */
+            item->prev  = item2->next->prev;
+            item2->next->prev = item;
+            item2->next = item;     /* Set the first item */
+            return;
+        case INSERT_ITEM:           /* Insert as the last item */
+            item->next = item2;     /* Set next item (or pointer to pointer to first item) */
+            item->prev = item2->prev;   /* Set prev item (or last item in the tree) */
+            next2 = PTR_INT(p_item[0]); /* Usually NULL */
+            prev2 = item2->prev;        /* Prev item to the second (or last tree item) */
+            if (PTR_INT(prev2) < 0)
+            {
+                prev2 = PTR_NOT(prev);
+                prev2->next = item;
+                item2->prev = item; /* Next after last item */
+                return;
+            }
+            if (next2 < 0)
+            {
+                next2 = item2 - item2->next->prev;
+            }
+            prev2 += next2;
+            prev2->next = item;
+            item2->prev = item;     /* Set the next/last item */
+            return;
+        default:
+            return;
+    }
+}
+
+/* Builds Huffman tree. Called with the first 8 bits loaded from input stream. */
+static void libmpq_huff_build_tree(struct huffman_tree* ht, unsigned int cmp_type)
+{
+    unsigned long max_byte;             /* [ESP+10] - The greatest character found in table */
+    unsigned char* byte_array;          /* [ESP+1C] - Pointer to unsigned char in table1502A630 */
+    unsigned long i;                /* egcs in linux doesn't like multiple for loops without an explicit i */
+    unsigned int found;             /* Thats needed to replace the goto stuff from original source :) */
+    struct huffman_tree_item** p_item;      /* [ESP+14] - Pointer to Huffman tree item pointer array */
+    struct huffman_tree_item* child1;
+
+    /* Loop while pointer has a negative value. */
+    while (PTR_INT(ht->last) > 0)           /* ESI - Last entry */
+    {
+        struct huffman_tree_item* temp;     /* EAX */
+
+        if (ht->last->next != NULL)         /* ESI->next */
+        {
+            libmpq_huff_remove_item(ht->last);
+        }
+        ht->item3058   = PTR_PTR(&ht->item3054);/* [EDI+4] */
+        ht->last->prev = ht->item3058;      /* EAX */
+        temp           = libmpq_huff_get_prev_item(PTR_PTR(&ht->item3054), PTR_INT(&ht->item3050));
+        temp->next     = ht->last;
+        ht->item3054   = ht->last;
+    }
+
+    /* Clear all pointers in huffman tree item array. */
+    memset(ht->items306C, 0, sizeof(ht->items306C));
+
+    max_byte = 0;                   /* Greatest character found init to zero. */
+    p_item = (struct huffman_tree_item**)&ht->items306C;    /* Pointer to current entry in huffman tree item pointer array */
+
+    /* Ensure we have low 8 bits only */
+    cmp_type   &= 0xFF;
+    byte_array  = table1502A630 + cmp_type * 258;   /* EDI also */
+
+    for (i = 0; i < 0x100; i++, p_item++)
+    {
+        struct huffman_tree_item* item = ht->item3058;  /* Item to be created */
+        struct huffman_tree_item* p_item3 = ht->item3058;
+        unsigned char one_byte = byte_array[i];
+
+        /* Skip all the bytes which are zero. */
+        if (byte_array[i] == 0)
+        {
+            continue;
+        }
+
+        /* If not valid pointer, take the first available item in the array. */
+        if (PTR_INT(item) <= 0)
+        {
+            item = &ht->items0008[ht->items++];
+        }
+
+        /* Insert this item as the top of the tree. */
+        libmpq_huff_insert_item(&ht->item305C, item, SWITCH_ITEMS, NULL);
+
+        item->parent    = NULL;         /* Invalidate child and parent */
+        item->child     = NULL;
+        *p_item         = item;         /* Store pointer into pointer array */
+
+        item->dcmp_byte  = i;           /* Store counter */
+        item->byte_value = one_byte;        /* Store byte value */
+        if (one_byte >= max_byte)
+        {
+            max_byte = one_byte;
+            continue;
+        }
+
+        /* Find the first item which has byte value greater than current one byte */
+        found = 0;
+        if (PTR_INT((p_item3 = ht->last)) > 0)  /* EDI - Pointer to the last item */
+        {
+
+            /* 15006AF7 */
+            if (p_item3 != NULL)
+            {
+                do              /* 15006AFB */
+                {
+                    if (p_item3->byte_value >= one_byte)
+                    {
+                        found = 1;
+                        break;
+                    }
+                    p_item3 = p_item3->prev;
+                }
+                while (PTR_INT(p_item3) > 0);
+            }
+        }
+
+        if (found == 0)
+        {
+            p_item3 = NULL;
+        }
+
+        /* 15006B09 */
+        if (item->next != NULL)
+        {
+            libmpq_huff_remove_item(item);
+        }
+
+        /* 15006B15 */
+        if (p_item3 == NULL)
+        {
+            p_item3 = PTR_PTR(&ht->first);
+        }
+
+        /* 15006B1F */
+        item->next = p_item3->next;
+        item->prev = p_item3->next->prev;
+        p_item3->next->prev = item;
+        p_item3->next = item;
+    }
+
+    /* 15006B4A */
+    for (; i < 0x102; i++)
+    {
+        struct huffman_tree_item** p_item2 = &ht->items306C[i]; /* EDI */
+
+        /* 15006B59  */
+        struct huffman_tree_item* item2 = ht->item3058; /* ESI */
+        if (PTR_INT(item2) <= 0)
+        {
+            item2 = &ht->items0008[ht->items++];
+        }
+        libmpq_huff_insert_item(&ht->item305C, item2, INSERT_ITEM, NULL);
+
+        /* 15006B89 */
+        item2->dcmp_byte  = i;
+        item2->byte_value = 1;
+        item2->parent     = NULL;
+        item2->child      = NULL;
+        *p_item2++        = item2;
+    }
+
+    /* 15006BAA */
+    if (PTR_INT((child1 = ht->last)) > 0)       /* EDI - last item (first child to item */
+    {
+        struct huffman_tree_item* child2;   /* EBP */
+        struct huffman_tree_item* item;     /* ESI */
+
+        /* 15006BB8 */
+        while (PTR_INT((child2 = child1->prev)) > 0)
+        {
+            if (PTR_INT((item = ht->item3058)) <= 0)
+            {
+                item = &ht->items0008[ht->items++];
+            }
+            /* 15006BE3 */
+            libmpq_huff_insert_item(&ht->item305C, item, SWITCH_ITEMS, NULL);
+
+            /* 15006BF3 */
+            item->parent = NULL;
+            item->child  = NULL;
+
+            /*
+             * EDX = child2->byte_value + child1->byte_value;
+             * EAX = child1->byte_value;
+             * ECX = max_byte;      The greatest character (0xFF usually)
+             */
+            item->byte_value = child1->byte_value + child2->byte_value; /* 0x02 */
+            item->child      = child1;  /* Prev item in the */
+            child1->parent   = item;
+            child2->parent   = item;
+
+            /* EAX = item->byte_value; */
+            if (item->byte_value >= max_byte)
+            {
+                max_byte = item->byte_value;
+            }
+            else
+            {
+                struct huffman_tree_item* p_item2 = child2->prev;   /* EDI */
+                found = 0;
+                if (PTR_INT(p_item2) > 0)
+                {
+
+                    /* 15006C2D */
+                    do
+                    {
+                        if (p_item2->byte_value >= item->byte_value)
+                        {
+                            found = 1;
+                            break;
+                        }
+                        p_item2 = p_item2->prev;
+                    }
+                    while (PTR_INT(p_item2) > 0);
+                }
+                if (found == 0)
+                {
+                    p_item2 = NULL;
+                }
+                if (item->next != 0)
+                {
+                    struct huffman_tree_item* temp4 = libmpq_huff_get_prev_item(item, -1);
+                    temp4->next      = item->next;  /* The first item changed */
+                    item->next->prev = item->prev;  /* First->prev changed to negative value */
+                    item->next = NULL;
+                    item->prev = NULL;
+                }
+
+                /* 15006C62 */
+                if (p_item2 == NULL)
+                {
+                    p_item2 = PTR_PTR(&ht->first);
+                }
+                item->next = p_item2->next;     /* Set item with 0x100 byte value */
+                item->prev = p_item2->next->prev;   /* Set item with 0x17 byte value */
+                p_item2->next->prev = item;     /* Changed prev of item with */
+                p_item2->next = item;
+            }
+
+            /* 15006C7B */
+            if (PTR_INT((child1 = child2->prev)) <= 0)
+            {
+                break;
+            }
+        }
+    }
+
+    /* 15006C88 */
+    ht->offs0004 = 1;
+}
+
+/* Gets the whole byte from the input stream. */
+static unsigned long libmpq_huff_get_8bits(struct huffman_input_stream* is)
+{
+    unsigned long one_byte;
+
+    if (is->bits <= 8)
+    {
+        is->bit_buf |= *(unsigned short*)is->in_buf << is->bits;
+        is->in_buf  += sizeof(unsigned short);
+        is->bits    += 16;
+    }
+
+    one_byte      = (is->bit_buf & 0xFF);
+    is->bit_buf >>= 8;
+    is->bits     -= 8;
+
+    return one_byte;
+}
+
+/* Gets 7 bits from the stream. */
+static unsigned long libmpq_huff_get_7bits(struct huffman_input_stream* is)
+{
+    if (is->bits <= 7)
+    {
+        is->bit_buf |= *(unsigned short*)is->in_buf << is->bits;
+        is->in_buf  += sizeof(unsigned short);
+        is->bits    += 16;
+    }
+
+    /* Get 7 bits from input stream. */
+    return (is->bit_buf & 0x7F);
+}
+
+/* Gets one bit from input stream. */
+unsigned long libmpq_huff_get_bit(struct huffman_input_stream* is)
+{
+    unsigned long bit = (is->bit_buf & 1);
+
+    is->bit_buf >>= 1;
+    if (--is->bits == 0)
+    {
+        is->bit_buf  = *(unsigned long*)is->in_buf;
+        is->in_buf  += sizeof(unsigned long);
+        is->bits     = 32;
+    }
+    return bit;
+}
+
+static struct huffman_tree_item* libmpq_huff_call1500E740(struct huffman_tree* ht, unsigned int value)
+{
+    struct huffman_tree_item* p_item1 = ht->item3058;   /* EDX */
+    struct huffman_tree_item* p_item2;          /* EAX */
+    struct huffman_tree_item* p_next;
+    struct huffman_tree_item* p_prev;
+    struct huffman_tree_item** pp_item;
+
+    if (PTR_INT(p_item1) <= 0 || (p_item2 = p_item1) == NULL)
+    {
+        if ((p_item2 = &ht->items0008[ht->items++]) != NULL)
+        {
+            p_item1 = p_item2;
+        }
+        else
+        {
+            p_item1 = ht->first;
+        }
+    }
+    else
+    {
+        p_item1 = p_item2;
+    }
+
+    p_next = p_item1->next;
+    if (p_next != NULL)
+    {
+        p_prev = p_item1->prev;
+        if (PTR_INT(p_prev) <= 0)
+        {
+            p_prev = PTR_NOT(p_prev);
+        }
+        else
+        {
+            p_prev += (p_item1 - p_item1->next->prev);
+        }
+
+        p_prev->next = p_next;
+        p_next->prev = p_prev;
+        p_item1->next = NULL;
+        p_item1->prev = NULL;
+    }
+    pp_item = &ht->first;               /* ESI */
+    if (value > 1)
+    {
+
+        /* ECX = ht->first->next; */
+        p_item1->next = *pp_item;
+        p_item1->prev = (*pp_item)->prev;
+
+        (*pp_item)->prev = p_item2;
+        *pp_item = p_item1;
+
+        p_item2->parent = NULL;
+        p_item2->child  = NULL;
+    }
+    else
+    {
+        p_item1->next = (struct huffman_tree_item*)pp_item;
+        p_item1->prev = pp_item[1];
+        /* EDI = ht->item305C; */
+        p_prev = pp_item[1];            /* ECX */
+        if (p_prev <= 0)
+        {
+            p_prev = PTR_NOT(p_prev);
+            p_prev->next = p_item1;
+            p_prev->prev = p_item2;
+
+            p_item2->parent = NULL;
+            p_item2->child  = NULL;
+        }
+        else
+        {
+            if (PTR_INT(ht->item305C) < 0)
+            {
+                p_prev += (struct huffman_tree_item*)pp_item - (*pp_item)->prev;
+            }
+            else
+            {
+                p_prev += PTR_INT(ht->item305C);
+            }
+
+            p_prev->next    = p_item1;
+            pp_item[1]      = p_item2;
+            p_item2->parent = NULL;
+            p_item2->child  = NULL;
+        }
+    }
+    return p_item2;
+}
+
+static void libmpq_huff_call1500E820(struct huffman_tree* ht, struct huffman_tree_item* p_item)
+{
+    struct huffman_tree_item* p_item1;      /* EDI */
+    struct huffman_tree_item* p_item2 = NULL;   /* EAX */
+    struct huffman_tree_item* p_item3;      /* EDX */
+    struct huffman_tree_item* p_prev;       /* EBX */
+
+    for (; p_item != NULL; p_item = p_item->parent)
+    {
+        p_item->byte_value++;
+
+        for (p_item1 = p_item; ; p_item1 = p_prev)
+        {
+            p_prev = p_item1->prev;
+            if (PTR_INT(p_prev) <= 0)
+            {
+                p_prev = NULL;
+                break;
+            }
+            if (p_prev->byte_value >= p_item->byte_value)
+            {
+                break;
+            }
+        }
+
+        if (p_item1 == p_item)
+        {
+            continue;
+        }
+
+        if (p_item1->next != NULL)
+        {
+            p_item2 = libmpq_huff_get_prev_item(p_item1, -1);
+            p_item2->next = p_item1->next;
+            p_item1->next->prev = p_item1->prev;
+            p_item1->next = NULL;
+            p_item1->prev = NULL;
+        }
+        p_item2 = p_item->next;
+        p_item1->next = p_item2;
+        p_item1->prev = p_item2->prev;
+        p_item2->prev = p_item1;
+        p_item->next = p_item1;
+        if ((p_item2 = p_item1) != NULL)
+        {
+            p_item2 = libmpq_huff_get_prev_item(p_item, -1);
+            p_item2->next = p_item->next;
+            p_item->next->prev = p_item->prev;
+            p_item->next = NULL;
+            p_item->prev = NULL;
+        }
+
+        if (p_prev == NULL)
+        {
+            p_prev = PTR_PTR(&ht->first);
+        }
+        p_item2       = p_prev->next;
+        p_item->next  = p_item2;
+        p_item->prev  = p_item2->prev;
+        p_item2->prev = p_item;
+        p_prev->next  = p_item;
+
+        p_item3 = p_item1->parent->child;
+        p_item2 = p_item->parent;
+        if (p_item2->child == p_item)
+        {
+            p_item2->child = p_item1;
+        }
+
+        if (p_item3 == p_item1)
+        {
+            p_item1->parent->child = p_item;
+        }
+
+        p_item2 = p_item->parent;
+        p_item->parent  = p_item1->parent;
+        p_item1->parent = p_item2;
+        ht->offs0004++;
+    }
+}
+
+int libmpq_huff_do_decompress(struct huffman_tree* ht, struct huffman_input_stream* is, unsigned char* out_buf, unsigned int out_length)
+{
+    unsigned int n8bits;                /* 8 bits loaded from input stream */
+    unsigned int n7bits;                /* 7 bits loaded from input stream */
+    unsigned int found;             /* Thats needed to replace the goto stuff from original source :) */
+    unsigned int dcmp_byte = 0;
+    unsigned long bit_count;
+    struct huffman_decompress* qd;
+    unsigned int has_qd;                /* Can we use quick decompression? */
+    struct huffman_tree_item* p_item1;
+    struct huffman_tree_item* p_item2;
+    unsigned char* out_pos = out_buf;
+
+    /* Test the output length. Must not be non zero. */
+    if (out_length == 0)
+    {
+        return 0;
+    }
+
+    /* Get the compression type from the input stream. */
+    n8bits = libmpq_huff_get_8bits(is);
+
+    /* Build the Huffman tree */
+    libmpq_huff_build_tree(ht, n8bits);
+    ht->cmp0 = (n8bits == 0) ? TRUE : FALSE;
+
+    for (;;)
+    {
+        n7bits = libmpq_huff_get_7bits(is); /* Get 7 bits from input stream */
+
+        /*
+         * Try to use quick decompression. Check huffman_decompress array for corresponding item.
+         * If found, use the result byte instead.
+         */
+        qd = &ht->qd3474[n7bits];
+
+        /* If there is a quick-pass possible (ebx) */
+        has_qd = (qd->offs00 >= ht->offs0004) ? TRUE : FALSE;
+
+        /* If we can use quick decompress, use it. */
+        if (has_qd)
+        {
+            found = 0;
+            if (qd->bits > 7)
+            {
+                is->bit_buf >>= 7;
+                is->bits -= 7;
+                p_item1 = qd->p_item;
+                found = 1;
+            }
+            if (found == 0)
+            {
+                is->bit_buf >>= qd->bits;
+                is->bits     -= qd->bits;
+                dcmp_byte     = qd->dcmp_byte;
+            }
+        }
+        else
+        {
+            found = 1;
+            p_item1 = ht->first->next->prev;
+            if (PTR_INT(p_item1) <= 0)
+            {
+                p_item1 = NULL;
+            }
+        }
+
+        if (found == 1)
+        {
+            bit_count = 0;
+            p_item2 = NULL;
+            do
+            {
+                p_item1 = p_item1->child;   /* Move down by one level */
+                if (libmpq_huff_get_bit(is))    /* If current bit is set, move to previous */
+                {
+                    p_item1 = p_item1->prev;
+                }
+                if (++bit_count == 7)       /* If we are at 7th bit, save current huffman tree item. */
+                {
+                    p_item2 = p_item1;
+                }
+            }
+            while (p_item1->child != NULL);     /* Walk until tree has no deeper level */
+
+            if (has_qd == FALSE)
+            {
+                if (bit_count > 7)
+                {
+                    qd->offs00 = ht->offs0004;
+                    qd->bits   = bit_count;
+                    qd->p_item = p_item2;
+                }
+                else
+                {
+                    unsigned long index = n7bits & (0xFFFFFFFF >> (32 - bit_count));
+                    unsigned long add   = (1 << bit_count);
+
+                    for (qd = &ht->qd3474[index]; index <= 0x7F; index += add, qd += add)
+                    {
+                        qd->offs00    = ht->offs0004;
+                        qd->bits      = bit_count;
+                        qd->dcmp_byte = p_item1->dcmp_byte;
+                    }
+                }
+            }
+            dcmp_byte = p_item1->dcmp_byte;
+        }
+
+        if (dcmp_byte == 0x101)         /* Huffman tree needs to be modified */
+        {
+            n8bits  = libmpq_huff_get_8bits(is);
+            p_item1 = (ht->last <= 0) ? NULL : ht->last;
+
+            p_item2 = libmpq_huff_call1500E740(ht, 1);
+            p_item2->parent     = p_item1;
+            p_item2->dcmp_byte  = p_item1->dcmp_byte;
+            p_item2->byte_value = p_item1->byte_value;
+            ht->items306C[p_item2->dcmp_byte] = p_item2;
+
+            p_item2 = libmpq_huff_call1500E740(ht, 1);
+            p_item2->parent     = p_item1;
+            p_item2->dcmp_byte  = n8bits;
+            p_item2->byte_value = 0;
+            ht->items306C[p_item2->dcmp_byte] = p_item2;
+
+            p_item1->child = p_item2;
+            libmpq_huff_call1500E820(ht, p_item2);
+            if (ht->cmp0 == 0)
+            {
+                libmpq_huff_call1500E820(ht, ht->items306C[n8bits]);
+            }
+            dcmp_byte = n8bits;
+        }
+
+        if (dcmp_byte == 0x100)
+        {
+            break;
+        }
+
+        *out_pos++ = (unsigned char)dcmp_byte;
+        if (--out_length == 0)
+        {
+            break;
+        }
+        if (ht->cmp0)
+        {
+            libmpq_huff_call1500E820(ht, ht->items306C[dcmp_byte]);
+        }
+    }
+    return (out_pos - out_buf);
+}
+
+int libmpq_huff_init_tree(struct huffman_tree* ht, struct huffman_tree_item* hi, unsigned int cmp)
+{
+    int count;
+
+    /* Clear links for all the items in the tree */
+    for (hi = ht->items0008, count = 0x203; count != 0; hi++, count--)
+    {
+        hi->next = hi->prev = NULL;
+    }
+
+    ht->item3050 = NULL;
+    ht->item3054 = PTR_PTR(&ht->item3054);
+    ht->item3058 = PTR_NOT(ht->item3054);
+
+    ht->item305C = NULL;
+    ht->first    = PTR_PTR(&ht->first);
+    ht->last     = PTR_NOT(ht->first);
+
+    ht->offs0004 = 1;
+    ht->items    = 0;
+
+    /* Clear all huffman_decompress items. Do this only if preparing for decompression */
+    if (cmp == LIBMPQ_HUFF_DECOMPRESS)
+    {
+        for (count = 0; count < sizeof(ht->qd3474) / sizeof(struct huffman_decompress); count++)
+        {
+            ht->qd3474[count].offs00 = 0;
+        }
+    }
+
+    return 0;
+}
diff -Nuar clean-build/maptools/map_extractor/libmpq03/huffman.h temp-build/maptools/map_extractor/libmpq03/huffman.h
--- clean-build/maptools/map_extractor/libmpq03/huffman.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/huffman.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,110 @@
+/*
+ *  huffman.h -- structures used for huffman compression.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of huffman.h included
+ *  in stormlib. The C++ version belongs to the following authors,
+ *
+ *  Ladislav Zezula <ladik.zezula.net>
+ *  ShadowFlare <BlakFlare@hotmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _HUFFMAN_H
+#define _HUFFMAN_H
+
+#define PTR_NOT(ptr)    (struct huffman_tree_item *)(~(unsigned long)(ptr))
+#define PTR_PTR(ptr)    ((struct huffman_tree_item *)(ptr))
+#define PTR_INT(ptr)    (long)(ptr)
+
+#define INSERT_ITEM 1
+#define SWITCH_ITEMS    2               /* Switch the item1 and item2 */
+
+/*
+ *  Input stream for Huffmann decompression
+ */
+struct huffman_input_stream
+{
+    unsigned char* in_buf;              /* 00 - Input data */
+    unsigned long bit_buf;              /* 04 - Input bit buffer */
+    unsigned int bits;              /* 08 - Number of bits remaining in 'byte' */
+};
+
+/*
+ *  Huffmann tree item.
+ */
+struct huffman_tree_item
+{
+    struct huffman_tree_item* next;         /* 00 - Pointer to next huffman_tree_item */
+    struct huffman_tree_item* prev;         /* 04 - Pointer to prev huffman_tree_item (< 0 if none) */
+    unsigned long dcmp_byte;            /* 08 - Index of this item in item pointer array, decompressed byte value */
+    unsigned long byte_value;           /* 0C - Some byte value */
+    struct huffman_tree_item* parent;       /* 10 - Pointer to parent huffman_tree_item (NULL if none) */
+    struct huffman_tree_item* child;        /* 14 - Pointer to child huffman_tree_item */
+};
+
+/*
+ *  Structure used for quick decompress. The 'bits' contains
+ *  number of bits and dcmp_byte contains result decompressed byte
+ *  value. After each walk through Huffman tree are filled all entries
+ *  which are multiplies of number of bits loaded from input stream.
+ *  These entries contain number of bits and result value. At the next
+ *  7 bits is tested this structure first. If corresponding entry found,
+ *  decompression routine will not walk through Huffman tree and
+ *  directly stores output byte to output stream.
+ */
+struct huffman_decompress
+{
+    unsigned long offs00;               /* 00 - 1 if resolved */
+    unsigned long bits;             /* 04 - Bit count */
+    union
+    {
+        unsigned long dcmp_byte;        /* 08 - Byte value for decompress (if bitCount <= 7) */
+        struct huffman_tree_item* p_item;   /* 08 - THTreeItem (if number of bits is greater than 7 */
+    };
+};
+
+/*
+ *  Structure for Huffman tree.
+ */
+struct huffman_tree
+{
+    unsigned long cmp0;             /* 0000 - 1 if compression type 0 */
+    unsigned long offs0004;             /* 0004 - Some flag */
+
+    struct huffman_tree_item items0008[0x203];  /* 0008 - huffman tree items */
+
+    /* Sometimes used as huffman tree item */
+    struct huffman_tree_item* item3050;     /* 3050 - Always NULL (?) */
+    struct huffman_tree_item* item3054;     /* 3054 - Pointer to huffman_tree_item */
+    struct huffman_tree_item* item3058;     /* 3058 - Pointer to huffman_tree_item (< 0 if invalid) */
+
+    /* Sometimes used as huffman tree item */
+    struct huffman_tree_item* item305C;     /* 305C - Usually NULL */
+    struct huffman_tree_item* first;        /* 3060 - Pointer to top (first) Huffman tree item */
+    struct huffman_tree_item* last;         /* 3064 - Pointer to bottom (last) Huffman tree item (< 0 if invalid) */
+    unsigned long items;                /* 3068 - Number of used huffman tree items */
+
+    struct huffman_tree_item* items306C[0x102]; /* 306C - huffman_tree_item pointer array */
+    struct huffman_decompress qd3474[0x80];     /* 3474 - Array for quick decompression */
+
+    //unsigned char table1502A630[];            /* Some table to make struct size flexible */
+};
+
+int libmpq_huff_init_tree(struct huffman_tree* ht, struct huffman_tree_item* hi, unsigned int cmp);
+int libmpq_huff_do_decompress(struct huffman_tree* ht, struct huffman_input_stream* is, unsigned char* out_buf, unsigned int out_length);
+#endif          /* _HUFFMAN_H */
diff -Nuar clean-build/maptools/map_extractor/libmpq03/mpq.cpp temp-build/maptools/map_extractor/libmpq03/mpq.cpp
--- clean-build/maptools/map_extractor/libmpq03/mpq.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/mpq.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,682 @@
+/*
+ *  mpq.c -- functions for developers using libmpq.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  $Id: mpq.c,v 1.6 2004/02/12 00:49:00 mbroemme Exp $
+ */
+#define _CRT_SECURE_NO_DEPRECATE
+
+#include <stdlib.h>
+#include <sys/stat.h>
+//#include <unistd.h>
+//#include <io.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include "mpq.h"
+#include "common.h"
+
+/*
+ *  This function returns version information.
+ *  format: MAJOR.MINOR.PATCH
+ */
+char* libmpq_version()
+{
+    static char version[10];
+    sprintf(version, "%i.%i.%i", LIBMPQ_MAJOR_VERSION, LIBMPQ_MINOR_VERSION, LIBMPQ_PATCH_VERSION);
+    return version;
+}
+
+/*
+ *  This function reads a file and verify if it is a legit MPQ archive
+ *  or not. Then it fills the mpq_header structure and reads the hash
+ *  table.
+ */
+int libmpq_archive_open(mpq_archive* mpq_a, unsigned char* mpq_filename)
+{
+    int fd = 0;
+    int rb = 0;
+    int ncnt = FALSE;
+    struct stat fileinfo;
+
+    /* allocate memory */
+    mpq_a->mpq_l = (mpq_list*)malloc(sizeof(mpq_list));
+    memset(mpq_a->mpq_l, 0, sizeof(mpq_list));
+    mpq_a->header = (mpq_header*)malloc(sizeof(mpq_header));
+    memset(mpq_a->header, 0, sizeof(mpq_header));
+
+    /* Check if file exists and is readable */
+    fd = _open((char*)mpq_filename, MPQ_FILE_OPEN_FLAGS);
+    if (fd == LIBMPQ_EFILE)
+    {
+        return LIBMPQ_EFILE;
+    }
+
+    /* fill the structures with informations */
+    strcpy((char*)mpq_a->filename, (char*)mpq_filename);
+    libmpq_init_buffer(mpq_a);
+    mpq_a->fd               = fd;
+    mpq_a->header->id       = 0;
+    mpq_a->maxblockindex    = 0;
+    mpq_a->mpq_l->mpq_files = NULL;
+
+    mpq_a->mpqpos = 0; //k
+
+    while (!ncnt)
+    {
+        mpq_a->header->id = 0;
+
+        libmpq_lseek(mpq_a, mpq_a->mpqpos);
+
+        rb = _read(mpq_a->fd, mpq_a->header, sizeof(mpq_header));
+
+        /* if different number of bytes read, break the loop */
+        if (rb != sizeof(mpq_header))
+        {
+            return LIBMPQ_EFILE_FORMAT;
+        }
+
+        /* special offset for protected MPQs */
+        if (mpq_a->header->offset == LIBMPQ_HEADER_W3M)
+        {
+            mpq_a->flags |= LIBMPQ_FLAG_PROTECTED;
+            mpq_a->header->offset = sizeof(mpq_header);
+        }
+
+        /* if valid signature has been found, break the loop */
+        if (mpq_a->header->id == LIBMPQ_ID_MPQ)
+        {
+            ncnt = true;
+        }
+        /*if (mpq_a->header->id == LIBMPQ_ID_MPQ &&
+            mpq_a->header->offset == sizeof(mpq_header) &&
+            mpq_a->header->hashtablepos < mpq_a->header->archivesize &&
+            mpq_a->header->blocktablepos < mpq_a->header->archivesize) {
+            ncnt = TRUE;
+        }*/
+
+        /* move to the next possible offset */
+        if (!ncnt)
+        {
+            mpq_a->mpqpos += 0x200;
+        }
+    }
+
+    /* get the right positions of the hash table and the block table. */
+    mpq_a->blocksize = (0x200 << mpq_a->header->blocksize);
+    fstat(mpq_a->fd, &fileinfo);
+
+    /* Normal MPQs must have position of */
+    /*if (mpq_a->header->hashtablepos + mpq_a->mpqpos < fileinfo.st_size &&
+        mpq_a->header->blocktablepos + mpq_a->mpqpos < fileinfo.st_size) {
+        mpq_a->header->hashtablepos  += mpq_a->mpqpos;
+        mpq_a->header->blocktablepos += mpq_a->mpqpos;
+    } else {
+        return LIBMPQ_EFILE_FORMAT;
+    }*/
+
+    /* Try to read and decrypt the hashtable */
+    if (libmpq_read_hashtable(mpq_a) != 0)
+    {
+        return LIBMPQ_EHASHTABLE;
+    }
+
+    /* Try to read and decrypt the blocktable */
+    if (libmpq_read_blocktable(mpq_a) != 0)
+    {
+        return LIBMPQ_EBLOCKTABLE;
+    }
+
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This function closes the file descriptor opened by
+ *  mpq_open_archive(); and frees the decryption buffer.
+ */
+int libmpq_archive_close(mpq_archive* mpq_a)
+{
+    memset(mpq_a->buf, 0, sizeof(mpq_a->buf));
+
+    /* free the allocated memory. */
+    free(mpq_a->header);
+    free(mpq_a->mpq_l);
+
+    /* Check if file descriptor is valid. */
+    if ((_close(mpq_a->fd)) == LIBMPQ_EFILE)
+    {
+        return LIBMPQ_EFILE;
+    }
+
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ * This function returns the value for the given infotype.
+ * If an error occurs something < 0 is returned.
+ */
+int libmpq_archive_info(mpq_archive* mpq_a, unsigned int infotype)
+{
+    unsigned int filecount = 0;
+    unsigned int fsize = 0;
+    unsigned int csize = 0;
+    mpq_block* mpq_b_end = mpq_a->blocktable + mpq_a->header->blocktablesize;
+    mpq_block* mpq_b = NULL;
+
+    switch (infotype)
+    {
+        case LIBMPQ_MPQ_ARCHIVE_SIZE:
+            return mpq_a->header->archivesize;
+        case LIBMPQ_MPQ_HASHTABLE_SIZE:
+            return mpq_a->header->hashtablesize;
+        case LIBMPQ_MPQ_BLOCKTABLE_SIZE:
+            return mpq_a->header->blocktablesize;
+        case LIBMPQ_MPQ_BLOCKSIZE:
+            return mpq_a->blocksize;
+        case LIBMPQ_MPQ_NUMFILES:
+            for (mpq_b = mpq_a->blocktable; mpq_b < mpq_b_end; mpq_b++)
+            {
+                filecount++;
+            }
+            return filecount;
+        case LIBMPQ_MPQ_COMPRESSED_SIZE:
+            for (mpq_b = mpq_a->blocktable; mpq_b < mpq_b_end; mpq_b++)
+            {
+                csize += mpq_b->csize;
+            }
+            return csize;
+        case LIBMPQ_MPQ_UNCOMPRESSED_SIZE:
+            for (mpq_b = mpq_a->blocktable; mpq_b < mpq_b_end; mpq_b++)
+            {
+                fsize += mpq_b->fsize;
+            }
+            return fsize;
+        default:
+            return LIBMPQ_TOOLS_SUCCESS;
+    }
+}
+
+/*
+ * This function returns some useful file information.
+ */
+int libmpq_file_info(mpq_archive* mpq_a, unsigned int infotype, const unsigned int number)
+{
+    int blockindex = number;
+    int i = 0;
+    mpq_block* mpq_b = NULL;
+    mpq_hash* mpq_h = NULL;
+
+    /* check if given number is not out of range */
+    if (number < 0 || number >= mpq_a->header->blocktablesize)
+    {
+        return LIBMPQ_EINV_RANGE;
+    }
+
+    /* check if sizes are correct */
+    mpq_b = mpq_a->blocktable + blockindex;
+    if (mpq_b->filepos > (mpq_a->header->archivesize + mpq_a->mpqpos) || mpq_b->csize > mpq_a->header->archivesize)
+    {
+        return LIBMPQ_EFILE_CORRUPT;
+    }
+
+    /* check if file exists */
+    if ((mpq_b->flags & LIBMPQ_FILE_EXISTS) == 0)
+    {
+        return LIBMPQ_EFILE_NOT_FOUND;
+    }
+
+    switch (infotype)
+    {
+        case LIBMPQ_FILE_COMPRESSED_SIZE:
+            return mpq_b->csize;
+        case LIBMPQ_FILE_UNCOMPRESSED_SIZE:
+            return mpq_b->fsize;
+        case LIBMPQ_FILE_COMPRESSION_TYPE:
+            if (mpq_b->flags & LIBMPQ_FILE_COMPRESS_PKWARE)
+            {
+                return LIBMPQ_FILE_COMPRESS_PKWARE;
+            }
+            if (mpq_b->flags & LIBMPQ_FILE_COMPRESS_MULTI)
+            {
+                return LIBMPQ_FILE_COMPRESS_MULTI;
+            }
+        default:
+            return LIBMPQ_TOOLS_SUCCESS;
+    }
+}
+
+/*
+ * This function searches the listfile for the filename.
+ * On success it returns the filename, otherwiese a name
+ * like file000001.xxx and if number is out of range it
+ * returns NULL.
+ */
+char* libmpq_file_name(mpq_archive* mpq_a, const int number)
+{
+    static char tempfile[PATH_MAX];
+
+    /* check if we are in the range of available files. */
+    if (number > libmpq_archive_info(mpq_a, LIBMPQ_MPQ_NUMFILES) || number < 1)
+    {
+        return NULL;
+    }
+
+    /* this is safe because we built a fallback filelist, if something was wrong. */
+    sprintf(tempfile, (char*)mpq_a->mpq_l->mpq_files[number - 1], number);
+
+    return tempfile;
+}
+
+/*
+ *  This function returns the number to the given
+ *  filename.
+ */
+int libmpq_file_number(mpq_archive* mpq_a, const char* name)
+{
+    int i;
+    char tempfile[PATH_MAX];
+
+    for (i = 0; mpq_a->mpq_l->mpq_files[i]; i++)
+    {
+        sprintf(tempfile, (char*)mpq_a->mpq_l->mpq_files[i], i + 1);
+        if (strncmp(tempfile, name, strlen(name)) == 0)
+        {
+
+            /* if file found return the number */
+            return i + 1;
+        }
+    }
+
+    /* if no matching entry found return LIBMPQ_EFILE_NOT_FOUND */
+    return LIBMPQ_EFILE_NOT_FOUND;
+}
+
+/*
+ *  This function verifies if a given file (by number
+ *  or name) is in the opened mpq archive. On success
+ *  it returns 0, otherwise LIBMPQ_EFILE_NOT_FOUND.
+ */
+int libmpq_file_check(mpq_archive* mpq_a, void* file, int type)
+{
+    int found = 0;
+    int i;
+    char tempfile[PATH_MAX];
+
+    switch (type)
+    {
+        case LIBMPQ_FILE_TYPE_INT:
+
+            /* check if we are in the range of available files. */
+            if (*(int*)file > libmpq_archive_info(mpq_a, LIBMPQ_MPQ_NUMFILES) || *(int*)file < 1)
+            {
+                return LIBMPQ_EFILE_NOT_FOUND;
+            }
+            else
+            {
+                return LIBMPQ_TOOLS_SUCCESS;
+            }
+        case LIBMPQ_FILE_TYPE_CHAR:
+            for (i = 0; mpq_a->mpq_l->mpq_files[i]; i++)
+            {
+                sprintf(tempfile, (char*)mpq_a->mpq_l->mpq_files[i], i);
+                if (strncmp(tempfile, (char*)file, strlen((char*)file)) == 0)
+                {
+
+                    /* if file found break */
+                    found = 1;
+                    break;
+                }
+            }
+
+            /* if a file was found return 0 */
+            if (found == 1)
+            {
+                return LIBMPQ_TOOLS_SUCCESS;
+            }
+            else
+            {
+                return LIBMPQ_EFILE_NOT_FOUND;
+            }
+        default:
+            return LIBMPQ_TOOLS_SUCCESS;
+    }
+}
+
+/*
+ *  This function extracts a file from a MPQ archive
+ *  by the given number.
+ */
+int libmpq_file_extract(mpq_archive* mpq_a, const int number, const char* filename)
+{
+    int blockindex = number; //-1;
+    int fd = 0;
+    int i = 0;
+    char buffer[0x1000];
+    //char tempfile[PATH_MAX];
+    unsigned int transferred = 1;
+    mpq_file* mpq_f = NULL;
+    mpq_block* mpq_b = NULL;
+    mpq_hash* mpq_h = NULL;
+
+    /*  if (number < 1 || number > mpq_a->header->blocktablesize) {
+            return LIBMPQ_EINV_RANGE;
+        }*/
+    /*
+        sprintf(tempfile, libmpq_file_name(mpq_a, number));
+    */
+    /* check if mpq_f->filename could be written here. */
+    fd = _open(filename, O_RDWR | O_CREAT | O_TRUNC, 0644);
+    if (fd == LIBMPQ_EFILE)
+    {
+        return LIBMPQ_EFILE;
+    }
+
+    /* search for correct hashtable */
+    /*for (i = 0; i < mpq_a->header->hashtablesize; i++) {
+        if ((number - 1) == (mpq_a->hashtable[i]).blockindex) {
+            blockindex = (mpq_a->hashtable[i]).blockindex;
+            mpq_h = &(mpq_a->hashtable[i]);
+            break;
+        }
+    }*/
+
+    /* check if file was found */
+    if (blockindex == -1 || blockindex > mpq_a->header->blocktablesize)
+    {
+        return LIBMPQ_EFILE_NOT_FOUND;
+    }
+
+    /* check if sizes are correct */
+    mpq_b = mpq_a->blocktable + blockindex;
+    if (mpq_b->filepos > (mpq_a->header->archivesize + mpq_a->mpqpos) || mpq_b->csize > mpq_a->header->archivesize)
+    {
+        return LIBMPQ_EFILE_CORRUPT;
+    }
+
+    /* check if file exists */
+    if ((mpq_b->flags & LIBMPQ_FILE_EXISTS) == 0)
+    {
+        return LIBMPQ_EFILE_NOT_FOUND;
+    }
+
+    /* allocate memory for file structure */
+    mpq_f = (mpq_file*)malloc(sizeof(mpq_file));
+    if (!mpq_f)
+    {
+        return LIBMPQ_EALLOCMEM;
+    }
+
+    /* initialize file structure */
+    memset(mpq_f, 0, sizeof(mpq_file));
+    mpq_f->fd             = fd;
+    mpq_f->mpq_b          = mpq_b;
+    mpq_f->nblocks        = (mpq_f->mpq_b->fsize + mpq_a->blocksize - 1) / mpq_a->blocksize;
+    mpq_f->mpq_h          = mpq_h;
+    mpq_f->accessed       = FALSE;
+    mpq_f->blockposloaded = FALSE;
+    sprintf((char*)mpq_f->filename, filename);
+
+    /* allocate buffers for decompression. */
+    if (mpq_f->mpq_b->flags & LIBMPQ_FILE_COMPRESSED)
+    {
+
+        /*
+         *  Allocate buffer for block positions. At the begin of file are stored
+         *  unsigned ints holding positions of each block relative from begin of
+         *  file in the archive.
+         */
+        if ((mpq_f->blockpos = (unsigned int*)malloc(sizeof(int) * mpq_f->nblocks + 1)) == NULL)
+        {
+            return LIBMPQ_EALLOCMEM;
+        }
+    }
+
+    while (transferred > 0)
+    {
+        transferred = libmpq_file_read_file(mpq_a, mpq_f, mpq_f->filepos, buffer, sizeof(buffer));
+        if (transferred == 0)
+        {
+            break;
+        }
+        else
+        {
+            mpq_f->accessed  = TRUE;
+            mpq_f->filepos  += transferred;
+        }
+
+        transferred = _write(mpq_f->fd, buffer, transferred);
+        if (transferred == 0)
+        {
+            break;
+        }
+    }
+
+    _close(fd);
+
+    /* freeing the file structure */
+    free(mpq_f);
+    return LIBMPQ_TOOLS_SUCCESS;
+}
+
+/*
+ *  This function tries to get the filenames for the hashes. It uses
+ *  an internal listfile database and gets the correct listfile from
+ *  some specific archive informations.
+ */
+
+int libmpq_listfile_open(mpq_archive* mpq_a, char file[PATH_MAX])
+{
+    FILE* fp;
+    //char **filelist;
+    int i = 0;
+    //int fl_count;
+    //int fl_size;
+    int fl_count_fb;
+    int fl_size_fb;
+    int result = LIBMPQ_TOOLS_SUCCESS;
+    struct stat statbuf;
+
+    /* get file status */
+    if (stat(file, &statbuf) < 0)
+    {
+        result = LIBMPQ_CONF_EFILE_NOT_FOUND;
+    }
+
+    /* check if file is a filename or directory */
+    /*if (S_ISDIR(statbuf.st_mode)) {
+
+        // allocate memory for the file list
+        filelist = (char **)malloc(LIBMPQ_CONF_FL_INCREMENT * sizeof(char *));
+        fl_count = 0;
+        fl_size = LIBMPQ_CONF_FL_INCREMENT;
+
+        // check if it is a valid listfile
+        if (libmpq_detect_listfile_rec(file, &filelist, &fl_count, &fl_size)) {
+            filelist == NULL;
+        }
+
+        filelist[fl_count] = NULL;
+
+        // return if no listfile was found
+        if (filelist == NULL) {
+            result = LIBMPQ_CONF_EFILE_NOT_FOUND;
+        }
+
+        for (i = 0; filelist[i]; i++) {
+            if ((fp = fopen(filelist[i], "r")) != NULL ) {
+                result = libmpq_read_listfile(mpq_a, fp);
+                fclose(fp);
+            }
+        }
+
+        // freeing the listfile struct
+        libmpq_free_listfile(filelist);
+    }*/
+
+    /* if file is a regular file use it */
+    //if (S_ISREG(statbuf.st_mode)) {
+
+    /* if specific listfile was forced. */
+    if ((fp = fopen(file, "r")) != NULL)
+    {
+        result = libmpq_read_listfile(mpq_a, fp);
+        fclose(fp);
+    }
+    else
+    {
+        result = LIBMPQ_CONF_EFILE_OPEN;
+    }
+    //}
+
+    /* if error occured we need to create a fallback filelist. */
+    if (mpq_a->mpq_l->mpq_files == NULL)
+    {
+
+        /* allocate memory for the file list */
+        mpq_a->mpq_l->mpq_files = (unsigned char**)malloc(LIBMPQ_CONF_FL_INCREMENT * sizeof(char*));
+        fl_count_fb = 0;
+        fl_size_fb = LIBMPQ_CONF_FL_INCREMENT;
+
+        for (i = 0; i < libmpq_archive_info(mpq_a, LIBMPQ_MPQ_NUMFILES); i++)
+        {
+
+            /* set the next filelist entry to a copy of the file */
+            mpq_a->mpq_l->mpq_files[fl_count_fb++] = (unsigned char*)_strdup("file%06lu.xxx");
+
+            /* increase the array size */
+            if (fl_count_fb == fl_size_fb)
+            {
+                mpq_a->mpq_l->mpq_files = (unsigned char**)realloc(mpq_a->mpq_l->mpq_files, (fl_size_fb + LIBMPQ_CONF_FL_INCREMENT) * sizeof(char*));
+                fl_size_fb += LIBMPQ_CONF_FL_INCREMENT;
+            }
+        }
+        mpq_a->mpq_l->mpq_files[fl_count_fb] = NULL;
+
+        /* if no error occurs and no listfile was assigned, we think there was no matching listfile. */
+        if (result == 0)
+        {
+            result = LIBMPQ_CONF_EFILE_NOT_FOUND;
+        }
+    }
+
+    return result;
+}
+
+/*
+ *  This function frees the allocated memory for the listfile.
+ */
+int libmpq_listfile_close(mpq_archive* mpq_a)
+{
+    int i = 0;
+
+    /* safety check if we really have a filelist. */
+    if (mpq_a->mpq_l->mpq_files != NULL)
+    {
+        /* freeing the filelist */
+        while (mpq_a->mpq_l->mpq_files[i])
+        {
+            free(mpq_a->mpq_l->mpq_files[i++]);
+        }
+        free(mpq_a->mpq_l->mpq_files);
+    }
+    return 0;
+}
+
+int libmpq_file_getdata(mpq_archive* mpq_a, mpq_hash mpq_h, const int number, unsigned char* dest)
+{
+    int blockindex = number; //-1;
+    int i = 0;
+    mpq_file* mpq_f = NULL;
+    mpq_block* mpq_b = NULL;
+    int success = 0;
+
+    /*if (number < 1 || number > mpq_a->header->blocktablesize) {
+        return LIBMPQ_EINV_RANGE;
+    }*/
+
+    /* search for correct hashtable */
+    /*for (i = 0; i < mpq_a->header->hashtablesize; i++) {
+        if ((number - 1) == (mpq_a->hashtable[i]).blockindex) {
+            blockindex = (mpq_a->hashtable[i]).blockindex;
+            mpq_h = &(mpq_a->hashtable[i]);
+            break;
+        }
+    }*/
+
+    /* check if file was found */
+    if (blockindex == -1 || blockindex > mpq_a->header->blocktablesize)
+    {
+        return LIBMPQ_EFILE_NOT_FOUND;
+    }
+
+    /* check if sizes are correct */
+    mpq_b = mpq_a->blocktable + blockindex;
+    if (mpq_b->filepos > (mpq_a->header->archivesize + mpq_a->mpqpos) || mpq_b->csize > mpq_a->header->archivesize)
+    {
+        return LIBMPQ_EFILE_CORRUPT;
+    }
+
+    /* check if file exists */
+    if ((mpq_b->flags & LIBMPQ_FILE_EXISTS) == 0)
+    {
+        return LIBMPQ_EFILE_NOT_FOUND;
+    }
+
+    /* allocate memory for file structure */
+    mpq_f = (mpq_file*)malloc(sizeof(mpq_file));
+    if (!mpq_f)
+    {
+        return LIBMPQ_EALLOCMEM;
+    }
+
+    /* initialize file structure */
+    memset(mpq_f, 0, sizeof(mpq_file));
+    mpq_f->mpq_b          = mpq_b;
+    mpq_f->nblocks        = (mpq_f->mpq_b->fsize + mpq_a->blocksize - 1) / mpq_a->blocksize;
+    mpq_f->mpq_h          = &mpq_h;
+    mpq_f->accessed       = FALSE;
+    mpq_f->blockposloaded = FALSE;
+
+    /* allocate buffers for decompression. */
+    if (mpq_f->mpq_b->flags & LIBMPQ_FILE_COMPRESSED)
+    {
+
+        /*
+         *  Allocate buffer for block positions. At the begin of file are stored
+         *  unsigned ints holding positions of each block relative from begin of
+         *  file in the archive.
+         */
+        if ((mpq_f->blockpos = (unsigned int*)malloc(sizeof(int) * (mpq_f->nblocks + 1))) == NULL)
+        {
+            return LIBMPQ_EALLOCMEM;
+        }
+    }
+
+    if (libmpq_file_read_file(mpq_a, mpq_f, 0, (char*)dest, mpq_b->fsize) == mpq_b->fsize)
+        success = 1;
+
+    if (mpq_f->mpq_b->flags & LIBMPQ_FILE_COMPRESSED)
+    {
+        // Free buffer for block positions
+
+        free(mpq_f->blockpos);
+    }
+    /* freeing the file structure */
+    free(mpq_f);
+    return success ? LIBMPQ_TOOLS_SUCCESS : LIBMPQ_EFILE_CORRUPT;
+}
diff -Nuar clean-build/maptools/map_extractor/libmpq03/mpq.h temp-build/maptools/map_extractor/libmpq03/mpq.h
--- clean-build/maptools/map_extractor/libmpq03/mpq.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/mpq.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,231 @@
+/*
+ *  mpq.h -- some default types and defines.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of StormLib.h and
+ *  StormPort.h included in stormlib. The C++ version belongs to
+ *  the following authors,
+ *
+ *  Ladislav Zezula <ladik.zezula.net>
+ *  Marko Friedemann <marko.friedemann@bmx-chemnitz.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  $Id: mpq.h,v 1.8 2004/02/12 00:45:50 mbroemme Exp $
+ */
+
+#ifndef _MPQ_H
+#define _MPQ_H
+
+#include <limits.h>
+
+#ifndef PATH_MAX
+#define PATH_MAX 260
+#endif
+
+#define LIBMPQ_MAJOR_VERSION        0       /* Major version number... maybe sometimes we reach version 1 :) */
+#define LIBMPQ_MINOR_VERSION        3       /* Minor version number - increased only for small changes */
+#define LIBMPQ_PATCH_VERSION        0       /* Patchlevel - changed on bugfixes etc... */
+
+#define LIBMPQ_TOOLS_SUCCESS        0       /* return value for all functions which success */
+#define LIBMPQ_TOOLS_BUFSIZE        0x500       /* buffer size for the decryption engine */
+
+#define LIBMPQ_EFILE            -1      /* error on file operation */
+#define LIBMPQ_EFILE_FORMAT     -2      /* bad file format */
+#define LIBMPQ_EFILE_CORRUPT        -3      /* file corrupt */
+#define LIBMPQ_EFILE_NOT_FOUND      -4      /* file in archive not found */
+#define LIBMPQ_EFILE_READ       -5      /* Read error in archive */
+#define LIBMPQ_EALLOCMEM        -6      /* maybe not enough memory? :) */
+#define LIBMPQ_EFREEMEM         -7      /* can not free memory */
+#define LIBMPQ_EINV_RANGE       -8      /* Given filenumber is out of range */
+#define LIBMPQ_EHASHTABLE       -9      /* error in reading hashtable */
+#define LIBMPQ_EBLOCKTABLE      -10     /* error in reading blocktable */
+
+#define LIBMPQ_ID_MPQ           0x1A51504D  /* MPQ archive header ID ('MPQ\x1A') */
+#define LIBMPQ_HEADER_W3M       0x6D9E4B86  /* special value used by W3M Map Protector */
+#define LIBMPQ_FLAG_PROTECTED       0x00000002  /* Set on protected MPQs (like W3M maps) */
+#define LIBMPQ_HASH_ENTRY_DELETED   0xFFFFFFFE  /* Block index for deleted hash entry */
+
+#define LIBMPQ_FILE_COMPRESS_PKWARE 0x00000100  /* Compression made by PKWARE Data Compression Library */
+#define LIBMPQ_FILE_COMPRESS_MULTI  0x00000200  /* Multiple compressions */
+#define LIBMPQ_FILE_COMPRESSED      0x0000FF00  /* File is compressed */
+#define LIBMPQ_FILE_EXISTS      0x80000000  /* Set if file exists, reset when the file was deleted */
+#define LIBMPQ_FILE_ENCRYPTED       0x00010000  /* Indicates whether file is encrypted */
+#define LIBMPQ_FILE_HAS_METADATA    0x04000000
+
+#define LIBMPQ_FILE_COMPRESSED_SIZE 1       /* MPQ compressed filesize of given file */
+#define LIBMPQ_FILE_UNCOMPRESSED_SIZE   2       /* MPQ uncompressed filesize of given file */
+#define LIBMPQ_FILE_COMPRESSION_TYPE    3       /* MPQ compression type of given file */
+#define LIBMPQ_FILE_TYPE_INT        4       /* file is given by number */
+#define LIBMPQ_FILE_TYPE_CHAR       5       /* file is given by name */
+
+#define LIBMPQ_MPQ_ARCHIVE_SIZE     1       /* MPQ archive size */
+#define LIBMPQ_MPQ_HASHTABLE_SIZE   2       /* MPQ archive hashtable size */
+#define LIBMPQ_MPQ_BLOCKTABLE_SIZE  3       /* MPQ archive blocktable size */
+#define LIBMPQ_MPQ_BLOCKSIZE        4       /* MPQ archive blocksize */
+#define LIBMPQ_MPQ_NUMFILES     5       /* Number of files in the MPQ archive */
+#define LIBMPQ_MPQ_COMPRESSED_SIZE  6       /* Compressed archive size */
+#define LIBMPQ_MPQ_UNCOMPRESSED_SIZE    7       /* Uncompressed archive size */
+
+#define LIBMPQ_HUFF_DECOMPRESS      0       /* Defines that we want to decompress using huffman trees. */
+
+#define LIBMPQ_CONF_EFILE_OPEN      -1      /* error if a specific listfile was forced and could not be opened. */
+#define LIBMPQ_CONF_EFILE_CORRUPT   -2      /* listfile seems to be corrupt */
+#define LIBMPQ_CONF_EFILE_LIST_CORRUPT  -3      /* listfile seems correct, but filelist is broken */
+#define LIBMPQ_CONF_EFILE_NOT_FOUND -4      /* error if no matching listfile found */
+#define LIBMPQ_CONF_EFILE_VERSION   -5      /* libmpq version does not match required listfile version */
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+/*
+#ifndef min
+#define min(a, b) ((a < b) ? a : b)
+#endif
+*/
+
+typedef unsigned int    mpq_buffer[LIBMPQ_TOOLS_BUFSIZE];
+typedef int (*DECOMPRESS)(char*, int*, char*, int);
+typedef struct
+{
+    unsigned long   mask;       /* Decompression bit */
+    DECOMPRESS  decompress; /* Decompression function */
+} decompress_table;
+
+/* MPQ file header */
+typedef struct
+{
+    unsigned int    id;     /* The 0x1A51504D ('MPQ\x1A') signature */
+    unsigned int    offset;     /* Offset of the first file (Relative to MPQ start) */
+    unsigned int    archivesize;    /* Size of MPQ archive */
+    unsigned short  offsetsc;   /* 0000 for SC and BW */
+    unsigned short  blocksize;  /* Size of file block is (0x200 << blockSize) */
+    unsigned int    hashtablepos;   /* File position of hashTable */
+    unsigned int    blocktablepos;  /* File position of blockTable. Each entry has 16 bytes */
+    unsigned int    hashtablesize;  /* Number of entries in hash table */
+    unsigned int    blocktablesize; /* Number of entries in the block table */
+} mpq_header;
+//} __attribute__ ((packed)) mpq_header;
+
+/* Hash entry. All files in the archive are searched by their hashes. */
+typedef struct
+{
+    unsigned int    name1;      /* The first two unsigned ints */
+    unsigned int    name2;      /* are the encrypted file name */
+    unsigned int    locale;     /* Locale information. */
+    unsigned int    blockindex; /* Index to file description block */
+} mpq_hash;
+
+/* File description block contains informations about the file */
+typedef struct
+{
+    unsigned int    filepos;    /* Block file starting position in the archive */
+    unsigned int    csize;      /* Compressed file size */
+    unsigned int    fsize;      /* Uncompressed file size */
+    unsigned int    flags;      /* Flags */
+} mpq_block;
+
+/* File handle structure used since Diablo 1.00 (0x38 bytes) */
+typedef struct
+{
+    unsigned char   filename[PATH_MAX]; /* filename of the actual file in the archive */
+    int     fd;     /* File handle */
+    unsigned int    seed;       /* Seed used for file decrypt */
+    unsigned int    filepos;    /* Current file position */
+    unsigned int    offset;
+    unsigned int    nblocks;    /* Number of blocks in the file (incl. the last noncomplete one) */
+    unsigned int*    blockpos;  /* Position of each file block (only for compressed files) */
+    int     blockposloaded; /* TRUE if block positions loaded */
+    unsigned int    offset2;    /* (Number of bytes somewhere ?) */
+    mpq_hash*    mpq_h;     /* Hash table entry */
+    mpq_block*   mpq_b;     /* File block pointer */
+
+    /* Non-Storm.dll members */
+
+    unsigned int    accessed;   /* Was something from the file already read? */
+} mpq_file;
+
+/* List handle structure */
+typedef struct
+{
+    unsigned char   mpq_version[10];    /* libmpq version required by the listfile */
+    unsigned char   mpq_name[PATH_MAX]; /* mpq archive name without full path */
+    unsigned char   mpq_type[20];       /* mpq archive type */
+    unsigned char   mpq_game[40];       /* blizzard title the file matches */
+    unsigned char   mpq_game_version[10];   /* game version */
+    unsigned char**   mpq_files;        /* filelist */
+} mpq_list;
+
+/* Archive handle structure used since Diablo 1.00 */
+typedef struct
+{
+    unsigned char   filename[PATH_MAX]; /* Opened archive file name */
+    int     fd;     /* File handle */
+    unsigned int    blockpos;   /* Position of loaded block in the file */
+    unsigned int    blocksize;  /* Size of file block */
+    unsigned char*   blockbuf;  /* Buffer (cache) for file block */
+    unsigned int    bufpos;     /* Position in block buffer */
+    unsigned int    mpqpos;     /* MPQ archive position in the file */
+    unsigned int    filepos;    /* Current file pointer */
+    unsigned int    openfiles;  /* Number of open files + 1 */
+    mpq_buffer  buf;        /* MPQ buffer */
+    mpq_header*  header;    /* MPQ file header */
+    mpq_hash*    hashtable; /* Hash table */
+    mpq_block*   blocktable;    /* Block table */
+
+    /* Non-Storm.dll members */
+
+    mpq_list*    mpq_l;     /* Handle to file list from database */
+
+    unsigned int    flags;      /* See LIBMPQ_TOOLS_FLAG_XXXXX */
+    unsigned int    maxblockindex;  /* The highest block table entry */
+} mpq_archive;
+
+extern char* libmpq_version();
+extern int libmpq_archive_open(mpq_archive* mpq_a, unsigned char* mpq_filename);
+extern int libmpq_archive_close(mpq_archive* mpq_a);
+extern int libmpq_archive_info(mpq_archive* mpq_a, unsigned int infotype);
+//extern int libmpq_file_extract(mpq_archive *mpq_a, const int number);
+extern int libmpq_file_info(mpq_archive* mpq_a, unsigned int infotype, const unsigned int number);
+extern char* libmpq_file_name(mpq_archive* mpq_a, const int number);
+extern int libmpq_file_number(mpq_archive* mpq_a, const char* name);
+extern int libmpq_file_check(mpq_archive* mpq_a, void* file, int type);
+extern int libmpq_listfile_open(mpq_archive* mpq_a, char file[PATH_MAX]);
+extern int libmpq_listfile_close(mpq_archive* mpq_a);
+
+extern int libmpq_pkzip_decompress(char* out_buf, int* out_length, char* in_buf, int in_length);
+extern int libmpq_zlib_decompress(char* out_buf, int* out_length, char* in_buf, int in_length);
+extern int libmpq_huff_decompress(char* out_buf, int* out_length, char* in_buf, int in_length);
+extern int libmpq_wave_decompress_stereo(char* out_buf, int* out_length, char* in_buf, int in_length);
+extern int libmpq_wave_decompress_mono(char* out_buf, int* out_length, char* in_buf, int in_length);
+extern int libmpq_multi_decompress(char* out_buf, int* pout_length, char* in_buf, int in_length);
+
+static decompress_table dcmp_table[] =
+{
+    {0x08, libmpq_pkzip_decompress},        /* Decompression with Pkware Data Compression Library */
+    {0x02, libmpq_zlib_decompress},         /* Decompression with the "zlib" library */
+    {0x01, libmpq_huff_decompress},         /* Huffmann decompression */
+    {0x80, libmpq_wave_decompress_stereo},      /* WAVE decompression for stereo waves */
+    {0x40, libmpq_wave_decompress_mono}     /* WAVE decompression for mono waves */
+};
+
+int libmpq_file_extract(mpq_archive* mpq_a, const int number, const char* filename);
+int libmpq_file_getdata(mpq_archive* mpq_a, mpq_hash mpq_h, const int number, unsigned char* dest);
+#endif                  /* _MPQ_H */
diff -Nuar clean-build/maptools/map_extractor/libmpq03/parser.cpp temp-build/maptools/map_extractor/libmpq03/parser.cpp
--- clean-build/maptools/map_extractor/libmpq03/parser.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/parser.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,333 @@
+/*
+ *  parser.c -- functions used to parse list or config file.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  $Id: parser.c,v 1.5 2004/02/12 00:47:53 mbroemme Exp $
+ */
+#define _CRT_SECURE_NO_DEPRECATE
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "mpq.h"
+#include "common.h"
+#include <ctype.h>
+
+/*
+ *  This function deletes the specified characters, but leaves
+ *  escape sequences unaffected. This means that " would be
+ *  deleted but \" would not.
+ */
+char* libmpq_conf_delete_char(char* buf, char* chars)
+{
+    static char* temp;
+    char ch;
+
+    temp = buf;
+
+    /* strip out special chars like " */
+    while (temp = strpbrk(temp, chars))
+    {
+        ch = temp[0];
+        memmove(&temp[0], &temp[1], strlen(temp));
+        if (ch == '\\')
+        {
+            temp++;
+        }
+    }
+
+    return buf;
+}
+
+/*
+ *  This function parses a line for the value to the given option. It
+ *  return 1 on success and the byte array or 0 and null.
+ */
+int libmpq_conf_parse_line(char* line, char* search_value, char* return_value, int size)
+{
+    int level = 0;
+    int found = 0;
+    int i = 0;
+    int pos = 0;
+
+    /* search value */
+    while (*(++line))
+    {
+
+        /* check for spaces */
+        if (!isspace(*line) && level == 1)
+        {
+
+            /* we found our value so break */
+            found = 1;
+            break;
+        }
+
+        /* check for '=' so the value follows as next parameter */
+        if (*line == '=' && level == 0)
+        {
+            level = 1;
+        }
+    }
+
+    /* now search for comment in this line */
+    for (i = 0; i < int(strlen(line)); i++)
+    {
+        if (line[i] == '#')
+        {
+            pos = i - 1;
+            break;
+        }
+    }
+
+    /* now set end of byte array behind value, but only if comment was found */
+    if (pos != 0)
+    {
+        for (i = pos; i >= 0; i--)
+        {
+            if (line[i] != ' ' && line[i] != '\t')
+            {
+                line[i + 1] = '\0';
+                break;
+            }
+        }
+    }
+
+    /* now check if line has trailing spaces */
+    for (i = strlen(line); i >= 0; i--)
+    {
+        if (line[i] != ' ' && line[i] != '\t')
+        {
+            line[i + 1] = '\0';
+            break;
+        }
+    }
+
+    /* now check if value is quoted with "" and if there is a char behind. */
+    for (i = strlen(line); i >= 0; i--)
+    {
+        if (line[i] == '"')
+        {
+            line[i + 1] = '\0';
+            break;
+        }
+    }
+
+    /* return the values */
+    strncpy(return_value, line, size);
+    return found;
+}
+
+/*
+ *  This function returns the value for a given option in the
+ *  listdb or config file. On success it returns 1, otherwise 0.
+ */
+int libmpq_conf_get_value(FILE* fp, char* search_value, void* return_value, int type, int size)
+{
+    char buf[LIBMPQ_CONF_BUFSIZE];
+    int found = 0;
+    int result = LIBMPQ_TOOLS_SUCCESS;
+
+    while (fgets(buf, LIBMPQ_CONF_BUFSIZE, fp) != NULL)
+    {
+        char* line;
+
+        buf[strlen(buf) - 1] = '\0';
+
+        /* skip whitespace */
+        for (line = buf; isspace(*line); line++)
+        {
+            continue;
+        }
+
+        /* skip empty line */
+        if (line[0] == '\0')
+        {
+            continue;
+        }
+
+        /* skip comments */
+        if (line[0] == '#')
+        {
+            continue;
+        }
+
+        /* process the line */
+        //if (!strncasecmp(line, search_value, strlen(search_value))) {
+        if (!strcmp(line, search_value))
+        {
+            found = libmpq_conf_parse_line(line, search_value, line, LIBMPQ_CONF_BUFSIZE);
+            if (found == 1)
+            {
+                libmpq_conf_delete_char(line, "\"\\");
+
+                switch (type)
+                {
+                    case LIBMPQ_CONF_TYPE_INT:
+
+                        /* if it is no valid number it is safe to return 0 */
+                        *(int*)return_value = atoi(line);
+                        break;
+                    default:
+                        strncpy((char*)return_value, line, size);
+                        break;
+                }
+
+                /* value found, so rewind stream */
+                break;
+            }
+        }
+    }
+
+    /* if value was not found */
+    if (found == 0)
+    {
+        switch (type)
+        {
+            case LIBMPQ_CONF_TYPE_INT:
+                *(int*)return_value = 0;
+                result = LIBMPQ_CONF_EVALUE_NOT_FOUND;
+                break;
+            default:
+                strncpy((char*)return_value, "", size);
+                result = LIBMPQ_CONF_EVALUE_NOT_FOUND;
+                break;
+        }
+    }
+    fseek(fp, 0L, SEEK_SET);
+
+    return result;
+}
+
+/*
+ *  This function returns a pointer to a byte array, with all values
+ *  found in the config file. As second value it returns th number of
+ *  entries in the byte array. On success it returns 1, otherwise 0.
+ */
+int libmpq_conf_get_array(FILE* fp, char* search_value, char** *filelist, int* entries)
+{
+    char buf[LIBMPQ_CONF_BUFSIZE];
+    char temp[LIBMPQ_CONF_BUFSIZE];
+    int level = 0;
+    int array_start = 0;
+    int array_end = 0;
+    int fl_count;
+    int fl_size;
+    int found = 0;
+    int i = 0;
+
+    *entries = 0;
+
+    /* allocate memory for the file list */
+    (*filelist) = (char**)malloc(LIBMPQ_CONF_FL_INCREMENT * sizeof(char*));
+    fl_count = 0;
+    fl_size = LIBMPQ_CONF_FL_INCREMENT;
+
+    while (fgets(buf, LIBMPQ_CONF_BUFSIZE, fp) != NULL)
+    {
+        char* line;
+
+        buf[strlen(buf) - 1] = '\0';
+
+        /* skip whitespace */
+        for (line = buf; isspace(*line); line++)
+        {
+            continue;
+        }
+
+        /* skip empty line */
+        if (line[0] == '\0')
+        {
+            continue;
+        }
+
+        /* skip comments */
+        if (line[0] == '#')
+        {
+            continue;
+        }
+
+        /* check for array end ) */
+        if (*line == ')')
+        {
+            array_end = 1;
+            break;
+        }
+
+        /* process entries between () */
+        if (array_start == 1 && array_end == 0)
+        {
+
+            /* add dummy option to use with libmpq_conf_parse_line() */
+            strncpy(temp, "MPQ_BUFFER = ", LIBMPQ_CONF_BUFSIZE);
+            strncat(temp, line, LIBMPQ_CONF_BUFSIZE);
+            found = libmpq_conf_parse_line(temp, "MPQ_BUFFER", temp, LIBMPQ_CONF_BUFSIZE);
+
+            if (found == 1)
+            {
+                libmpq_conf_delete_char(temp, "\"\\");
+
+                /* set the next filelist entry to a copy of the file */
+                (*filelist)[fl_count++] = _strdup(temp);
+
+                /* increase the array size */
+                if (fl_count == fl_size)
+                {
+                    (*filelist) = (char**)realloc((*filelist), (fl_size + LIBMPQ_CONF_FL_INCREMENT) * sizeof(char*));
+                    fl_size += LIBMPQ_CONF_FL_INCREMENT;
+                }
+
+                /* increase number of entries */
+                (*entries)++;
+            }
+        }
+
+        /* process the line and search array start */
+        //if (!strncasecmp(line, search_value, strlen(search_value))) {
+        if (!strcmp(line, search_value))
+        {
+
+            /* search value */
+            while (*(++line))
+            {
+
+                /* check for array start ( */
+                if (*line == '(' && level == 1)
+                {
+
+                    /* we found our value so break */
+                    array_start = 1;
+                    break;
+                }
+
+                /* check for '=' so the value follows as next parameter */
+                if (*line == '=' && level == 0)
+                {
+                    level = 1;
+                }
+            }
+        }
+    }
+
+    /* we got all files, so rewind stream */
+    fseek(fp, 0L, SEEK_SET);
+
+    (*filelist)[fl_count] = NULL;
+
+    return found;
+}
diff -Nuar clean-build/maptools/map_extractor/libmpq03/wave.cpp temp-build/maptools/map_extractor/libmpq03/wave.cpp
--- clean-build/maptools/map_extractor/libmpq03/wave.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/wave.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,218 @@
+/*
+ *  wave.c -- this file contains decompression methods used by Storm.dll
+ *            to decompress wave files.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of wave.cpp included
+ *  in stormlib. The C++ version belongs to the following authors,
+ *
+ *  Ladislav Zezula <ladik.zezula.net>
+ *  Tom Amigo <tomamigo@apexmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "wave.h"
+
+/* Tables necessary dor decompression */
+static unsigned long wave_table_1503f120[] =
+{
+    0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000004, 0xFFFFFFFF, 0x00000002, 0xFFFFFFFF, 0x00000006,
+    0xFFFFFFFF, 0x00000001, 0xFFFFFFFF, 0x00000005, 0xFFFFFFFF, 0x00000003, 0xFFFFFFFF, 0x00000007,
+    0xFFFFFFFF, 0x00000001, 0xFFFFFFFF, 0x00000005, 0xFFFFFFFF, 0x00000003, 0xFFFFFFFF, 0x00000007,
+    0xFFFFFFFF, 0x00000002, 0xFFFFFFFF, 0x00000004, 0xFFFFFFFF, 0x00000006, 0xFFFFFFFF, 0x00000008
+};
+
+static unsigned long wave_table_1503f1a0[] =
+{
+    0x00000007, 0x00000008, 0x00000009, 0x0000000A, 0x0000000B, 0x0000000C, 0x0000000D, 0x0000000E,
+    0x00000010, 0x00000011, 0x00000013, 0x00000015, 0x00000017, 0x00000019, 0x0000001C, 0x0000001F,
+    0x00000022, 0x00000025, 0x00000029, 0x0000002D, 0x00000032, 0x00000037, 0x0000003C, 0x00000042,
+    0x00000049, 0x00000050, 0x00000058, 0x00000061, 0x0000006B, 0x00000076, 0x00000082, 0x0000008F,
+    0x0000009D, 0x000000AD, 0x000000BE, 0x000000D1, 0x000000E6, 0x000000FD, 0x00000117, 0x00000133,
+    0x00000151, 0x00000173, 0x00000198, 0x000001C1, 0x000001EE, 0x00000220, 0x00000256, 0x00000292,
+    0x000002D4, 0x0000031C, 0x0000036C, 0x000003C3, 0x00000424, 0x0000048E, 0x00000502, 0x00000583,
+    0x00000610, 0x000006AB, 0x00000756, 0x00000812, 0x000008E0, 0x000009C3, 0x00000ABD, 0x00000BD0,
+    0x00000CFF, 0x00000E4C, 0x00000FBA, 0x0000114C, 0x00001307, 0x000014EE, 0x00001706, 0x00001954,
+    0x00001BDC, 0x00001EA5, 0x000021B6, 0x00002515, 0x000028CA, 0x00002CDF, 0x0000315B, 0x0000364B,
+    0x00003BB9, 0x000041B2, 0x00004844, 0x00004F7E, 0x00005771, 0x0000602F, 0x000069CE, 0x00007462,
+    0x00007FFF
+};
+
+/*
+ *  Decompress a wave file, mono or stereo
+ *
+ *  Offset: 1500F230
+ */
+int libmpq_wave_decompress(unsigned char* out_buf, int out_length, unsigned char* in_buf, int in_length, int channels)
+{
+    byte_and_short out;
+    byte_and_short in;
+    unsigned char* in_end = in_buf + in_length; /* End on input buffer */
+    unsigned long index;
+    long nr_array1[2];
+    long nr_array2[2];
+    int count = 0;
+
+    out.pb     = out_buf;
+    in.pb      = in_buf;
+    nr_array1[0] = 0x2C;
+    nr_array1[1] = 0x2C;
+    in.pw++;
+
+    /* 15007AD7 */
+    for (count = 0; count < channels; count++)
+    {
+        long temp;
+        temp = *(short*)in.pw++;
+        nr_array2[count] = temp;
+        if (out_length < 2)
+        {
+            return out.pb - out_buf;
+        }
+        *out.pw++   = (unsigned short)temp;
+        out_length -= 2;
+    }
+    index = channels - 1;
+    while (in.pb < in_end)
+    {
+        unsigned char one_byte = *in.pb++;
+        if (channels == 2)
+        {
+            index = (index == 0) ? 1 : 0;
+        }
+
+        /*
+         * Get one byte from input buffer
+         * 15007B25
+         */
+        if (one_byte & 0x80)
+        {
+            /* 15007B32 */
+            switch (one_byte & 0x7F)
+            {
+                case 0:                 /* 15007B8E */
+                    if (nr_array1[index] != 0)
+                    {
+                        nr_array1[index]--;
+                    }
+                    if (out_length < 2)
+                    {
+                        break;
+                    }
+                    *out.pw++ = (unsigned short)nr_array2[index];
+                    out_length -= 2;
+                    continue;
+                case 1:                 /* 15007B72 */
+                    nr_array1[index] += 8;      /* EBX also */
+                    if (nr_array1[index] > 0x58)
+                    {
+                        nr_array1[index] = 0x58;
+                    }
+                    if (channels == 2)
+                    {
+                        index = (index == 0) ? 1 : 0;
+                    }
+                    continue;
+                case 2:
+                    continue;
+                default:
+                    nr_array1[index] -= 8;
+                    if (nr_array1[index] < 0)
+                    {
+                        nr_array1[index] = 0;
+                    }
+                    if (channels != 2)
+                    {
+                        continue;
+                    }
+                    index = (index == 0) ? 1 : 0;
+                    continue;
+            }
+        }
+        else
+        {
+            unsigned long temp1 = wave_table_1503f1a0[nr_array1[index]];    /* EDI */
+            unsigned long temp2 = temp1 >> in_buf[1];   /* ESI */
+            long temp3 = nr_array2[index];          /* ECX */
+            if (one_byte & 0x01)                /* EBX = one_byte */
+            {
+                temp2 += (temp1 >> 0);
+            }
+            if (one_byte & 0x02)
+            {
+                temp2 += (temp1 >> 1);
+            }
+            if (one_byte & 0x04)
+            {
+                temp2 += (temp1 >> 2);
+            }
+            if (one_byte & 0x08)
+            {
+                temp2 += (temp1 >> 3);
+            }
+            if (one_byte & 0x10)
+            {
+                temp2 += (temp1 >> 4);
+            }
+            if (one_byte & 0x20)
+            {
+                temp2 += (temp1 >> 5);
+            }
+            if (one_byte & 0x40)
+            {
+                temp3 -= temp2;
+                if (temp3 <= (long)0xFFFF8000)
+                {
+                    temp3 = (long)0xFFFF8000;
+                }
+            }
+            else
+            {
+                temp3 += temp2;
+                if (temp3 >= 0x7FFF)
+                {
+                    temp3 = 0x7FFF;
+                }
+            }
+            nr_array2[index] = temp3;
+            if (out_length < 2)
+            {
+                break;
+            }
+
+            temp2 = nr_array1[index];
+            one_byte &= 0x1F;
+            *out.pw++ = (unsigned short)temp3;
+            out_length -= 2;
+            temp2 += wave_table_1503f120[one_byte];
+            nr_array1[index] = temp2;
+
+            if (nr_array1[index] < 0)
+            {
+                nr_array1[index] = 0;
+            }
+            else
+            {
+                if (nr_array1[index] > 0x58)
+                {
+                    nr_array1[index] = 0x58;
+                }
+            }
+        }
+    }
+    return (out.pb - out_buf);
+}
diff -Nuar clean-build/maptools/map_extractor/libmpq03/wave.h temp-build/maptools/map_extractor/libmpq03/wave.h
--- clean-build/maptools/map_extractor/libmpq03/wave.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/wave.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,38 @@
+/*
+ *  wave.h -- header file for WAVe unplode functions used by mpq-tools.
+ *
+ *  Copyright (C) 2003 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of wave.h included
+ *  in stormlib. The C++ version belongs to the following authors,
+ *
+ *  Ladislav Zezula <ladik.zezula.net>
+ *  Tom Amigo <tomamigo@apexmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WAVE_H
+#define _WAVE_H
+
+typedef union
+{
+    unsigned short*  pw;
+    unsigned char*   pb;
+} byte_and_short;
+
+int libmpq_wave_decompress(unsigned char* out_buf, int out_length, unsigned char* in_buf, int in_length, int channels);
+
+#endif                  /* _WAVE_H */
diff -Nuar clean-build/maptools/map_extractor/libmpq03/zconf.h temp-build/maptools/map_extractor/libmpq03/zconf.h
--- clean-build/maptools/map_extractor/libmpq03/zconf.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/zconf.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,323 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2003 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_  z_deflateInit_
+#  define deflate       z_deflate
+#  define deflateEnd    z_deflateEnd
+#  define inflateInit_  z_inflateInit_
+#  define inflate       z_inflate
+#  define inflateEnd    z_inflateEnd
+#  define deflateInit2_ z_deflateInit2_
+#  define deflateSetDictionary z_deflateSetDictionary
+#  define deflateCopy   z_deflateCopy
+#  define deflateReset  z_deflateReset
+#  define deflatePrime  z_deflatePrime
+#  define deflateParams z_deflateParams
+#  define deflateBound  z_deflateBound
+#  define inflateInit2_ z_inflateInit2_
+#  define inflateSetDictionary z_inflateSetDictionary
+#  define inflateSync   z_inflateSync
+#  define inflateSyncPoint z_inflateSyncPoint
+#  define inflateCopy   z_inflateCopy
+#  define inflateReset  z_inflateReset
+#  define compress      z_compress
+#  define compress2     z_compress2
+#  define compressBound z_compressBound
+#  define uncompress    z_uncompress
+#  define adler32       z_adler32
+#  define crc32         z_crc32
+#  define get_crc_table z_get_crc_table
+
+#  define Byte          z_Byte
+#  define uInt          z_uInt
+#  define uLong         z_uLong
+#  define Bytef         z_Bytef
+#  define charf         z_charf
+#  define intf          z_intf
+#  define uIntf         z_uIntf
+#  define uLongf        z_uLongf
+#  define voidpf        z_voidpf
+#  define voidp         z_voidp
+#endif
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
+#  define WIN32
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
+#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ >= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+/* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+/* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+/* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+/* If building or using zlib as a DLL, define ZLIB_DLL.
+ * This is not mandatory, but it offers a little performance increase.
+ */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+/* If building or using zlib with the WINAPI/WINAPIV calling convention,
+ * define ZLIB_WINAPI.
+ * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+ */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+/* No need for _export, use ZLIB.DEF instead. */
+/* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+/* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+typedef void const* voidpc;
+typedef void FAR*   voidpf;
+typedef void*       voidp;
+#else
+typedef Byte const* voidpc;
+typedef Byte FAR*   voidpf;
+typedef Byte*       voidp;
+#endif
+
+#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
+#  include <sys/types.h> /* for off_t */
+#  include <unistd.h>    /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include <unixio.h>   /* for off_t */
+#  endif
+#  define z_off_t  off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define  z_off_t long
+#endif
+
+#if defined(__OS400__)
+#define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(deflateBound,"DEBND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(compressBound,"CMBND")
+#   pragma map(inflate_table,"INTABL")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_copyright,"INCOPY")
+#endif
+
+#endif /* ZCONF_H */
diff -Nuar clean-build/maptools/map_extractor/libmpq03/zlib.h temp-build/maptools/map_extractor/libmpq03/zlib.h
--- clean-build/maptools/map_extractor/libmpq03/zlib.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/libmpq03/zlib.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,1201 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.1, November 17th, 2003
+
+  Copyright (C) 1995-2003 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.2.1"
+#define ZLIB_VERNUM 0x1210
+
+    /*
+         The 'zlib' compression library provides in-memory compression and
+      decompression functions, including integrity checks of the uncompressed
+      data.  This version of the library supports only one compression method
+      (deflation) but other algorithms will be added later and will have the same
+      stream interface.
+
+         Compression can be done in a single step if the buffers are large
+      enough (for example if an input file is mmap'ed), or can be done by
+      repeated calls of the compression function.  In the latter case, the
+      application must provide more input and/or consume the output
+      (providing more output space) before each call.
+
+         The compressed data format used by the in-memory functions is the zlib
+      format, which is a zlib wrapper documented in RFC 1950, wrapped around a
+      deflate stream, which is itself documented in RFC 1951.
+
+         The library also supports reading and writing files in gzip (.gz) format
+      with an interface similar to that of stdio using the functions that start
+      with "gz".  The gzip format is different from the zlib format.  gzip is a
+      gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+         The zlib format was designed to be compact and fast for use in memory
+      and on communications channels.  The gzip format was designed for single-
+      file compression on file systems, has a larger header than zlib to maintain
+      directory information, and uses a different, slower check method than zlib.
+
+         This library does not provide any functions to write gzip files in memory.
+      However such functions could be easily written using zlib's deflate function,
+      the documentation in the gzip RFC, and the examples in gzio.c.
+
+         The library does not install any signal handler. The decoder checks
+      the consistency of the compressed data, so the library should never
+      crash even in case of corrupted input.
+    */
+
+    typedef voidpf(*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+    typedef void (*free_func)  OF((voidpf opaque, voidpf address));
+
+    struct internal_state;
+
+    typedef struct z_stream_s
+    {
+        Bytef*    next_in;  /* next input byte */
+        uInt     avail_in;  /* number of bytes available at next_in */
+        uLong    total_in;  /* total nb of input bytes read so far */
+
+        Bytef*    next_out; /* next output byte should be put there */
+        uInt     avail_out; /* remaining free space at next_out */
+        uLong    total_out; /* total nb of bytes output so far */
+
+        char*     msg;      /* last error message, NULL if no error */
+        struct internal_state FAR* state; /* not visible by applications */
+
+        alloc_func zalloc;  /* used to allocate the internal state */
+        free_func  zfree;   /* used to free the internal state */
+        voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+        int     data_type;  /* best guess about the data type: ascii or binary */
+        uLong   adler;      /* adler32 value of the uncompressed data */
+        uLong   reserved;   /* reserved for future use */
+    } z_stream;
+
+    typedef z_stream FAR* z_streamp;
+
+    /*
+       The application must update next_in and avail_in when avail_in has
+       dropped to zero. It must update next_out and avail_out when avail_out
+       has dropped to zero. The application must initialize zalloc, zfree and
+       opaque before calling the init function. All other fields are set by the
+       compression library and must not be updated by the application.
+
+       The opaque value provided by the application will be passed as the first
+       parameter for calls of zalloc and zfree. This can be useful for custom
+       memory management. The compression library attaches no meaning to the
+       opaque value.
+
+       zalloc must return Z_NULL if there is not enough memory for the object.
+       If zlib is used in a multi-threaded application, zalloc and zfree must be
+       thread safe.
+
+       On 16-bit systems, the functions zalloc and zfree must be able to allocate
+       exactly 65536 bytes, but will not be required to allocate more than this
+       if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+       pointers returned by zalloc for objects of exactly 65536 bytes *must*
+       have their offset normalized to zero. The default allocation function
+       provided by this library ensures this (see zutil.c). To reduce memory
+       requirements and avoid any allocation of 64K objects, at the expense of
+       compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+       The fields total_in and total_out can be used for statistics or
+       progress reports. After compression, total_in holds the total size of
+       the uncompressed data and may be saved for use in the decompressor
+       (particularly if the decompressor wants to decompress everything in
+       a single step).
+    */
+
+    /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+    /* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+    /* Return codes for the compression/decompression functions. Negative
+     * values are errors, positive values are used for special but normal events.
+     */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+    /* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_DEFAULT_STRATEGY    0
+    /* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+    /* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+    /* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+    /* for compatibility with versions < 1.0.2 */
+
+    /* basic functions */
+
+    ZEXTERN const char* ZEXPORT zlibVersion OF((void));
+    /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+       If the first character differs, the library code actually used is
+       not compatible with the zlib.h header file used by the application.
+       This check is automatically made by deflateInit and inflateInit.
+     */
+
+    /*
+    ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+         Initializes the internal stream state for compression. The fields
+       zalloc, zfree and opaque must be initialized before by the caller.
+       If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+       use default allocation functions.
+
+         The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+       1 gives best speed, 9 gives best compression, 0 gives no compression at
+       all (the input data is simply copied a block at a time).
+       Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+       compression (currently equivalent to level 6).
+
+         deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+       Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+       with the version assumed by the caller (ZLIB_VERSION).
+       msg is set to null if there is no error message.  deflateInit does not
+       perform any compression: this will be done by deflate().
+    */
+
+
+    ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+    /*
+        deflate compresses as much data as possible, and stops when the input
+      buffer becomes empty or the output buffer becomes full. It may introduce some
+      output latency (reading input without producing any output) except when
+      forced to flush.
+
+        The detailed semantics are as follows. deflate performs one or both of the
+      following actions:
+
+      - Compress more input starting at next_in and update next_in and avail_in
+        accordingly. If not all input can be processed (because there is not
+        enough room in the output buffer), next_in and avail_in are updated and
+        processing will resume at this point for the next call of deflate().
+
+      - Provide more output starting at next_out and update next_out and avail_out
+        accordingly. This action is forced if the parameter flush is non zero.
+        Forcing flush frequently degrades the compression ratio, so this parameter
+        should be set only when necessary (in interactive applications).
+        Some output may be provided even if flush is not set.
+
+      Before the call of deflate(), the application should ensure that at least
+      one of the actions is possible, by providing more input and/or consuming
+      more output, and updating avail_in or avail_out accordingly; avail_out
+      should never be zero before the call. The application can consume the
+      compressed output when it wants, for example when the output buffer is full
+      (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+      and with zero avail_out, it must be called again after making room in the
+      output buffer because there might be more output pending.
+
+        If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+      flushed to the output buffer and the output is aligned on a byte boundary, so
+      that the decompressor can get all input data available so far. (In particular
+      avail_in is zero after the call if enough output space has been provided
+      before the call.)  Flushing may degrade compression for some compression
+      algorithms and so it should be used only when necessary.
+
+        If flush is set to Z_FULL_FLUSH, all output is flushed as with
+      Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+      restart from this point if previous compressed data has been damaged or if
+      random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+      the compression.
+
+        If deflate returns with avail_out == 0, this function must be called again
+      with the same value of the flush parameter and more output space (updated
+      avail_out), until the flush is complete (deflate returns with non-zero
+      avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+      avail_out is greater than six to avoid repeated flush markers due to
+      avail_out == 0 on return.
+
+        If the parameter flush is set to Z_FINISH, pending input is processed,
+      pending output is flushed and deflate returns with Z_STREAM_END if there
+      was enough output space; if deflate returns with Z_OK, this function must be
+      called again with Z_FINISH and more output space (updated avail_out) but no
+      more input data, until it returns with Z_STREAM_END or an error. After
+      deflate has returned Z_STREAM_END, the only possible operations on the
+      stream are deflateReset or deflateEnd.
+
+        Z_FINISH can be used immediately after deflateInit if all the compression
+      is to be done in a single step. In this case, avail_out must be at least
+      the value returned by deflateBound (see below). If deflate does not return
+      Z_STREAM_END, then it must be called again as described above.
+
+        deflate() sets strm->adler to the adler32 checksum of all input read
+      so far (that is, total_in bytes).
+
+        deflate() may update data_type if it can make a good guess about
+      the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+      binary. This field is only for information purposes and does not affect
+      the compression algorithm in any manner.
+
+        deflate() returns Z_OK if some progress has been made (more input
+      processed or more output produced), Z_STREAM_END if all input has been
+      consumed and all output has been produced (only when flush is set to
+      Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+      if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+      (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+      fatal, and deflate() can be called again with more input and more output
+      space to continue compressing.
+    */
+
+
+    ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+    /*
+         All dynamically allocated data structures for this stream are freed.
+       This function discards any unprocessed input and does not flush any
+       pending output.
+
+         deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+       stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+       prematurely (some input or output was discarded). In the error case,
+       msg may be set but then points to a static string (which must not be
+       deallocated).
+    */
+
+
+    /*
+    ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+         Initializes the internal stream state for decompression. The fields
+       next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+       the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+       value depends on the compression method), inflateInit determines the
+       compression method from the zlib header and allocates all data structures
+       accordingly; otherwise the allocation will be deferred to the first call of
+       inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+       use default allocation functions.
+
+         inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+       memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+       version assumed by the caller.  msg is set to null if there is no error
+       message. inflateInit does not perform any decompression apart from reading
+       the zlib header if present: this will be done by inflate().  (So next_in and
+       avail_in may be modified, but next_out and avail_out are unchanged.)
+    */
+
+
+    ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+    /*
+        inflate decompresses as much data as possible, and stops when the input
+      buffer becomes empty or the output buffer becomes full. It may introduce
+      some output latency (reading input without producing any output) except when
+      forced to flush.
+
+      The detailed semantics are as follows. inflate performs one or both of the
+      following actions:
+
+      - Decompress more input starting at next_in and update next_in and avail_in
+        accordingly. If not all input can be processed (because there is not
+        enough room in the output buffer), next_in is updated and processing
+        will resume at this point for the next call of inflate().
+
+      - Provide more output starting at next_out and update next_out and avail_out
+        accordingly.  inflate() provides as much output as possible, until there
+        is no more input data or no more space in the output buffer (see below
+        about the flush parameter).
+
+      Before the call of inflate(), the application should ensure that at least
+      one of the actions is possible, by providing more input and/or consuming
+      more output, and updating the next_* and avail_* values accordingly.
+      The application can consume the uncompressed output when it wants, for
+      example when the output buffer is full (avail_out == 0), or after each
+      call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+      must be called again after making room in the output buffer because there
+      might be more output pending.
+
+        The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+      Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+      output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+      if and when it get to the next deflate block boundary. When decoding the zlib
+      or gzip format, this will cause inflate() to return immediately after the
+      header and before the first block. When doing a raw inflate, inflate() will
+      go ahead and process the first block, and will return when it gets to the end
+      of that block, or when it runs out of data.
+
+        The Z_BLOCK option assists in appending to or combining deflate streams.
+      Also to assist in this, on return inflate() will set strm->data_type to the
+      number of unused bits in the last byte taken from strm->next_in, plus 64
+      if inflate() is currently decoding the last block in the deflate stream,
+      plus 128 if inflate() returned immediately after decoding an end-of-block
+      code or decoding the complete header up to just before the first byte of the
+      deflate stream. The end-of-block will not be indicated until all of the
+      uncompressed data from that block has been written to strm->next_out.  The
+      number of unused bits may in general be greater than seven, except when
+      bit 7 of data_type is set, in which case the number of unused bits will be
+      less than eight.
+
+        inflate() should normally be called until it returns Z_STREAM_END or an
+      error. However if all decompression is to be performed in a single step
+      (a single call of inflate), the parameter flush should be set to
+      Z_FINISH. In this case all pending input is processed and all pending
+      output is flushed; avail_out must be large enough to hold all the
+      uncompressed data. (The size of the uncompressed data may have been saved
+      by the compressor for this purpose.) The next operation on this stream must
+      be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+      is never required, but can be used to inform inflate that a faster approach
+      may be used for the single inflate() call.
+
+         In this implementation, inflate() always flushes as much output as
+      possible to the output buffer, and always uses the faster approach on the
+      first call. So the only effect of the flush parameter in this implementation
+      is on the return value of inflate(), as noted below, or when it returns early
+      because Z_BLOCK is used.
+
+         If a preset dictionary is needed after this call (see inflateSetDictionary
+      below), inflate sets strm-adler to the adler32 checksum of the dictionary
+      chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+      strm->adler to the adler32 checksum of all output produced so far (that is,
+      total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+      below. At the end of the stream, inflate() checks that its computed adler32
+      checksum is equal to that saved by the compressor and returns Z_STREAM_END
+      only if the checksum is correct.
+
+        inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+      deflate data.  The header type is detected automatically.  Any information
+      contained in the gzip header is not retained, so applications that need that
+      information should instead use raw inflate, see inflateInit2() below, or
+      inflateBack() and perform their own processing of the gzip header and
+      trailer.
+
+        inflate() returns Z_OK if some progress has been made (more input processed
+      or more output produced), Z_STREAM_END if the end of the compressed data has
+      been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+      preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+      corrupted (input stream not conforming to the zlib format or incorrect check
+      value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+      if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+      Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+      output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+      inflate() can be called again with more input and more output space to
+      continue decompressing. If Z_DATA_ERROR is returned, the application may then
+      call inflateSync() to look for a good compression block if a partial recovery
+      of the data is desired.
+    */
+
+
+    ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+    /*
+         All dynamically allocated data structures for this stream are freed.
+       This function discards any unprocessed input and does not flush any
+       pending output.
+
+         inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+       was inconsistent. In the error case, msg may be set but then points to a
+       static string (which must not be deallocated).
+    */
+
+    /* Advanced functions */
+
+    /*
+        The following functions are needed only in some special applications.
+    */
+
+    /*
+    ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                         int  level,
+                                         int  method,
+                                         int  windowBits,
+                                         int  memLevel,
+                                         int  strategy));
+
+         This is another version of deflateInit with more compression options. The
+       fields next_in, zalloc, zfree and opaque must be initialized before by
+       the caller.
+
+         The method parameter is the compression method. It must be Z_DEFLATED in
+       this version of the library.
+
+         The windowBits parameter is the base two logarithm of the window size
+       (the size of the history buffer). It should be in the range 8..15 for this
+       version of the library. Larger values of this parameter result in better
+       compression at the expense of memory usage. The default value is 15 if
+       deflateInit is used instead.
+
+         windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
+       determines the window size. deflate() will then generate raw deflate data
+       with no zlib header or trailer, and will not compute an adler32 check value.
+
+         windowBits can also be greater than 15 for optional gzip encoding. Add
+       16 to windowBits to write a simple gzip header and trailer around the
+       compressed data instead of a zlib wrapper. The gzip header will have no
+       file name, no extra data, no comment, no modification time (set to zero),
+       no header crc, and the operating system will be set to 255 (unknown).
+
+         The memLevel parameter specifies how much memory should be allocated
+       for the internal compression state. memLevel=1 uses minimum memory but
+       is slow and reduces compression ratio; memLevel=9 uses maximum memory
+       for optimal speed. The default value is 8. See zconf.h for total memory
+       usage as a function of windowBits and memLevel.
+
+         The strategy parameter is used to tune the compression algorithm. Use the
+       value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+       filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+       string match), or Z_RLE to limit match distances to one (run-length
+       encoding). Filtered data consists mostly of small values with a somewhat
+       random distribution. In this case, the compression algorithm is tuned to
+       compress them better. The effect of Z_FILTERED is to force more Huffman
+       coding and less string matching; it is somewhat intermediate between
+       Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
+       Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
+       parameter only affects the compression ratio but not the correctness of the
+       compressed output even if it is not set appropriately.
+
+          deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+       memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+       method). msg is set to null if there is no error message.  deflateInit2 does
+       not perform any compression: this will be done by deflate().
+    */
+
+    ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+            const Bytef* dictionary,
+            uInt  dictLength));
+    /*
+         Initializes the compression dictionary from the given byte sequence
+       without producing any compressed output. This function must be called
+       immediately after deflateInit, deflateInit2 or deflateReset, before any
+       call of deflate. The compressor and decompressor must use exactly the same
+       dictionary (see inflateSetDictionary).
+
+         The dictionary should consist of strings (byte sequences) that are likely
+       to be encountered later in the data to be compressed, with the most commonly
+       used strings preferably put towards the end of the dictionary. Using a
+       dictionary is most useful when the data to be compressed is short and can be
+       predicted with good accuracy; the data can then be compressed better than
+       with the default empty dictionary.
+
+         Depending on the size of the compression data structures selected by
+       deflateInit or deflateInit2, a part of the dictionary may in effect be
+       discarded, for example if the dictionary is larger than the window size in
+       deflate or deflate2. Thus the strings most likely to be useful should be
+       put at the end of the dictionary, not at the front.
+
+         Upon return of this function, strm->adler is set to the adler32 value
+       of the dictionary; the decompressor may later use this value to determine
+       which dictionary has been used by the compressor. (The adler32 value
+       applies to the whole dictionary even if only a subset of the dictionary is
+       actually used by the compressor.) If a raw deflate was requested, then the
+       adler32 value is not computed and strm->adler is not set.
+
+         deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+       parameter is invalid (such as NULL dictionary) or the stream state is
+       inconsistent (for example if deflate has already been called for this stream
+       or if the compression method is bsort). deflateSetDictionary does not
+       perform any compression: this will be done by deflate().
+    */
+
+    ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                        z_streamp source));
+    /*
+         Sets the destination stream as a complete copy of the source stream.
+
+         This function can be useful when several compression strategies will be
+       tried, for example when there are several ways of pre-processing the input
+       data with a filter. The streams that will be discarded should then be freed
+       by calling deflateEnd.  Note that deflateCopy duplicates the internal
+       compression state which can be quite large, so this strategy is slow and
+       can consume lots of memory.
+
+         deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+       (such as zalloc being NULL). msg is left unchanged in both source and
+       destination.
+    */
+
+    ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+    /*
+         This function is equivalent to deflateEnd followed by deflateInit,
+       but does not free and reallocate all the internal compression state.
+       The stream will keep the same compression level and any other attributes
+       that may have been set by deflateInit2.
+
+          deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+       stream state was inconsistent (such as zalloc or state being NULL).
+    */
+
+    ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                          int level,
+                                          int strategy));
+    /*
+         Dynamically update the compression level and compression strategy.  The
+       interpretation of level and strategy is as in deflateInit2.  This can be
+       used to switch between compression and straight copy of the input data, or
+       to switch to a different kind of input data requiring a different
+       strategy. If the compression level is changed, the input available so far
+       is compressed with the old level (and may be flushed); the new level will
+       take effect only at the next call of deflate().
+
+         Before the call of deflateParams, the stream state must be set as for
+       a call of deflate(), since the currently available input may have to
+       be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+         deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+       stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+       if strm->avail_out was zero.
+    */
+
+    ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                           uLong sourceLen));
+    /*
+         deflateBound() returns an upper bound on the compressed size after
+       deflation of sourceLen bytes.  It must be called after deflateInit()
+       or deflateInit2().  This would be used to allocate an output buffer
+       for deflation in a single pass, and so would be called before deflate().
+    */
+
+    ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                         int bits,
+                                         int value));
+    /*
+         deflatePrime() inserts bits in the deflate output stream.  The intent
+      is that this function is used to start off the deflate output with the
+      bits leftover from a previous deflate stream when appending to it.  As such,
+      this function can only be used for raw deflate, and must be used before the
+      first deflate() call after a deflateInit2() or deflateReset().  bits must be
+      less than or equal to 16, and that many of the least significant bits of
+      value will be inserted in the output.
+
+          deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+       stream state was inconsistent.
+    */
+
+    /*
+    ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                         int  windowBits));
+
+         This is another version of inflateInit with an extra parameter. The
+       fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+       before by the caller.
+
+         The windowBits parameter is the base two logarithm of the maximum window
+       size (the size of the history buffer).  It should be in the range 8..15 for
+       this version of the library. The default value is 15 if inflateInit is used
+       instead. windowBits must be greater than or equal to the windowBits value
+       provided to deflateInit2() while compressing, or it must be equal to 15 if
+       deflateInit2() was not used. If a compressed stream with a larger window
+       size is given as input, inflate() will return with the error code
+       Z_DATA_ERROR instead of trying to allocate a larger window.
+
+         windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
+       determines the window size. inflate() will then process raw deflate data,
+       not looking for a zlib or gzip header, not generating a check value, and not
+       looking for any check values for comparison at the end of the stream. This
+       is for use with other formats that use the deflate compressed data format
+       such as zip.  Those formats provide their own check values. If a custom
+       format is developed using the raw deflate format for compressed data, it is
+       recommended that a check value such as an adler32 or a crc32 be applied to
+       the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+       most applications, the zlib format should be used as is. Note that comments
+       above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+         windowBits can also be greater than 15 for optional gzip decoding. Add
+       32 to windowBits to enable zlib and gzip decoding with automatic header
+       detection, or add 16 to decode only the gzip format (the zlib format will
+       return a Z_DATA_ERROR).
+
+         inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+       memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
+       memLevel). msg is set to null if there is no error message.  inflateInit2
+       does not perform any decompression apart from reading the zlib header if
+       present: this will be done by inflate(). (So next_in and avail_in may be
+       modified, but next_out and avail_out are unchanged.)
+    */
+
+    ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+            const Bytef* dictionary,
+            uInt  dictLength));
+    /*
+         Initializes the decompression dictionary from the given uncompressed byte
+       sequence. This function must be called immediately after a call of inflate
+       if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
+       can be determined from the adler32 value returned by this call of
+       inflate. The compressor and decompressor must use exactly the same
+       dictionary (see deflateSetDictionary).
+
+         inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+       parameter is invalid (such as NULL dictionary) or the stream state is
+       inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+       expected one (incorrect adler32 value). inflateSetDictionary does not
+       perform any decompression: this will be done by subsequent calls of
+       inflate().
+    */
+
+    ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+    /*
+        Skips invalid compressed data until a full flush point (see above the
+      description of deflate with Z_FULL_FLUSH) can be found, or until all
+      available input is skipped. No output is provided.
+
+        inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+      if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+      or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+      case, the application may save the current current value of total_in which
+      indicates where valid compressed data was found. In the error case, the
+      application may repeatedly call inflateSync, providing more input each time,
+      until success or end of the input data.
+    */
+
+    ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                        z_streamp source));
+    /*
+         Sets the destination stream as a complete copy of the source stream.
+
+         This function can be useful when randomly accessing a large stream.  The
+       first pass through the stream can periodically record the inflate state,
+       allowing restarting inflate at those points when randomly accessing the
+       stream.
+
+         inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+       (such as zalloc being NULL). msg is left unchanged in both source and
+       destination.
+    */
+
+    ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+    /*
+         This function is equivalent to inflateEnd followed by inflateInit,
+       but does not free and reallocate all the internal decompression state.
+       The stream will keep attributes that may have been set by inflateInit2.
+
+          inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+       stream state was inconsistent (such as zalloc or state being NULL).
+    */
+
+    /*
+    ZEXTERN int ZEXPORT inflateBackInit OF((z_stream FAR *strm, int windowBits,
+                                            unsigned char FAR *window));
+
+         Initialize the internal stream state for decompression using inflateBack()
+       calls.  The fields zalloc, zfree and opaque in strm must be initialized
+       before the call.  If zalloc and zfree are Z_NULL, then the default library-
+       derived memory allocation routines are used.  windowBits is the base two
+       logarithm of the window size, in the range 8..15.  window is a caller
+       supplied buffer of that size.  Except for special applications where it is
+       assured that deflate was used with small window sizes, windowBits must be 15
+       and a 32K byte window must be supplied to be able to decompress general
+       deflate streams.
+
+         See inflateBack() for the usage of these routines.
+
+         inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+       the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+       be allocated, or Z_VERSION_ERROR if the version of the library does not
+       match the version of the header file.
+    */
+
+    typedef unsigned(*in_func) OF((void FAR*, unsigned char FAR* FAR*));
+    typedef int (*out_func) OF((void FAR*, unsigned char FAR*, unsigned));
+
+    ZEXTERN int ZEXPORT inflateBack OF((z_stream FAR* strm,
+                                        in_func in, void FAR* in_desc,
+                                        out_func out, void FAR* out_desc));
+    /*
+         inflateBack() does a raw inflate with a single call using a call-back
+       interface for input and output.  This is more efficient than inflate() for
+       file i/o applications in that it avoids copying between the output and the
+       sliding window by simply making the window itself the output buffer.  This
+       function trusts the application to not change the output buffer passed by
+       the output function, at least until inflateBack() returns.
+
+         inflateBackInit() must be called first to allocate the internal state
+       and to initialize the state with the user-provided window buffer.
+       inflateBack() may then be used multiple times to inflate a complete, raw
+       deflate stream with each call.  inflateBackEnd() is then called to free
+       the allocated state.
+
+         A raw deflate stream is one with no zlib or gzip header or trailer.
+       This routine would normally be used in a utility that reads zip or gzip
+       files and writes out uncompressed files.  The utility would decode the
+       header and process the trailer on its own, hence this routine expects
+       only the raw deflate stream to decompress.  This is different from the
+       normal behavior of inflate(), which expects either a zlib or gzip header and
+       trailer around the deflate stream.
+
+         inflateBack() uses two subroutines supplied by the caller that are then
+       called by inflateBack() for input and output.  inflateBack() calls those
+       routines until it reads a complete deflate stream and writes out all of the
+       uncompressed data, or until it encounters an error.  The function's
+       parameters and return types are defined above in the in_func and out_func
+       typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
+       number of bytes of provided input, and a pointer to that input in buf.  If
+       there is no input available, in() must return zero--buf is ignored in that
+       case--and inflateBack() will return a buffer error.  inflateBack() will call
+       out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+       should return zero on success, or non-zero on failure.  If out() returns
+       non-zero, inflateBack() will return with an error.  Neither in() nor out()
+       are permitted to change the contents of the window provided to
+       inflateBackInit(), which is also the buffer that out() uses to write from.
+       The length written by out() will be at most the window size.  Any non-zero
+       amount of input may be provided by in().
+
+         For convenience, inflateBack() can be provided input on the first call by
+       setting strm->next_in and strm->avail_in.  If that input is exhausted, then
+       in() will be called.  Therefore strm->next_in must be initialized before
+       calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
+       immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
+       must also be initialized, and then if strm->avail_in is not zero, input will
+       initially be taken from strm->next_in[0 .. strm->avail_in - 1].
+
+         The in_desc and out_desc parameters of inflateBack() is passed as the
+       first parameter of in() and out() respectively when they are called.  These
+       descriptors can be optionally used to pass any information that the caller-
+       supplied in() and out() functions need to do their job.
+
+         On return, inflateBack() will set strm->next_in and strm->avail_in to
+       pass back any unused input that was provided by the last in() call.  The
+       return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+       if in() or out() returned an error, Z_DATA_ERROR if there was a format
+       error in the deflate stream (in which case strm->msg is set to indicate the
+       nature of the error), or Z_STREAM_ERROR if the stream was not properly
+       initialized.  In the case of Z_BUF_ERROR, an input or output error can be
+       distinguished using strm->next_in which will be Z_NULL only if in() returned
+       an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
+       out() returning non-zero.  (in() will always be called before out(), so
+       strm->next_in is assured to be defined if out() returns non-zero.)  Note
+       that inflateBack() cannot return Z_OK.
+    */
+
+    ZEXTERN int ZEXPORT inflateBackEnd OF((z_stream FAR* strm));
+    /*
+         All memory allocated by inflateBackInit() is freed.
+
+         inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+       state was inconsistent.
+    */
+
+    ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+    /* Return flags indicating compile-time options.
+
+        Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+         1.0: size of uInt
+         3.2: size of uLong
+         5.4: size of voidpf (pointer)
+         7.6: size of z_off_t
+
+        Compiler, assembler, and debug options:
+         8: DEBUG
+         9: ASMV or ASMINF -- use ASM code
+         10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+         11: 0 (reserved)
+
+        One-time table building (smaller code, but not thread-safe if true):
+         12: BUILDFIXED -- build static block decoding tables when needed
+         13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+         14,15: 0 (reserved)
+
+        Library content (indicates missing functionality):
+         16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                              deflate code when not needed)
+         17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                        and decode gzip streams (to avoid linking crc code)
+         18-19: 0 (reserved)
+
+        Operation variations (changes in library functionality):
+         20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+         21: FASTEST -- deflate algorithm with only one, lowest compression level
+         22,23: 0 (reserved)
+
+        The sprintf variant used by gzprintf (zero is best):
+         24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+         25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+         26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+        Remainder:
+         27-31: 0 (reserved)
+     */
+
+
+    /* utility functions */
+
+    /*
+         The following utility functions are implemented on top of the
+       basic stream-oriented functions. To simplify the interface, some
+       default options are assumed (compression level and memory usage,
+       standard memory allocation functions). The source code of these
+       utility functions can easily be modified if you need special options.
+    */
+
+    ZEXTERN int ZEXPORT compress OF((Bytef* dest,   uLongf* destLen,
+                                     const Bytef* source, uLong sourceLen));
+    /*
+         Compresses the source buffer into the destination buffer.  sourceLen is
+       the byte length of the source buffer. Upon entry, destLen is the total
+       size of the destination buffer, which must be at least the value returned
+       by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+       compressed buffer.
+         This function can be used to compress a whole file at once if the
+       input file is mmap'ed.
+         compress returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_BUF_ERROR if there was not enough room in the output
+       buffer.
+    */
+
+    ZEXTERN int ZEXPORT compress2 OF((Bytef* dest,   uLongf* destLen,
+                                      const Bytef* source, uLong sourceLen,
+                                      int level));
+    /*
+         Compresses the source buffer into the destination buffer. The level
+       parameter has the same meaning as in deflateInit.  sourceLen is the byte
+       length of the source buffer. Upon entry, destLen is the total size of the
+       destination buffer, which must be at least the value returned by
+       compressBound(sourceLen). Upon exit, destLen is the actual size of the
+       compressed buffer.
+
+         compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+       memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+       Z_STREAM_ERROR if the level parameter is invalid.
+    */
+
+    ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+    /*
+         compressBound() returns an upper bound on the compressed size after
+       compress() or compress2() on sourceLen bytes.  It would be used before
+       a compress() or compress2() call to allocate the destination buffer.
+    */
+
+    ZEXTERN int ZEXPORT uncompress OF((Bytef* dest,   uLongf* destLen,
+                                       const Bytef* source, uLong sourceLen));
+    /*
+         Decompresses the source buffer into the destination buffer.  sourceLen is
+       the byte length of the source buffer. Upon entry, destLen is the total
+       size of the destination buffer, which must be large enough to hold the
+       entire uncompressed data. (The size of the uncompressed data must have
+       been saved previously by the compressor and transmitted to the decompressor
+       by some mechanism outside the scope of this compression library.)
+       Upon exit, destLen is the actual size of the compressed buffer.
+         This function can be used to decompress a whole file at once if the
+       input file is mmap'ed.
+
+         uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_BUF_ERROR if there was not enough room in the output
+       buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+    */
+
+
+    typedef voidp gzFile;
+
+    ZEXTERN gzFile ZEXPORT gzopen  OF((const char* path, const char* mode));
+    /*
+         Opens a gzip (.gz) file for reading or writing. The mode parameter
+       is as in fopen ("rb" or "wb") but can also include a compression level
+       ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
+       Huffman only compression as in "wb1h", or 'R' for run-length encoding
+       as in "wb1R". (See the description of deflateInit2 for more information
+       about the strategy parameter.)
+
+         gzopen can be used to read a file which is not in gzip format; in this
+       case gzread will directly read from the file without decompression.
+
+         gzopen returns NULL if the file could not be opened or if there was
+       insufficient memory to allocate the (de)compression state; errno
+       can be checked to distinguish the two cases (if errno is zero, the
+       zlib error is Z_MEM_ERROR).  */
+
+    ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char* mode));
+    /*
+         gzdopen() associates a gzFile with the file descriptor fd.  File
+       descriptors are obtained from calls like open, dup, creat, pipe or
+       fileno (in the file has been previously opened with fopen).
+       The mode parameter is as in gzopen.
+         The next call of gzclose on the returned gzFile will also close the
+       file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+       descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+         gzdopen returns NULL if there was insufficient memory to allocate
+       the (de)compression state.
+    */
+
+    ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+    /*
+         Dynamically update the compression level or strategy. See the description
+       of deflateInit2 for the meaning of these parameters.
+         gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+       opened for writing.
+    */
+
+    ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+    /*
+         Reads the given number of uncompressed bytes from the compressed file.
+       If the input file was not in gzip format, gzread copies the given number
+       of bytes into the buffer.
+         gzread returns the number of uncompressed bytes actually read (0 for
+       end of file, -1 for error). */
+
+    ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
+                                       voidpc buf, unsigned len));
+    /*
+         Writes the given number of uncompressed bytes into the compressed file.
+       gzwrite returns the number of uncompressed bytes actually written
+       (0 in case of error).
+    */
+
+    ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char* format, ...));
+    /*
+         Converts, formats, and writes the args to the compressed file under
+       control of the format string, as in fprintf. gzprintf returns the number of
+       uncompressed bytes actually written (0 in case of error).  The number of
+       uncompressed bytes written is limited to 4095. The caller should assure that
+       this limit is not exceeded. If it is exceeded, then gzprintf() will return
+       return an error (0) with nothing written. In this case, there may also be a
+       buffer overflow with unpredictable consequences, which is possible only if
+       zlib was compiled with the insecure functions sprintf() or vsprintf()
+       because the secure snprintf() or vsnprintf() functions were not available.
+    */
+
+    ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char* s));
+    /*
+          Writes the given null-terminated string to the compressed file, excluding
+       the terminating null character.
+          gzputs returns the number of characters written, or -1 in case of error.
+    */
+
+    ZEXTERN char* ZEXPORT gzgets OF((gzFile file, char* buf, int len));
+    /*
+          Reads bytes from the compressed file until len-1 characters are read, or
+       a newline character is read and transferred to buf, or an end-of-file
+       condition is encountered.  The string is then terminated with a null
+       character.
+          gzgets returns buf, or Z_NULL in case of error.
+    */
+
+    ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+    /*
+          Writes c, converted to an unsigned char, into the compressed file.
+       gzputc returns the value that was written, or -1 in case of error.
+    */
+
+    ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+    /*
+          Reads one byte from the compressed file. gzgetc returns this byte
+       or -1 in case of end of file or error.
+    */
+
+    ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+    /*
+          Push one character back onto the stream to be read again later.
+       Only one character of push-back is allowed.  gzungetc() returns the
+       character pushed, or -1 on failure.  gzungetc() will fail if a
+       character has been pushed but not read yet, or if c is -1. The pushed
+       character will be discarded if the stream is repositioned with gzseek()
+       or gzrewind().
+    */
+
+    ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+    /*
+         Flushes all pending output into the compressed file. The parameter
+       flush is as in the deflate() function. The return value is the zlib
+       error number (see function gzerror below). gzflush returns Z_OK if
+       the flush parameter is Z_FINISH and all output could be flushed.
+         gzflush should be called only when strictly necessary because it can
+       degrade compression.
+    */
+
+    ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+                                          z_off_t offset, int whence));
+    /*
+          Sets the starting position for the next gzread or gzwrite on the
+       given compressed file. The offset represents a number of bytes in the
+       uncompressed data stream. The whence parameter is defined as in lseek(2);
+       the value SEEK_END is not supported.
+         If the file is opened for reading, this function is emulated but can be
+       extremely slow. If the file is opened for writing, only forward seeks are
+       supported; gzseek then compresses a sequence of zeroes up to the new
+       starting position.
+
+          gzseek returns the resulting offset location as measured in bytes from
+       the beginning of the uncompressed stream, or -1 in case of error, in
+       particular if the file is opened for writing and the new starting position
+       would be before the current position.
+    */
+
+    ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+    /*
+         Rewinds the given file. This function is supported only for reading.
+
+       gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+    */
+
+    ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+    /*
+         Returns the starting position for the next gzread or gzwrite on the
+       given compressed file. This position represents a number of bytes in the
+       uncompressed data stream.
+
+       gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+    */
+
+    ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+    /*
+         Returns 1 when EOF has previously been detected reading the given
+       input stream, otherwise zero.
+    */
+
+    ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+    /*
+         Flushes all pending output if necessary, closes the compressed file
+       and deallocates all the (de)compression state. The return value is the zlib
+       error number (see function gzerror below).
+    */
+
+    ZEXTERN const char* ZEXPORT gzerror OF((gzFile file, int* errnum));
+    /*
+         Returns the error message for the last error which occurred on the
+       given compressed file. errnum is set to zlib error number. If an
+       error occurred in the file system and not in the compression library,
+       errnum is set to Z_ERRNO and the application may consult errno
+       to get the exact error code.
+    */
+
+    ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+    /*
+         Clears the error and end-of-file flags for file. This is analogous to the
+       clearerr() function in stdio. This is useful for continuing to read a gzip
+       file that is being written concurrently.
+    */
+
+    /* checksum functions */
+
+    /*
+         These functions are not related to compression but are exported
+       anyway because they might be useful in applications using the
+       compression library.
+    */
+
+    ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef* buf, uInt len));
+
+    /*
+         Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+       return the updated checksum. If buf is NULL, this function returns
+       the required initial value for the checksum.
+       An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+       much faster. Usage example:
+
+         uLong adler = adler32(0L, Z_NULL, 0);
+
+         while (read_buffer(buffer, length) != EOF) {
+           adler = adler32(adler, buffer, length);
+         }
+         if (adler != original_adler) error();
+    */
+
+    ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef* buf, uInt len));
+    /*
+         Update a running crc with the bytes buf[0..len-1] and return the updated
+       crc. If buf is NULL, this function returns the required initial value
+       for the crc. Pre- and post-conditioning (one's complement) is performed
+       within this function so it shouldn't be done by the application.
+       Usage example:
+
+         uLong crc = crc32(0L, Z_NULL, 0);
+
+         while (read_buffer(buffer, length) != EOF) {
+           crc = crc32(crc, buffer, length);
+         }
+         if (crc != original_crc) error();
+    */
+
+
+    /* various hacks, don't look :) */
+
+    /* deflateInit and inflateInit are macros to allow checking the zlib version
+     * and the compiler's view of z_stream:
+     */
+    ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                         const char* version, int stream_size));
+    ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                         const char* version, int stream_size));
+    ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                          int windowBits, int memLevel,
+                                          int strategy, const char* version,
+                                          int stream_size));
+    ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                          const char* version, int stream_size));
+    ZEXTERN int ZEXPORT inflateBackInit_ OF((z_stream FAR* strm, int windowBits,
+                                            unsigned char FAR* window,
+                                            const char* version,
+                                            int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+        ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+    ZEXTERN const char*    ZEXPORT zError           OF((int err));
+    ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+    ZEXTERN const uLongf* ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */
diff -Nuar clean-build/maptools/map_extractor/map_loadlib/adt.cpp temp-build/maptools/map_extractor/map_loadlib/adt.cpp
--- clean-build/maptools/map_extractor/map_loadlib/adt.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/map_loadlib/adt.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,131 @@
+#define _CRT_SECURE_NO_DEPRECATE
+
+#include "adt.h"
+
+// Helper
+int holetab_h[4] = {0x1111, 0x2222, 0x4444, 0x8888};
+int holetab_v[4] = {0x000F, 0x00F0, 0x0F00, 0xF000};
+
+bool isHole(int holes, int i, int j)
+{
+    int testi = i / 2;
+    int testj = j / 4;
+    if (testi > 3) testi = 3;
+    if (testj > 3) testj = 3;
+    return (holes & holetab_h[testi] & holetab_v[testj]) != 0;
+}
+
+//
+// Adt file loader class
+//
+ADT_file::ADT_file()
+{
+    a_grid = 0;
+}
+
+ADT_file::~ADT_file()
+{
+    free();
+}
+
+void ADT_file::free()
+{
+    a_grid = 0;
+    FileLoader::free();
+}
+
+//
+// Adt file check function
+//
+bool ADT_file::prepareLoadedData()
+{
+    // Check parent
+    if (!FileLoader::prepareLoadedData())
+        return false;
+
+    // Check and prepare MHDR
+    a_grid = (adt_MHDR*)(GetData() + 8 + version->size);
+    if (!a_grid->prepareLoadedData())
+        return false;
+
+    return true;
+}
+
+bool adt_MHDR::prepareLoadedData()
+{
+    if (fcc != 'MHDR')
+        return false;
+
+    if (size != sizeof(adt_MHDR) - 8)
+        return false;
+
+    // Check and prepare MCIN
+    if (offsMCIN && !getMCIN()->prepareLoadedData())
+        return false;
+
+    // Check and prepare MH2O
+    if (offsMH2O && !getMH2O()->prepareLoadedData())
+        return false;
+
+    return true;
+}
+
+bool adt_MCIN::prepareLoadedData()
+{
+    if (fcc != 'MCIN')
+        return false;
+
+    // Check cells data
+    for (int i = 0; i < ADT_CELLS_PER_GRID; i++)
+        for (int j = 0; j < ADT_CELLS_PER_GRID; j++)
+            if (cells[i][j].offsMCNK && !getMCNK(i, j)->prepareLoadedData())
+                return false;
+
+    return true;
+}
+
+bool adt_MH2O::prepareLoadedData()
+{
+    if (fcc != 'MH2O')
+        return false;
+
+    // Check liquid data
+//    for (int i=0; i<ADT_CELLS_PER_GRID;i++)
+//        for (int j=0; j<ADT_CELLS_PER_GRID;j++)
+
+    return true;
+}
+
+bool adt_MCNK::prepareLoadedData()
+{
+    if (fcc != 'MCNK')
+        return false;
+
+    // Check height map
+    if (offsMCVT && !getMCVT()->prepareLoadedData())
+        return false;
+    // Check liquid data
+    if (offsMCLQ && !getMCLQ()->prepareLoadedData())
+        return false;
+
+    return true;
+}
+
+bool adt_MCVT::prepareLoadedData()
+{
+    if (fcc != 'MCVT')
+        return false;
+
+    if (size != sizeof(adt_MCVT) - 8)
+        return false;
+
+    return true;
+}
+
+bool adt_MCLQ::prepareLoadedData()
+{
+    if (fcc != 'MCLQ')
+        return false;
+
+    return true;
+}
\ No newline at end of file
diff -Nuar clean-build/maptools/map_extractor/map_loadlib/adt.h temp-build/maptools/map_extractor/map_loadlib/adt.h
--- clean-build/maptools/map_extractor/map_loadlib/adt.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/map_loadlib/adt.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,301 @@
+#ifndef ADT_H
+#define ADT_H
+
+#include "loadlib.h"
+
+#define TILESIZE (533.33333f)
+#define CHUNKSIZE ((TILESIZE) / 16.0f)
+#define UNITSIZE (CHUNKSIZE / 8.0f)
+
+enum LiquidType
+{
+    LIQUID_TYPE_WATER = 0,
+    LIQUID_TYPE_OCEAN = 1,
+    LIQUID_TYPE_MAGMA = 2,
+    LIQUID_TYPE_SLIME = 3
+};
+
+//**************************************************************************************
+// ADT file class
+//**************************************************************************************
+#define ADT_CELLS_PER_GRID    16
+#define ADT_CELL_SIZE         8
+#define ADT_GRID_SIZE         (ADT_CELLS_PER_GRID*ADT_CELL_SIZE)
+
+//
+// Adt file height map chunk
+//
+class adt_MCVT
+{
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+        uint32 size;
+    public:
+        float height_map[(ADT_CELL_SIZE + 1) * (ADT_CELL_SIZE + 1) + ADT_CELL_SIZE* ADT_CELL_SIZE];
+
+        bool  prepareLoadedData();
+};
+
+//
+// Adt file liquid map chunk (old)
+//
+class adt_MCLQ
+{
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+        uint32 size;
+    public:
+        float height1;
+        float height2;
+        struct liquid_data
+        {
+            uint32 light;
+            float  height;
+        } liquid[ADT_CELL_SIZE + 1][ADT_CELL_SIZE + 1];
+
+        // 1<<0 - ochen
+        // 1<<1 - lava/slime
+        // 1<<2 - water
+        // 1<<6 - all water
+        // 1<<7 - dark water
+        // == 0x0F - not show liquid
+        uint8 flags[ADT_CELL_SIZE][ADT_CELL_SIZE];
+        uint8 data[84];
+        bool  prepareLoadedData();
+};
+
+//
+// Adt file cell chunk
+//
+class adt_MCNK
+{
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+        uint32 size;
+    public:
+        uint32 flags;
+        uint32 ix;
+        uint32 iy;
+        uint32 nLayers;
+        uint32 nDoodadRefs;
+        uint32 offsMCVT;        // height map
+        uint32 offsMCNR;        // Normal vectors for each vertex
+        uint32 offsMCLY;        // Texture layer definitions
+        uint32 offsMCRF;        // A list of indices into the parent file's MDDF chunk
+        uint32 offsMCAL;        // Alpha maps for additional texture layers
+        uint32 sizeMCAL;
+        uint32 offsMCSH;        // Shadow map for static shadows on the terrain
+        uint32 sizeMCSH;
+        uint32 areaid;
+        uint32 nMapObjRefs;
+        uint16 holes;           // locations where models pierce the heightmap
+        uint16 pad;
+        uint16 s[2];
+        uint32 data1;
+        uint32 data2;
+        uint32 data3;
+        uint32 predTex;
+        uint32 nEffectDoodad;
+        uint32 offsMCSE;
+        uint32 nSndEmitters;
+        uint32 offsMCLQ;         // Liqid level (old)
+        uint32 sizeMCLQ;         //
+        float  zpos;
+        float  xpos;
+        float  ypos;
+        uint32 offsMCCV;         // offsColorValues in WotLK
+        uint32 props;
+        uint32 effectId;
+
+        bool   prepareLoadedData();
+        adt_MCVT* getMCVT()
+        {
+            if (offsMCVT)
+                return (adt_MCVT*)((uint8*)this + offsMCVT);
+            return 0;
+        }
+        adt_MCLQ* getMCLQ()
+        {
+            if (offsMCLQ)
+                return (adt_MCLQ*)((uint8*)this + offsMCLQ);
+            return 0;
+        }
+};
+
+//
+// Adt file grid chunk
+//
+class adt_MCIN
+{
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+        uint32 size;
+    public:
+        struct adt_CELLS
+        {
+            uint32 offsMCNK;
+            uint32 size;
+            uint32 flags;
+            uint32 asyncId;
+        } cells[ADT_CELLS_PER_GRID][ADT_CELLS_PER_GRID];
+
+        bool   prepareLoadedData();
+        // offset from begin file (used this-84)
+        adt_MCNK* getMCNK(int x, int y)
+        {
+            if (cells[x][y].offsMCNK)
+                return (adt_MCNK*)((uint8*)this + cells[x][y].offsMCNK - 84);
+            return 0;
+        }
+};
+
+#define ADT_LIQUID_HEADER_FULL_LIGHT   0x01
+#define ADT_LIQUID_HEADER_NO_HIGHT     0x02
+
+struct adt_liquid_header
+{
+    uint16 liquidType;             // Index from LiquidType.dbc
+    uint16 formatFlags;
+    float  heightLevel1;
+    float  heightLevel2;
+    uint8  xOffset;
+    uint8  yOffset;
+    uint8  width;
+    uint8  height;
+    uint32 offsData2a;
+    uint32 offsData2b;
+};
+
+//
+// Adt file liquid data chunk (new)
+//
+class adt_MH2O
+{
+    public:
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+        uint32 size;
+
+        struct adt_LIQUID
+        {
+            uint32 offsData1;
+            uint32 used;
+            uint32 offsData2;
+        } liquid[ADT_CELLS_PER_GRID][ADT_CELLS_PER_GRID];
+
+        bool   prepareLoadedData();
+
+        adt_liquid_header* getLiquidData(int x, int y)
+        {
+            if (liquid[x][y].used && liquid[x][y].offsData1)
+                return (adt_liquid_header*)((uint8*)this + 8 + liquid[x][y].offsData1);
+            return 0;
+        }
+
+        float* getLiquidHeightMap(adt_liquid_header* h)
+        {
+            if (h->formatFlags & ADT_LIQUID_HEADER_NO_HIGHT)
+                return 0;
+            if (h->offsData2b)
+                return (float*)((uint8*)this + 8 + h->offsData2b);
+            return 0;
+        }
+
+        uint8* getLiquidLightMap(adt_liquid_header* h)
+        {
+            if (h->formatFlags & ADT_LIQUID_HEADER_FULL_LIGHT)
+                return 0;
+            if (h->offsData2b)
+            {
+                if (h->formatFlags & ADT_LIQUID_HEADER_NO_HIGHT)
+                    return (uint8*)((uint8*)this + 8 + h->offsData2b);
+                return (uint8*)((uint8*)this + 8 + h->offsData2b + (h->width + 1) * (h->height + 1) * 4);
+            }
+            return 0;
+        }
+
+        uint32* getLiquidFullLightMap(adt_liquid_header* h)
+        {
+            if (!(h->formatFlags & ADT_LIQUID_HEADER_FULL_LIGHT))
+                return 0;
+            if (h->offsData2b)
+            {
+                if (h->formatFlags & ADT_LIQUID_HEADER_NO_HIGHT)
+                    return (uint32*)((uint8*)this + 8 + h->offsData2b);
+                return (uint32*)((uint8*)this + 8 + h->offsData2b + (h->width + 1) * (h->height + 1) * 4);
+            }
+            return 0;
+        }
+
+        uint64 getLiquidShowMap(adt_liquid_header* h)
+        {
+            if (h->offsData2a)
+                return *((uint64*)((uint8*)this + 8 + h->offsData2a));
+            else
+                return 0xFFFFFFFFFFFFFFFFLL;
+        }
+};
+
+//
+// Adt file header chunk
+//
+class adt_MHDR
+{
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+        uint32 size;
+
+        uint32 pad;
+        uint32 offsMCIN;           // MCIN
+        uint32 offsTex;            // MTEX
+        uint32 offsModels;         // MMDX
+        uint32 offsModelsIds;      // MMID
+        uint32 offsMapObejcts;     // MWMO
+        uint32 offsMapObejctsIds;  // MWID
+        uint32 offsDoodsDef;       // MDDF
+        uint32 offsObjectsDef;     // MODF
+        uint32 offsMFBO;           // MFBO
+        uint32 offsMH2O;           // MH2O
+        uint32 data1;
+        uint32 data2;
+        uint32 data3;
+        uint32 data4;
+        uint32 data5;
+    public:
+        bool prepareLoadedData();
+        adt_MCIN* getMCIN() { return (adt_MCIN*)((uint8*)&pad + offsMCIN); }
+        adt_MH2O* getMH2O() { return offsMH2O ? (adt_MH2O*)((uint8*)&pad + offsMH2O) : 0; }
+};
+
+class ADT_file : public FileLoader
+{
+    public:
+        bool prepareLoadedData();
+        ADT_file();
+        ~ADT_file();
+        void free();
+
+        adt_MHDR* a_grid;
+};
+
+bool isHole(int holes, int i, int j);
+
+#endif
diff -Nuar clean-build/maptools/map_extractor/map_loadlib/CMakeLists.txt temp-build/maptools/map_extractor/map_loadlib/CMakeLists.txt
--- clean-build/maptools/map_extractor/map_loadlib/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/map_loadlib/CMakeLists.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,4 @@
+add_library (map_loadlib loadlib.cpp adt.cpp wdt.cpp)
+
+target_link_libraries (map_loadlib zlib_mt)
+
diff -Nuar clean-build/maptools/map_extractor/map_loadlib/loadlib.cpp temp-build/maptools/map_extractor/map_loadlib/loadlib.cpp
--- clean-build/maptools/map_extractor/map_loadlib/loadlib.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/map_loadlib/loadlib.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,66 @@
+#define _CRT_SECURE_NO_DEPRECATE
+
+#include "loadlib.h"
+#include "../mpq_libmpq.h"
+
+#include <stdio.h>
+
+class MPQFile;
+
+FileLoader::FileLoader()
+{
+    data = 0;
+    data_size = 0;
+    version = 0;
+}
+
+FileLoader::~FileLoader()
+{
+    free();
+}
+
+bool FileLoader::loadFile(char* filename, bool log)
+{
+    free();
+    MPQFile mf(filename);
+    if (mf.isEof())
+    {
+        if (log)
+            printf("No such file %s\n", filename);
+        return false;
+    }
+
+    data_size = mf.getSize();
+
+    data = new uint8 [data_size];
+    if (data)
+    {
+        mf.read(data, data_size);
+        mf.close();
+        if (prepareLoadedData())
+            return true;
+    }
+    printf("Error loading %s", filename);
+    mf.close();
+    free();
+    return false;
+}
+
+bool FileLoader::prepareLoadedData()
+{
+    // Check version
+    version = (file_MVER*) data;
+    if (version->fcc != 'MVER')
+        return false;
+    if (version->ver != FILE_FORMAT_VERSION)
+        return false;
+    return true;
+}
+
+void FileLoader::free()
+{
+    if (data) delete[] data;
+    data = 0;
+    data_size = 0;
+    version = 0;
+}
\ No newline at end of file
diff -Nuar clean-build/maptools/map_extractor/map_loadlib/loadlib.h temp-build/maptools/map_extractor/map_loadlib/loadlib.h
--- clean-build/maptools/map_extractor/map_loadlib/loadlib.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/map_loadlib/loadlib.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,52 @@
+#ifndef LOAD_LIB_H
+#define LOAD_LIB_H
+
+#include <stdint.h>
+
+#ifndef uint64_t
+#  ifdef __linux__
+#    include <linux/types.h>
+#  endif
+#endif
+
+typedef int64_t            int64;
+typedef int32_t            int32;
+typedef int16_t            int16;
+typedef int8_t             int8;
+typedef uint64_t           uint64;
+typedef uint32_t           uint32;
+typedef uint16_t           uint16;
+typedef uint8_t            uint8;
+
+#define FILE_FORMAT_VERSION    18
+
+//
+// File version chunk
+//
+struct file_MVER
+{
+    union
+    {
+        uint32 fcc;
+        char   fcc_txt[4];
+    };
+    uint32 size;
+    uint32 ver;
+};
+
+class FileLoader
+{
+        uint8*  data;
+        uint32  data_size;
+    public:
+        virtual bool prepareLoadedData();
+        uint8* GetData()     {return data;}
+        uint32 GetDataSize() {return data_size;}
+
+        file_MVER* version;
+        FileLoader();
+        ~FileLoader();
+        bool loadFile(char* filename, bool log = true);
+        virtual void free();
+};
+#endif
diff -Nuar clean-build/maptools/map_extractor/map_loadlib/wdt.cpp temp-build/maptools/map_extractor/map_loadlib/wdt.cpp
--- clean-build/maptools/map_extractor/map_loadlib/wdt.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/map_loadlib/wdt.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,62 @@
+#define _CRT_SECURE_NO_DEPRECATE
+
+#include "wdt.h"
+
+bool wdt_MWMO::prepareLoadedData()
+{
+    if (fcc != 'MWMO')
+        return false;
+    return true;
+}
+
+bool wdt_MPHD::prepareLoadedData()
+{
+    if (fcc != 'MPHD')
+        return false;
+    return true;
+}
+
+bool wdt_MAIN::prepareLoadedData()
+{
+    if (fcc != 'MAIN')
+        return false;
+    return true;
+}
+
+WDT_file::WDT_file()
+{
+    mphd = 0;
+    main = 0;
+    wmo  = 0;
+}
+
+WDT_file::~WDT_file()
+{
+    free();
+}
+
+void WDT_file::free()
+{
+    mphd = 0;
+    main = 0;
+    wmo  = 0;
+    FileLoader::free();
+}
+
+bool WDT_file::prepareLoadedData()
+{
+    // Check parent
+    if (!FileLoader::prepareLoadedData())
+        return false;
+
+    mphd = (wdt_MPHD*)((uint8*)version + version->size + 8);
+    if (!mphd->prepareLoadedData())
+        return false;
+    main = (wdt_MAIN*)((uint8*)mphd + mphd->size + 8);
+    if (!main->prepareLoadedData())
+        return false;
+    wmo = (wdt_MWMO*)((uint8*)main + main->size + 8);
+    if (!wmo->prepareLoadedData())
+        return false;
+    return true;
+}
\ No newline at end of file
diff -Nuar clean-build/maptools/map_extractor/map_loadlib/wdt.h temp-build/maptools/map_extractor/map_loadlib/wdt.h
--- clean-build/maptools/map_extractor/map_loadlib/wdt.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/map_loadlib/wdt.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,76 @@
+#ifndef WDT_H
+#define WDT_H
+#include "loadlib.h"
+
+//**************************************************************************************
+// WDT file class and structures
+//**************************************************************************************
+#define WDT_MAP_SIZE 64
+
+class wdt_MWMO
+{
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+    public:
+        uint32 size;
+        bool prepareLoadedData();
+};
+
+class wdt_MPHD
+{
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+    public:
+        uint32 size;
+
+        uint32 data1;
+        uint32 data2;
+        uint32 data3;
+        uint32 data4;
+        uint32 data5;
+        uint32 data6;
+        uint32 data7;
+        uint32 data8;
+        bool   prepareLoadedData();
+};
+
+class wdt_MAIN
+{
+        union
+        {
+            uint32 fcc;
+            char   fcc_txt[4];
+        };
+    public:
+        uint32 size;
+
+        struct adtData
+        {
+            uint32 exist;
+            uint32 data1;
+        } adt_list[64][64];
+
+        bool   prepareLoadedData();
+};
+
+class WDT_file : public FileLoader
+{
+    public:
+        bool   prepareLoadedData();
+
+        WDT_file();
+        ~WDT_file();
+        void free();
+
+        wdt_MPHD* mphd;
+        wdt_MAIN* main;
+        wdt_MWMO* wmo;
+};
+
+#endif
\ No newline at end of file
diff -Nuar clean-build/maptools/map_extractor/mpq_libmpq.cpp temp-build/maptools/map_extractor/mpq_libmpq.cpp
--- clean-build/maptools/map_extractor/mpq_libmpq.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/mpq_libmpq.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,136 @@
+#include "mpq_libmpq.h"
+#include <deque>
+#include <stdio.h>
+
+ArchiveSet gOpenArchives;
+
+MPQArchive::MPQArchive(const char* filename)
+{
+    int result = libmpq_archive_open(&mpq_a, (unsigned char*)filename);
+    printf("Opening %s\n", filename);
+    if (result)
+    {
+        switch (result)
+        {
+            case LIBMPQ_EFILE :                   /* error on file operation */
+                printf("Error opening archive '%s': File operation Error\n", filename);
+                break;
+            case LIBMPQ_EFILE_FORMAT :            /* bad file format */
+                printf("Error opening archive '%s': Bad file format\n", filename);
+                break;
+            case LIBMPQ_EFILE_CORRUPT :           /* file corrupt */
+                printf("Error opening archive '%s': File corrupt\n", filename);
+                break;
+            case LIBMPQ_EFILE_NOT_FOUND :         /* file in archive not found */
+                printf("Error opening archive '%s': File in archive not found\n", filename);
+                break;
+            case LIBMPQ_EFILE_READ :              /* Read error in archive */
+                printf("Error opening archive '%s': Read error in archive\n", filename);
+                break;
+            case LIBMPQ_EALLOCMEM :               /* maybe not enough memory? :) */
+                printf("Error opening archive '%s': Maybe not enough memory\n", filename);
+                break;
+            case LIBMPQ_EFREEMEM :                /* can not free memory */
+                printf("Error opening archive '%s': Cannot free memory\n", filename);
+                break;
+            case LIBMPQ_EINV_RANGE :              /* Given filenumber is out of range */
+                printf("Error opening archive '%s': Given filenumber is out of range\n", filename);
+                break;
+            case LIBMPQ_EHASHTABLE :              /* error in reading hashtable */
+                printf("Error opening archive '%s': Error in reading hashtable\n", filename);
+                break;
+            case LIBMPQ_EBLOCKTABLE :             /* error in reading blocktable */
+                printf("Error opening archive '%s': Error in reading blocktable\n", filename);
+                break;
+            default:
+                printf("Error opening archive '%s': Unknown error\n", filename);
+                break;
+        }
+        return;
+    }
+    gOpenArchives.push_front(this);
+}
+
+void MPQArchive::close()
+{
+    //gOpenArchives.erase(erase(&mpq_a);
+    libmpq_archive_close(&mpq_a);
+}
+
+MPQFile::MPQFile(const char* filename):
+    eof(false),
+    buffer(0),
+    pointer(0),
+    size(0)
+{
+    for (ArchiveSet::iterator i = gOpenArchives.begin(); i != gOpenArchives.end(); ++i)
+    {
+        mpq_archive& mpq_a = (*i)->mpq_a;
+
+        mpq_hash hash = (*i)->GetHashEntry(filename);
+        uint32 blockindex = hash.blockindex;
+
+        if (blockindex == 0xFFFFFFFF)
+            continue; //file not found
+
+        uint32 fileno = blockindex;
+
+        //int fileno = libmpq_file_number(&mpq_a, filename);
+        //if(fileno == LIBMPQ_EFILE_NOT_FOUND)
+        //    continue;
+
+        // Found!
+        size = libmpq_file_info(&mpq_a, LIBMPQ_FILE_UNCOMPRESSED_SIZE, fileno);
+        // HACK: in patch.mpq some files don't want to open and give 1 for filesize
+        if (size <= 1)
+        {
+            eof = true;
+            buffer = 0;
+            return;
+        }
+        buffer = new char[size];
+
+        //libmpq_file_getdata
+        libmpq_file_getdata(&mpq_a, hash, fileno, (unsigned char*)buffer);
+        return;
+    }
+    eof = true;
+    buffer = 0;
+}
+
+size_t MPQFile::read(void* dest, size_t bytes)
+{
+    if (eof) return 0;
+
+    size_t rpos = pointer + bytes;
+    if (rpos > size)
+    {
+        bytes = size - pointer;
+        eof = true;
+    }
+
+    memcpy(dest, &(buffer[pointer]), bytes);
+
+    pointer = rpos;
+
+    return bytes;
+}
+
+void MPQFile::seek(int offset)
+{
+    pointer = offset;
+    eof = (pointer >= size);
+}
+
+void MPQFile::seekRelative(int offset)
+{
+    pointer += offset;
+    eof = (pointer >= size);
+}
+
+void MPQFile::close()
+{
+    if (buffer) delete[] buffer;
+    buffer = 0;
+    eof = true;
+}
diff -Nuar clean-build/maptools/map_extractor/mpq_libmpq.h temp-build/maptools/map_extractor/mpq_libmpq.h
--- clean-build/maptools/map_extractor/mpq_libmpq.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/mpq_libmpq.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,127 @@
+#define _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_WARNINGS
+
+#ifndef MPQ_H
+#define MPQ_H
+
+#include "map_loadlib/loadlib.h"
+#include "libmpq03/mpq.h"
+#include <string.h>
+#include <ctype.h>
+#include <vector>
+#include <iostream>
+#include <deque>
+
+using namespace std;
+
+class MPQArchive
+{
+
+    public:
+        mpq_archive mpq_a;
+
+        MPQArchive(const char* filename);
+        void close();
+
+        uint32 HashString(const char* Input, uint32 Offset)
+        {
+            uint32 seed1 = 0x7fed7fed;
+            uint32 seed2 = 0xeeeeeeee;
+
+            for (uint32 i = 0; i < strlen(Input); i++)
+            {
+                uint32 val = toupper(Input[i]);
+                seed1 = mpq_a.buf[Offset + val] ^ (seed1 + seed2);
+                seed2 = val + seed1 + seed2 + (seed2 << 5) + 3;
+            }
+
+            return seed1;
+        }
+        mpq_hash GetHashEntry(const char* Filename)
+        {
+            uint32 index = HashString(Filename, 0);
+            index &= mpq_a.header->hashtablesize - 1;
+            uint32 name1 = HashString(Filename, 0x100);
+            uint32 name2 = HashString(Filename, 0x200);
+
+            for (uint32 i = index; i < mpq_a.header->hashtablesize; ++i)
+            {
+                mpq_hash hash = mpq_a.hashtable[i];
+                if (hash.name1 == name1 && hash.name2 == name2) return hash;
+            }
+
+            mpq_hash nullhash;
+            nullhash.blockindex = 0xFFFFFFFF;
+            return nullhash;
+        }
+
+        void GetFileListTo(vector<string>& filelist)
+        {
+            mpq_hash hash = GetHashEntry("(listfile)");
+            uint32 blockindex = hash.blockindex;
+
+            if ((blockindex == 0xFFFFFFFF) || (blockindex == 0))
+                return;
+
+            uint32 size = libmpq_file_info(&mpq_a, LIBMPQ_FILE_UNCOMPRESSED_SIZE, blockindex);
+            char* buffer = new char[size];
+
+            libmpq_file_getdata(&mpq_a, hash, blockindex, (unsigned char*)buffer);
+
+            char seps[] = "\n";
+            char* token;
+
+            token = strtok(buffer, seps);
+            uint32 counter = 0;
+            while ((token != NULL) && (counter < size))
+            {
+                //cout << token << endl;
+                token[strlen(token) - 1] = 0;
+                string s = token;
+                filelist.push_back(s);
+                counter += strlen(token) + 2;
+                token = strtok(NULL, seps);
+            }
+
+            delete[] buffer;
+        }
+};
+typedef std::deque<MPQArchive*> ArchiveSet;
+
+class MPQFile
+{
+        //MPQHANDLE handle;
+        bool eof;
+        char* buffer;
+        size_t pointer, size;
+
+        // disable copying
+        MPQFile(const MPQFile& f) {}
+        void operator=(const MPQFile& f) {}
+
+    public:
+        MPQFile(const char* filename);    // filenames are not case sensitive
+        ~MPQFile() { close(); }
+        size_t read(void* dest, size_t bytes);
+        size_t getSize() { return size; }
+        size_t getPos() { return pointer; }
+        char* getBuffer() { return buffer; }
+        char* getPointer() { return buffer + pointer; }
+        bool isEof() { return eof; }
+        void seek(int offset);
+        void seekRelative(int offset);
+        void close();
+};
+
+inline void flipcc(char* fcc)
+{
+    char t;
+    t = fcc[0];
+    fcc[0] = fcc[3];
+    fcc[3] = t;
+    t = fcc[1];
+    fcc[1] = fcc[2];
+    fcc[2] = t;
+}
+
+#endif
diff -Nuar clean-build/maptools/map_extractor/System.cpp temp-build/maptools/map_extractor/System.cpp
--- clean-build/maptools/map_extractor/System.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/map_extractor/System.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,1119 @@
+#define _CRT_SECURE_NO_DEPRECATE
+
+#include <stdio.h>
+#include <deque>
+#include <set>
+#include <cstdlib>
+#include <sys/stat.h>
+
+#include "dbcfile.h"
+#include "mpq_libmpq.h"
+#include "map_loadlib/adt.h"
+#include "map_loadlib/wdt.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+
+#if defined( __GNUC__ )
+#define _open   open
+#define _close close
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+#else
+#include <io.h>
+#endif
+
+#ifdef O_LARGEFILE
+#define OPEN_FLAGS  (O_RDONLY | O_BINARY | O_LARGEFILE)
+#else
+#define OPEN_FLAGS (O_RDONLY | O_BINARY)
+#endif
+extern ArchiveSet gOpenArchives;
+
+typedef struct
+{
+    char name[64];
+    uint32 id;
+} map_id;
+
+map_id* map_ids;
+uint16* areas;
+uint16* LiqType;
+char output_path[128] = ".";
+char input_path[128] = ".";
+uint32 maxAreaId = 0;
+
+//**************************************************
+// Extractor options
+//**************************************************
+enum Extract
+{
+    EXTRACT_MAP = 1,
+    EXTRACT_DBC = 2
+};
+
+// Select data for extract
+int   CONF_extract = EXTRACT_MAP | EXTRACT_DBC;
+// This option allow limit minimum height to some value (Allow save some memory)
+// see contrib/mmap/src/Tilebuilder.h, INVALID_MAP_LIQ_HEIGHT
+bool  CONF_allow_height_limit = true;
+float CONF_use_minHeight = -500.0f;
+
+// This option allow use float to int conversion
+bool  CONF_allow_float_to_int   = true;
+float CONF_float_to_int8_limit  = 2.0f;      // Max accuracy = val/256
+float CONF_float_to_int16_limit = 2048.0f;   // Max accuracy = val/65536
+float CONF_flat_height_delta_limit = 0.005f; // If max - min less this value - surface is flat
+float CONF_flat_liquid_delta_limit = 0.001f; // If max - min less this value - liquid surface is flat
+
+// List MPQ for extract from
+const char* CONF_mpq_list[] =
+{
+    "common.MPQ",
+    "common-2.MPQ",
+    "lichking.MPQ",
+    "expansion.MPQ",
+    "patch.MPQ",
+    "patch-2.MPQ",
+    "patch-3.MPQ",
+    "patch-4.MPQ",
+    "patch-5.MPQ",
+};
+
+static char* const langs[] = {"enGB", "enUS", "deDE", "esES", "frFR", "koKR", "zhCN", "zhTW", "enCN", "enTW", "esMX", "ruRU" };
+#define LANG_COUNT 12
+
+void CreateDir(const std::string& Path)
+{
+    mkdir(Path.c_str(), 0777);
+}
+
+bool FileExists(const char* FileName)
+{
+    int fp = _open(FileName, OPEN_FLAGS);
+    if (fp != -1)
+    {
+        _close(fp);
+        return true;
+    }
+
+    return false;
+}
+
+void Usage(char* prg)
+{
+    printf(
+        "Usage:\n"\
+        "%s -[var] [value]\n"\
+        "-i set input path\n"\
+        "-o set output path\n"\
+        "-e extract only MAP(1)/DBC(2) - standard: both(3)\n"\
+        "-f height stored as int (less map size but lost some accuracy) 1 by default\n"\
+        "Example: %s -f 0 -i \"c:\\games\\game\"", prg, prg);
+    exit(1);
+}
+
+void HandleArgs(int argc, char* arg[])
+{
+    for (int c = 1; c < argc; ++c)
+    {
+        // i - input path
+        // o - output path
+        // e - extract only MAP(1)/DBC(2) - standard both(3)
+        // f - use float to int conversion
+        // h - limit minimum height
+        if (arg[c][0] != '-')
+            Usage(arg[0]);
+
+        switch (arg[c][1])
+        {
+            case 'i':
+                if (c + 1 < argc)                           // all ok
+                    strcpy(input_path, arg[(c++) + 1]);
+                else
+                    Usage(arg[0]);
+                break;
+            case 'o':
+                if (c + 1 < argc)                           // all ok
+                    strcpy(output_path, arg[(c++) + 1]);
+                else
+                    Usage(arg[0]);
+                break;
+            case 'f':
+                if (c + 1 < argc)                           // all ok
+                    CONF_allow_float_to_int = atoi(arg[(c++) + 1]) != 0;
+                else
+                    Usage(arg[0]);
+                break;
+            case 'e':
+                if (c + 1 < argc)                           // all ok
+                {
+                    CONF_extract = atoi(arg[(c++) + 1]);
+                    if (!(CONF_extract > 0 && CONF_extract < 4))
+                        Usage(arg[0]);
+                }
+                else
+                    Usage(arg[0]);
+                break;
+        }
+    }
+}
+
+uint32 ReadBuild(int locale)
+{
+    // include build info file also
+    std::string filename  = std::string("component.wow-") + langs[locale] + ".txt";
+    //printf("Read %s file... ", filename.c_str());
+
+    MPQFile m(filename.c_str());
+    if (m.isEof())
+    {
+        printf("Fatal error: Not found %s file!\n", filename.c_str());
+        exit(1);
+    }
+
+    std::string text = m.getPointer();
+    m.close();
+
+    size_t pos = text.find("version=\"");
+    size_t pos1 = pos + strlen("version=\"");
+    size_t pos2 = text.find("\"", pos1);
+    if (pos == text.npos || pos2 == text.npos || pos1 >= pos2)
+    {
+        printf("Fatal error: Invalid  %s file format!\n", filename.c_str());
+        exit(1);
+    }
+
+    std::string build_str = text.substr(pos1, pos2 - pos1);
+
+    int build = atoi(build_str.c_str());
+    if (build <= 0)
+    {
+        printf("Fatal error: Invalid  %s file format!\n", filename.c_str());
+        exit(1);
+    }
+
+    return build;
+}
+
+uint32 ReadMapDBC()
+{
+    printf("Read Map.dbc file... ");
+    DBCFile dbc("DBFilesClient\\Map.dbc");
+
+    if (!dbc.open())
+    {
+        printf("Fatal error: Invalid Map.dbc file format!\n");
+        exit(1);
+    }
+
+    size_t map_count = dbc.getRecordCount();
+    map_ids = new map_id[map_count];
+    for (uint32 x = 0; x < map_count; ++x)
+    {
+        map_ids[x].id = dbc.getRecord(x).getUInt(0);
+        strcpy(map_ids[x].name, dbc.getRecord(x).getString(1));
+    }
+    printf("Done! (%u maps loaded)\n", map_count);
+    return map_count;
+}
+
+void ReadAreaTableDBC()
+{
+    printf("Read AreaTable.dbc file...");
+    DBCFile dbc("DBFilesClient\\AreaTable.dbc");
+
+    if (!dbc.open())
+    {
+        printf("Fatal error: Invalid AreaTable.dbc file format!\n");
+        exit(1);
+    }
+
+    size_t area_count = dbc.getRecordCount();
+    size_t maxid = dbc.getMaxId();
+    areas = new uint16[maxid + 1];
+    memset(areas, 0xff, (maxid + 1) * sizeof(uint16));
+
+    for (uint32 x = 0; x < area_count; ++x)
+        areas[dbc.getRecord(x).getUInt(0)] = dbc.getRecord(x).getUInt(3);
+
+    maxAreaId = dbc.getMaxId();
+
+    printf("Done! (%u areas loaded)\n", area_count);
+}
+
+void ReadLiquidTypeTableDBC()
+{
+    printf("Read LiquidType.dbc file...");
+    DBCFile dbc("DBFilesClient\\LiquidType.dbc");
+    if (!dbc.open())
+    {
+        printf("Fatal error: Invalid LiquidType.dbc file format!\n");
+        exit(1);
+    }
+
+    size_t LiqType_count = dbc.getRecordCount();
+    size_t LiqType_maxid = dbc.getMaxId();
+    LiqType = new uint16[LiqType_maxid + 1];
+    memset(LiqType, 0xff, (LiqType_maxid + 1) * sizeof(uint16));
+
+    for (uint32 x = 0; x < LiqType_count; ++x)
+        LiqType[dbc.getRecord(x).getUInt(0)] = dbc.getRecord(x).getUInt(3);
+
+    printf("Done! (%u LiqTypes loaded)\n", LiqType_count);
+}
+
+//
+// Adt file convertor function and data
+//
+
+// Map file format data
+static char const* MAP_MAGIC         = "MAPS";
+static char const* MAP_VERSION_MAGIC = "v1.3";
+static char const* MAP_AREA_MAGIC    = "AREA";
+static char const* MAP_HEIGHT_MAGIC  = "MHGT";
+static char const* MAP_LIQUID_MAGIC  = "MLIQ";
+
+struct map_fileheader
+{
+    uint32 mapMagic;
+    uint32 versionMagic;
+    uint32 buildMagic;
+    uint32 areaMapOffset;
+    uint32 areaMapSize;
+    uint32 heightMapOffset;
+    uint32 heightMapSize;
+    uint32 liquidMapOffset;
+    uint32 liquidMapSize;
+    uint32 holesOffset;
+    uint32 holesSize;
+};
+
+#define MAP_AREA_NO_AREA      0x0001
+
+struct map_areaHeader
+{
+    uint32 fourcc;
+    uint16 flags;
+    uint16 gridArea;
+};
+
+#define MAP_HEIGHT_NO_HEIGHT  0x0001
+#define MAP_HEIGHT_AS_INT16   0x0002
+#define MAP_HEIGHT_AS_INT8    0x0004
+
+struct map_heightHeader
+{
+    uint32 fourcc;
+    uint32 flags;
+    float  gridHeight;
+    float  gridMaxHeight;
+};
+
+#define MAP_LIQUID_TYPE_NO_WATER    0x00
+#define MAP_LIQUID_TYPE_WATER       0x01
+#define MAP_LIQUID_TYPE_OCEAN       0x02
+#define MAP_LIQUID_TYPE_MAGMA       0x04
+#define MAP_LIQUID_TYPE_SLIME       0x08
+
+#define MAP_LIQUID_TYPE_DARK_WATER  0x10
+#define MAP_LIQUID_TYPE_WMO_WATER   0x20
+
+#define MAP_LIQUID_NO_TYPE    0x0001
+#define MAP_LIQUID_NO_HEIGHT  0x0002
+
+struct map_liquidHeader
+{
+    uint32 fourcc;
+    uint16 flags;
+    uint16 liquidType;
+    uint8  offsetX;
+    uint8  offsetY;
+    uint8  width;
+    uint8  height;
+    float  liquidLevel;
+};
+
+float selectUInt8StepStore(float maxDiff)
+{
+    return 255 / maxDiff;
+}
+
+float selectUInt16StepStore(float maxDiff)
+{
+    return 65535 / maxDiff;
+}
+// Temporary grid data store
+uint16 area_flags[ADT_CELLS_PER_GRID][ADT_CELLS_PER_GRID];
+
+float V8[ADT_GRID_SIZE][ADT_GRID_SIZE];
+float V9[ADT_GRID_SIZE + 1][ADT_GRID_SIZE + 1];
+uint16 uint16_V8[ADT_GRID_SIZE][ADT_GRID_SIZE];
+uint16 uint16_V9[ADT_GRID_SIZE + 1][ADT_GRID_SIZE + 1];
+uint8  uint8_V8[ADT_GRID_SIZE][ADT_GRID_SIZE];
+uint8  uint8_V9[ADT_GRID_SIZE + 1][ADT_GRID_SIZE + 1];
+
+uint16 liquid_entry[ADT_CELLS_PER_GRID][ADT_CELLS_PER_GRID];
+uint8 liquid_flags[ADT_CELLS_PER_GRID][ADT_CELLS_PER_GRID];
+bool  liquid_show[ADT_GRID_SIZE][ADT_GRID_SIZE];
+float liquid_height[ADT_GRID_SIZE + 1][ADT_GRID_SIZE + 1];
+
+bool ConvertADT(char* filename, char* filename2, int cell_y, int cell_x, uint32 build)
+{
+    ADT_file adt;
+
+    if (!adt.loadFile(filename))
+        return false;
+
+    adt_MCIN* cells = adt.a_grid->getMCIN();
+    if (!cells)
+    {
+        printf("Can't find cells in '%s'\n", filename);
+        return false;
+    }
+
+    memset(liquid_show, 0, sizeof(liquid_show));
+    memset(liquid_flags, 0, sizeof(liquid_flags));
+    memset(liquid_entry, 0, sizeof(liquid_entry));
+
+    // Prepare map header
+    map_fileheader map;
+    map.mapMagic = *(uint32 const*)MAP_MAGIC;
+    map.versionMagic = *(uint32 const*)MAP_VERSION_MAGIC;
+    map.buildMagic = build;
+
+    // Get area flags data
+    for (int i = 0; i < ADT_CELLS_PER_GRID; i++)
+    {
+        for (int j = 0; j < ADT_CELLS_PER_GRID; j++)
+        {
+            adt_MCNK* cell = cells->getMCNK(i, j);
+            uint32 areaid = cell->areaid;
+            if (areaid && areaid <= maxAreaId)
+            {
+                if (areas[areaid] != 0xffff)
+                {
+                    area_flags[i][j] = areas[areaid];
+                    continue;
+                }
+                printf("File: %s\nCan't find area flag for areaid %u [%d, %d].\n", filename, areaid, cell->ix, cell->iy);
+            }
+            area_flags[i][j] = 0xffff;
+        }
+    }
+    //============================================
+    // Try pack area data
+    //============================================
+    bool fullAreaData = false;
+    uint32 areaflag = area_flags[0][0];
+    for (int y = 0; y < ADT_CELLS_PER_GRID; y++)
+    {
+        for (int x = 0; x < ADT_CELLS_PER_GRID; x++)
+        {
+            if (area_flags[y][x] != areaflag)
+            {
+                fullAreaData = true;
+                break;
+            }
+        }
+    }
+
+    map.areaMapOffset = sizeof(map);
+    map.areaMapSize   = sizeof(map_areaHeader);
+
+    map_areaHeader areaHeader;
+    areaHeader.fourcc = *(uint32 const*)MAP_AREA_MAGIC;
+    areaHeader.flags = 0;
+    if (fullAreaData)
+    {
+        areaHeader.gridArea = 0;
+        map.areaMapSize += sizeof(area_flags);
+    }
+    else
+    {
+        areaHeader.flags |= MAP_AREA_NO_AREA;
+        areaHeader.gridArea = (uint16)areaflag;
+    }
+
+    //
+    // Get Height map from grid
+    //
+    for (int i = 0; i < ADT_CELLS_PER_GRID; i++)
+    {
+        for (int j = 0; j < ADT_CELLS_PER_GRID; j++)
+        {
+            adt_MCNK* cell = cells->getMCNK(i, j);
+            if (!cell)
+                continue;
+            // Height values for triangles stored in order:
+            // 1     2     3     4     5     6     7     8     9
+            //    10    11    12    13    14    15    16    17
+            // 18    19    20    21    22    23    24    25    26
+            //    27    28    29    30    31    32    33    34
+            // . . . . . . . .
+            // For better get height values merge it to V9 and V8 map
+            // V9 height map:
+            // 1     2     3     4     5     6     7     8     9
+            // 18    19    20    21    22    23    24    25    26
+            // . . . . . . . .
+            // V8 height map:
+            //    10    11    12    13    14    15    16    17
+            //    27    28    29    30    31    32    33    34
+            // . . . . . . . .
+
+            // Set map height as grid height
+            for (int y = 0; y <= ADT_CELL_SIZE; y++)
+            {
+                int cy = i * ADT_CELL_SIZE + y;
+                for (int x = 0; x <= ADT_CELL_SIZE; x++)
+                {
+                    int cx = j * ADT_CELL_SIZE + x;
+                    V9[cy][cx] = cell->ypos;
+                }
+            }
+            for (int y = 0; y < ADT_CELL_SIZE; y++)
+            {
+                int cy = i * ADT_CELL_SIZE + y;
+                for (int x = 0; x < ADT_CELL_SIZE; x++)
+                {
+                    int cx = j * ADT_CELL_SIZE + x;
+                    V8[cy][cx] = cell->ypos;
+                }
+            }
+            // Get custom height
+            adt_MCVT* v = cell->getMCVT();
+            if (!v)
+                continue;
+            // get V9 height map
+            for (int y = 0; y <= ADT_CELL_SIZE; y++)
+            {
+                int cy = i * ADT_CELL_SIZE + y;
+                for (int x = 0; x <= ADT_CELL_SIZE; x++)
+                {
+                    int cx = j * ADT_CELL_SIZE + x;
+                    V9[cy][cx] += v->height_map[y * (ADT_CELL_SIZE * 2 + 1) + x];
+                }
+            }
+            // get V8 height map
+            for (int y = 0; y < ADT_CELL_SIZE; y++)
+            {
+                int cy = i * ADT_CELL_SIZE + y;
+                for (int x = 0; x < ADT_CELL_SIZE; x++)
+                {
+                    int cx = j * ADT_CELL_SIZE + x;
+                    V8[cy][cx] += v->height_map[y * (ADT_CELL_SIZE * 2 + 1) + ADT_CELL_SIZE + 1 + x];
+                }
+            }
+        }
+    }
+    //============================================
+    // Try pack height data
+    //============================================
+    float maxHeight = -20000;
+    float minHeight =  20000;
+    for (int y = 0; y < ADT_GRID_SIZE; y++)
+    {
+        for (int x = 0; x < ADT_GRID_SIZE; x++)
+        {
+            float h = V8[y][x];
+            if (maxHeight < h) maxHeight = h;
+            if (minHeight > h) minHeight = h;
+        }
+    }
+    for (int y = 0; y <= ADT_GRID_SIZE; y++)
+    {
+        for (int x = 0; x <= ADT_GRID_SIZE; x++)
+        {
+            float h = V9[y][x];
+            if (maxHeight < h) maxHeight = h;
+            if (minHeight > h) minHeight = h;
+        }
+    }
+
+    // Check for allow limit minimum height (not store height in deep ochean - allow save some memory)
+    if (CONF_allow_height_limit && minHeight < CONF_use_minHeight)
+    {
+        for (int y = 0; y < ADT_GRID_SIZE; y++)
+            for (int x = 0; x < ADT_GRID_SIZE; x++)
+                if (V8[y][x] < CONF_use_minHeight)
+                    V8[y][x] = CONF_use_minHeight;
+        for (int y = 0; y <= ADT_GRID_SIZE; y++)
+            for (int x = 0; x <= ADT_GRID_SIZE; x++)
+                if (V9[y][x] < CONF_use_minHeight)
+                    V9[y][x] = CONF_use_minHeight;
+        if (minHeight < CONF_use_minHeight)
+            minHeight = CONF_use_minHeight;
+        if (maxHeight < CONF_use_minHeight)
+            maxHeight = CONF_use_minHeight;
+    }
+
+    map.heightMapOffset = map.areaMapOffset + map.areaMapSize;
+    map.heightMapSize = sizeof(map_heightHeader);
+
+    map_heightHeader heightHeader;
+    heightHeader.fourcc = *(uint32 const*)MAP_HEIGHT_MAGIC;
+    heightHeader.flags = 0;
+    heightHeader.gridHeight    = minHeight;
+    heightHeader.gridMaxHeight = maxHeight;
+
+    if (maxHeight == minHeight)
+        heightHeader.flags |= MAP_HEIGHT_NO_HEIGHT;
+
+    // Not need store if flat surface
+    if (CONF_allow_float_to_int && (maxHeight - minHeight) < CONF_flat_height_delta_limit)
+        heightHeader.flags |= MAP_HEIGHT_NO_HEIGHT;
+
+    // Try store as packed in uint16 or uint8 values
+    if (!(heightHeader.flags & MAP_HEIGHT_NO_HEIGHT))
+    {
+        float step;
+        // Try Store as uint values
+        if (CONF_allow_float_to_int)
+        {
+            float diff = maxHeight - minHeight;
+            if (diff < CONF_float_to_int8_limit)      // As uint8 (max accuracy = CONF_float_to_int8_limit/256)
+            {
+                heightHeader.flags |= MAP_HEIGHT_AS_INT8;
+                step = selectUInt8StepStore(diff);
+            }
+            else if (diff < CONF_float_to_int16_limit) // As uint16 (max accuracy = CONF_float_to_int16_limit/65536)
+            {
+                heightHeader.flags |= MAP_HEIGHT_AS_INT16;
+                step = selectUInt16StepStore(diff);
+            }
+        }
+
+        // Pack it to int values if need
+        if (heightHeader.flags & MAP_HEIGHT_AS_INT8)
+        {
+            for (int y = 0; y < ADT_GRID_SIZE; y++)
+                for (int x = 0; x < ADT_GRID_SIZE; x++)
+                    uint8_V8[y][x] = uint8((V8[y][x] - minHeight) * step + 0.5f);
+            for (int y = 0; y <= ADT_GRID_SIZE; y++)
+                for (int x = 0; x <= ADT_GRID_SIZE; x++)
+                    uint8_V9[y][x] = uint8((V9[y][x] - minHeight) * step + 0.5f);
+            map.heightMapSize += sizeof(uint8_V9) + sizeof(uint8_V8);
+        }
+        else if (heightHeader.flags & MAP_HEIGHT_AS_INT16)
+        {
+            for (int y = 0; y < ADT_GRID_SIZE; y++)
+                for (int x = 0; x < ADT_GRID_SIZE; x++)
+                    uint16_V8[y][x] = uint16((V8[y][x] - minHeight) * step + 0.5f);
+            for (int y = 0; y <= ADT_GRID_SIZE; y++)
+                for (int x = 0; x <= ADT_GRID_SIZE; x++)
+                    uint16_V9[y][x] = uint16((V9[y][x] - minHeight) * step + 0.5f);
+            map.heightMapSize += sizeof(uint16_V9) + sizeof(uint16_V8);
+        }
+        else
+            map.heightMapSize += sizeof(V9) + sizeof(V8);
+    }
+
+    // Get from MCLQ chunk (old)
+    for (int i = 0; i < ADT_CELLS_PER_GRID; i++)
+    {
+        for (int j = 0; j < ADT_CELLS_PER_GRID; j++)
+        {
+            adt_MCNK* cell = cells->getMCNK(i, j);
+            if (!cell)
+                continue;
+
+            adt_MCLQ* liquid = cell->getMCLQ();
+            int count = 0;
+            if (!liquid || cell->sizeMCLQ <= 8)
+                continue;
+
+            for (int y = 0; y < ADT_CELL_SIZE; y++)
+            {
+                int cy = i * ADT_CELL_SIZE + y;
+                for (int x = 0; x < ADT_CELL_SIZE; x++)
+                {
+                    int cx = j * ADT_CELL_SIZE + x;
+                    if (liquid->flags[y][x] != 0x0F)
+                    {
+                        liquid_show[cy][cx] = true;
+                        if (liquid->flags[y][x] & (1 << 7))
+                            liquid_flags[i][j] |= MAP_LIQUID_TYPE_DARK_WATER;
+                        ++count;
+                    }
+                }
+            }
+
+            uint32 c_flag = cell->flags;
+            if (c_flag & (1 << 2))
+            {
+                liquid_entry[i][j] = 1;
+                liquid_flags[i][j] |= MAP_LIQUID_TYPE_WATER;            // water
+            }
+            if (c_flag & (1 << 3))
+            {
+                liquid_entry[i][j] = 2;
+                liquid_flags[i][j] |= MAP_LIQUID_TYPE_OCEAN;            // ocean
+            }
+            if (c_flag & (1 << 4))
+            {
+                liquid_entry[i][j] = 3;
+                liquid_flags[i][j] |= MAP_LIQUID_TYPE_MAGMA;            // magma/slime
+            }
+
+            if (!count && liquid_flags[i][j])
+                fprintf(stderr, "Wrong liquid detect in MCLQ chunk");
+
+            for (int y = 0; y <= ADT_CELL_SIZE; y++)
+            {
+                int cy = i * ADT_CELL_SIZE + y;
+                for (int x = 0; x <= ADT_CELL_SIZE; x++)
+                {
+                    int cx = j * ADT_CELL_SIZE + x;
+                    liquid_height[cy][cx] = liquid->liquid[y][x].height;
+                }
+            }
+        }
+    }
+
+    // Get liquid map for grid (in WOTLK used MH2O chunk)
+    adt_MH2O* h2o = adt.a_grid->getMH2O();
+    if (h2o)
+    {
+        for (int i = 0; i < ADT_CELLS_PER_GRID; i++)
+        {
+            for (int j = 0; j < ADT_CELLS_PER_GRID; j++)
+            {
+                adt_liquid_header* h = h2o->getLiquidData(i, j);
+                if (!h)
+                    continue;
+
+                int count = 0;
+                uint64 show = h2o->getLiquidShowMap(h);
+                for (int y = 0; y < h->height; y++)
+                {
+                    int cy = i * ADT_CELL_SIZE + y + h->yOffset;
+                    for (int x = 0; x < h->width; x++)
+                    {
+                        int cx = j * ADT_CELL_SIZE + x + h->xOffset;
+                        if (show & 1)
+                        {
+                            liquid_show[cy][cx] = true;
+                            ++count;
+                        }
+                        show >>= 1;
+                    }
+                }
+
+                liquid_entry[i][j] = h->liquidType;
+                switch (LiqType[h->liquidType])
+                {
+                    case LIQUID_TYPE_WATER: liquid_flags[i][j] |= MAP_LIQUID_TYPE_WATER; break;
+                    case LIQUID_TYPE_OCEAN: liquid_flags[i][j] |= MAP_LIQUID_TYPE_OCEAN; break;
+                    case LIQUID_TYPE_MAGMA: liquid_flags[i][j] |= MAP_LIQUID_TYPE_MAGMA; break;
+                    case LIQUID_TYPE_SLIME: liquid_flags[i][j] |= MAP_LIQUID_TYPE_SLIME; break;
+                    default:
+                        printf("\nCan't find Liquid type %u for map %s\nchunk %d,%d\n", h->liquidType, filename, i, j);
+                        break;
+                }
+                // Dark water detect
+                if (LiqType[h->liquidType] == LIQUID_TYPE_OCEAN)
+                {
+                    uint8* lm = h2o->getLiquidLightMap(h);
+                    if (!lm)
+                        liquid_flags[i][j] |= MAP_LIQUID_TYPE_DARK_WATER;
+                }
+
+                if (!count && liquid_flags[i][j])
+                    printf("Wrong liquid detect in MH2O chunk");
+
+                float* height = h2o->getLiquidHeightMap(h);
+                int pos = 0;
+                for (int y = 0; y <= h->height; y++)
+                {
+                    int cy = i * ADT_CELL_SIZE + y + h->yOffset;
+                    for (int x = 0; x <= h->width; x++)
+                    {
+                        int cx = j * ADT_CELL_SIZE + x + h->xOffset;
+                        if (height)
+                            liquid_height[cy][cx] = height[pos];
+                        else
+                            liquid_height[cy][cx] = h->heightLevel1;
+                        pos++;
+                    }
+                }
+            }
+        }
+    }
+    //============================================
+    // Pack liquid data
+    //============================================
+    uint8 type = liquid_flags[0][0];
+    bool fullType = false;
+    for (int y = 0; y < ADT_CELLS_PER_GRID; y++)
+    {
+        for (int x = 0; x < ADT_CELLS_PER_GRID; x++)
+        {
+            if (liquid_flags[y][x] != type)
+            {
+                fullType = true;
+                y = ADT_CELLS_PER_GRID;
+                break;
+            }
+        }
+    }
+
+    map_liquidHeader liquidHeader;
+
+    // no water data (if all grid have 0 liquid type)
+    if (type == 0 && !fullType)
+    {
+        // No liquid data
+        map.liquidMapOffset = 0;
+        map.liquidMapSize   = 0;
+    }
+    else
+    {
+        int minX = 255, minY = 255;
+        int maxX = 0, maxY = 0;
+        maxHeight = -20000;
+        minHeight = 20000;
+        for (int y = 0; y < ADT_GRID_SIZE; y++)
+        {
+            for (int x = 0; x < ADT_GRID_SIZE; x++)
+            {
+                if (liquid_show[y][x])
+                {
+                    if (minX > x) minX = x;
+                    if (maxX < x) maxX = x;
+                    if (minY > y) minY = y;
+                    if (maxY < y) maxY = y;
+                    float h = liquid_height[y][x];
+                    if (maxHeight < h) maxHeight = h;
+                    if (minHeight > h) minHeight = h;
+                }
+                else
+                    liquid_height[y][x] = CONF_use_minHeight;
+            }
+        }
+        map.liquidMapOffset = map.heightMapOffset + map.heightMapSize;
+        map.liquidMapSize = sizeof(map_liquidHeader);
+        liquidHeader.fourcc = *(uint32 const*)MAP_LIQUID_MAGIC;
+        liquidHeader.flags = 0;
+        liquidHeader.liquidType = 0;
+        liquidHeader.offsetX = minX;
+        liquidHeader.offsetY = minY;
+        liquidHeader.width   = maxX - minX + 1 + 1;
+        liquidHeader.height  = maxY - minY + 1 + 1;
+        liquidHeader.liquidLevel = minHeight;
+
+        if (maxHeight == minHeight)
+            liquidHeader.flags |= MAP_LIQUID_NO_HEIGHT;
+
+        // Not need store if flat surface
+        if (CONF_allow_float_to_int && (maxHeight - minHeight) < CONF_flat_liquid_delta_limit)
+            liquidHeader.flags |= MAP_LIQUID_NO_HEIGHT;
+
+        if (!fullType)
+            liquidHeader.flags |= MAP_LIQUID_NO_TYPE;
+
+        if (liquidHeader.flags & MAP_LIQUID_NO_TYPE)
+            liquidHeader.liquidType = type;
+        else
+            map.liquidMapSize += sizeof(liquid_entry) + sizeof(liquid_flags);
+
+        if (!(liquidHeader.flags & MAP_LIQUID_NO_HEIGHT))
+            map.liquidMapSize += sizeof(float) * liquidHeader.width * liquidHeader.height;
+    }
+
+    // map hole info
+    uint16 holes[ADT_CELLS_PER_GRID][ADT_CELLS_PER_GRID];
+
+    if (map.liquidMapOffset)
+        map.holesOffset = map.liquidMapOffset + map.liquidMapSize;
+    else
+        map.holesOffset = map.heightMapOffset + map.heightMapSize;
+
+    map.holesSize = sizeof(holes);
+    memset(holes, 0, map.holesSize);
+
+    for (int i = 0; i < ADT_CELLS_PER_GRID; ++i)
+    {
+        for (int j = 0; j < ADT_CELLS_PER_GRID; ++j)
+        {
+            adt_MCNK* cell = cells->getMCNK(i, j);
+            if (!cell)
+                continue;
+            holes[i][j] = cell->holes;
+        }
+    }
+
+    // Ok all data prepared - store it
+    FILE* output = fopen(filename2, "wb");
+    if (!output)
+    {
+        printf("Can't create the output file '%s'\n", filename2);
+        return false;
+    }
+    fwrite(&map, sizeof(map), 1, output);
+    // Store area data
+    fwrite(&areaHeader, sizeof(areaHeader), 1, output);
+    if (!(areaHeader.flags & MAP_AREA_NO_AREA))
+        fwrite(area_flags, sizeof(area_flags), 1, output);
+
+    // Store height data
+    fwrite(&heightHeader, sizeof(heightHeader), 1, output);
+    if (!(heightHeader.flags & MAP_HEIGHT_NO_HEIGHT))
+    {
+        if (heightHeader.flags & MAP_HEIGHT_AS_INT16)
+        {
+            fwrite(uint16_V9, sizeof(uint16_V9), 1, output);
+            fwrite(uint16_V8, sizeof(uint16_V8), 1, output);
+        }
+        else if (heightHeader.flags & MAP_HEIGHT_AS_INT8)
+        {
+            fwrite(uint8_V9, sizeof(uint8_V9), 1, output);
+            fwrite(uint8_V8, sizeof(uint8_V8), 1, output);
+        }
+        else
+        {
+            fwrite(V9, sizeof(V9), 1, output);
+            fwrite(V8, sizeof(V8), 1, output);
+        }
+    }
+
+    // Store liquid data if need
+    if (map.liquidMapOffset)
+    {
+        fwrite(&liquidHeader, sizeof(liquidHeader), 1, output);
+        if (!(liquidHeader.flags & MAP_LIQUID_NO_TYPE))
+        {
+            fwrite(liquid_entry, sizeof(liquid_entry), 1, output);
+            fwrite(liquid_flags, sizeof(liquid_flags), 1, output);
+        }
+        if (!(liquidHeader.flags & MAP_LIQUID_NO_HEIGHT))
+        {
+            for (int y = 0; y < liquidHeader.height; y++)
+                fwrite(&liquid_height[y + liquidHeader.offsetY][liquidHeader.offsetX], sizeof(float), liquidHeader.width, output);
+        }
+    }
+
+    // store hole data
+    fwrite(holes, map.holesSize, 1, output);
+
+    fclose(output);
+
+    return true;
+}
+
+void ExtractMapsFromMpq(uint32 build)
+{
+    char mpq_filename[1024];
+    char output_filename[1024];
+    char mpq_map_name[1024];
+
+    printf("Extracting maps...\n");
+
+    uint32 map_count = ReadMapDBC();
+
+    ReadAreaTableDBC();
+    ReadLiquidTypeTableDBC();
+
+    std::string path = output_path;
+    path += "/maps/";
+    CreateDir(path);
+
+    printf("Convert map files\n");
+    for (uint32 z = 0; z < map_count; ++z)
+    {
+        printf("Extract %s (%d/%d)                  \n", map_ids[z].name, z + 1, map_count);
+        // Loadup map grid data
+        sprintf(mpq_map_name, "World\\Maps\\%s\\%s.wdt", map_ids[z].name, map_ids[z].name);
+        WDT_file wdt;
+        if (!wdt.loadFile(mpq_map_name, false))
+        {
+//            printf("Error loading %s map wdt data\n", map_ids[z].name);
+            continue;
+        }
+
+        for (uint32 y = 0; y < WDT_MAP_SIZE; ++y)
+        {
+            for (uint32 x = 0; x < WDT_MAP_SIZE; ++x)
+            {
+                if (!wdt.main->adt_list[y][x].exist)
+                    continue;
+                sprintf(mpq_filename, "World\\Maps\\%s\\%s_%u_%u.adt", map_ids[z].name, map_ids[z].name, x, y);
+                sprintf(output_filename, "%s/maps/%03u%02u%02u.map", output_path, map_ids[z].id, y, x);
+                ConvertADT(mpq_filename, output_filename, y, x, build);
+            }
+            // draw progress bar
+            printf("Processing........................%d%%\r", (100 * (y + 1)) / WDT_MAP_SIZE);
+        }
+    }
+    delete [] areas;
+    delete [] map_ids;
+}
+
+bool ExtractFile(char const* mpq_name, std::string const& filename)
+{
+    FILE* output = fopen(filename.c_str(), "wb");
+    if (!output)
+    {
+        printf("Can't create the output file '%s'\n", filename.c_str());
+        return false;
+    }
+    MPQFile m(mpq_name);
+    if (!m.isEof())
+        fwrite(m.getPointer(), 1, m.getSize(), output);
+
+    fclose(output);
+    return true;
+}
+
+void ExtractDBCFiles(int locale, bool basicLocale)
+{
+    printf("Extracting dbc files...\n");
+
+    std::set<std::string> dbcfiles;
+
+    // get DBC file list
+    for (ArchiveSet::iterator i = gOpenArchives.begin(); i != gOpenArchives.end(); ++i)
+    {
+        vector<string> files;
+        (*i)->GetFileListTo(files);
+        for (vector<string>::iterator iter = files.begin(); iter != files.end(); ++iter)
+            if (iter->rfind(".dbc") == iter->length() - strlen(".dbc"))
+                dbcfiles.insert(*iter);
+    }
+
+    std::string path = output_path;
+    path += "/dbc/";
+    CreateDir(path);
+    if (!basicLocale)
+    {
+        path += langs[locale];
+        path += "/";
+        CreateDir(path);
+    }
+
+    // extract Build info file
+    {
+        string mpq_name = std::string("component.wow-") + langs[locale] + ".txt";
+        string filename = path + mpq_name;
+
+        ExtractFile(mpq_name.c_str(), filename);
+    }
+
+    // extract DBCs
+    int count = 0;
+    for (set<string>::iterator iter = dbcfiles.begin(); iter != dbcfiles.end(); ++iter)
+    {
+        string filename = path;
+        filename += (iter->c_str() + strlen("DBFilesClient\\"));
+
+        if (ExtractFile(iter->c_str(), filename))
+            ++count;
+    }
+    printf("Extracted %u DBC files\n\n", count);
+}
+
+void LoadLocaleMPQFiles(int const locale)
+{
+    char filename[512];
+
+    sprintf(filename, "%s/Data/%s/locale-%s.MPQ", input_path, langs[locale], langs[locale]);
+    new MPQArchive(filename);
+
+    for (int i = 1; i < 5; ++i)
+    {
+        char ext[3] = "";
+        if (i > 1)
+            sprintf(ext, "-%i", i);
+
+        sprintf(filename, "%s/Data/%s/patch-%s%s.MPQ", input_path, langs[locale], langs[locale], ext);
+        if (FileExists(filename))
+            new MPQArchive(filename);
+    }
+}
+
+void LoadCommonMPQFiles()
+{
+    char filename[512];
+    int count = sizeof(CONF_mpq_list) / sizeof(char*);
+    for (int i = 0; i < count; ++i)
+    {
+        sprintf(filename, "%s/Data/%s", input_path, CONF_mpq_list[i]);
+        if (FileExists(filename))
+            new MPQArchive(filename);
+    }
+}
+
+inline void CloseMPQFiles()
+{
+    for (ArchiveSet::iterator j = gOpenArchives.begin(); j != gOpenArchives.end(); ++j)(*j)->close();
+    gOpenArchives.clear();
+}
+
+int main(int argc, char* arg[])
+{
+    printf("Map & DBC Extractor\n");
+    printf("===================\n\n");
+
+    HandleArgs(argc, arg);
+
+    int FirstLocale = -1;
+    uint32 build = 0;
+
+    for (int i = 0; i < LANG_COUNT; i++)
+    {
+        char tmp1[512];
+        sprintf(tmp1, "%s/Data/%s/locale-%s.MPQ", input_path, langs[i], langs[i]);
+        if (FileExists(tmp1))
+        {
+            printf("Detected locale: %s\n", langs[i]);
+
+            //Open MPQs
+            LoadLocaleMPQFiles(i);
+
+            if ((CONF_extract & EXTRACT_DBC) == 0)
+            {
+                FirstLocale = i;
+                build = ReadBuild(FirstLocale);
+                printf("Detected client build: %u\n", build);
+                break;
+            }
+
+            //Extract DBC files
+            if (FirstLocale < 0)
+            {
+                FirstLocale = i;
+                build = ReadBuild(FirstLocale);
+                printf("Detected client build: %u\n", build);
+                ExtractDBCFiles(i, true);
+            }
+            else
+                ExtractDBCFiles(i, false);
+
+            //Close MPQs
+            CloseMPQFiles();
+        }
+    }
+
+    if (FirstLocale < 0)
+    {
+        printf("No locales detected\n");
+        return 0;
+    }
+
+    if (CONF_extract & EXTRACT_MAP)
+    {
+        printf("Using locale: %s\n", langs[FirstLocale]);
+
+        // Open MPQs
+        LoadLocaleMPQFiles(FirstLocale);
+        LoadCommonMPQFiles();
+
+        // Extract maps
+        ExtractMapsFromMpq(build);
+
+        // Close MPQs
+        CloseMPQFiles();
+    }
+
+    return 0;
+}
diff -Nuar clean-build/maptools/mmap_generator/CMakeLists.txt temp-build/maptools/mmap_generator/CMakeLists.txt
--- clean-build/maptools/mmap_generator/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/CMakeLists.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,29 @@
+ADD_DEFINITIONS(-DMMAP_GENERATOR -DNO_CORE_FUNCS)
+
+add_library(vmap_mt2
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/BIH.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/VMapManager2.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/MapTree.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/TileAssembler.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/WorldModel.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/ModelInstance.cpp
+        )
+
+target_link_libraries(vmap_mt2 g3dlite zlib_mt)
+
+set(SOURCES
+    IntermediateValues.cpp
+    generator.cpp
+    MapBuilder.cpp
+    TerrainBuilder.cpp
+    VMapExtensions.cpp
+)
+
+add_executable(mmap_generator ${SOURCES})
+
+target_link_libraries(mmap_generator g3dlite vmap_mt2 detour recast zlib_mt)
+
+install(TARGETS mmap_generator DESTINATION ${CMAKE_INSTALL_PREFIX}/maptools)
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/mmap_build.sh DESTINATION ${CMAKE_INSTALL_PREFIX}/maptools)
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/offmesh.txt DESTINATION ${CMAKE_INSTALL_PREFIX}/maptools)
+
diff -Nuar clean-build/maptools/mmap_generator/CoreMap.h temp-build/maptools/mmap_generator/CoreMap.h
--- clean-build/maptools/mmap_generator/CoreMap.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/CoreMap.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,87 @@
+#ifndef _CORE_MAP_H
+#define _CORE_MAP_H
+
+// following is copied from src/game/GridMap.h (too many useless includes there to use original file)
+namespace System
+{
+    struct GridMapFileHeader
+    {
+        uint32 mapMagic;
+        uint32 versionMagic;
+        uint32 buildMagic;
+        uint32 areaMapOffset;
+        uint32 areaMapSize;
+        uint32 heightMapOffset;
+        uint32 heightMapSize;
+        uint32 liquidMapOffset;
+        uint32 liquidMapSize;
+        uint32 holesOffset;
+        uint32 holesSize;
+    };
+
+    // ==============mmaps don't use area==============
+    //#define MAP_AREA_NO_AREA      0x0001
+
+    //struct GridMapAreaHeader
+    //{
+    //    uint32 fourcc;
+    //    uint16 flags;
+    //    uint16 gridArea;
+    //};
+
+#define MAP_HEIGHT_NO_HEIGHT  0x0001
+#define MAP_HEIGHT_AS_INT16   0x0002
+#define MAP_HEIGHT_AS_INT8    0x0004
+
+    struct GridMapHeightHeader
+    {
+        uint32 fourcc;
+        uint32 flags;
+        float gridHeight;
+        float gridMaxHeight;
+    };
+
+#define MAP_LIQUID_NO_TYPE    0x0001
+#define MAP_LIQUID_NO_HEIGHT  0x0002
+
+    struct GridMapLiquidHeader
+    {
+        uint32 fourcc;
+        uint16 flags;
+        uint16 liquidType;
+        uint8 offsetX;
+        uint8 offsetY;
+        uint8 width;
+        uint8 height;
+        float liquidLevel;
+    };
+
+    //enum GridMapLiquidStatus
+    //{
+    //    LIQUID_MAP_NO_WATER     = 0x00000000,
+    //    LIQUID_MAP_ABOVE_WATER  = 0x00000001,
+    //    LIQUID_MAP_WATER_WALK   = 0x00000002,
+    //    LIQUID_MAP_IN_WATER     = 0x00000004,
+    //    LIQUID_MAP_UNDER_WATER  = 0x00000008
+    //};
+
+#define MAP_LIQUID_TYPE_NO_WATER    0x00
+#define MAP_LIQUID_TYPE_WATER       0x01
+#define MAP_LIQUID_TYPE_OCEAN       0x02
+#define MAP_LIQUID_TYPE_MAGMA       0x04
+#define MAP_LIQUID_TYPE_SLIME       0x08
+
+#define MAP_ALL_LIQUIDS   (MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_OCEAN | MAP_LIQUID_TYPE_MAGMA | MAP_LIQUID_TYPE_SLIME)
+
+#define MAP_LIQUID_TYPE_DARK_WATER  0x10
+#define MAP_LIQUID_TYPE_WMO_WATER   0x20
+
+    //struct GridMapLiquidData
+    //{
+    //    uint32 type;
+    //    float level;
+    //    float depth_level;
+    //};
+}
+
+#endif
diff -Nuar clean-build/maptools/mmap_generator/generator.cpp temp-build/maptools/mmap_generator/generator.cpp
--- clean-build/maptools/mmap_generator/generator.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/generator.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,281 @@
+#include "MMapCommon.h"
+#include "MapBuilder.h"
+
+using namespace MMAP;
+
+bool checkDirectories(bool debugOutput)
+{
+    vector<string> dirFiles;
+
+    if (getDirContents(dirFiles, "maps") == LISTFILE_DIRECTORY_NOT_FOUND || !dirFiles.size())
+    {
+        printf("'maps' directory is empty or does not exist\n");
+        return false;
+    }
+
+    dirFiles.clear();
+    if (getDirContents(dirFiles, "vmaps", "*.vmtree") == LISTFILE_DIRECTORY_NOT_FOUND || !dirFiles.size())
+    {
+        printf("'vmaps' directory is empty or does not exist\n");
+        return false;
+    }
+
+    dirFiles.clear();
+    if (getDirContents(dirFiles, "mmaps") == LISTFILE_DIRECTORY_NOT_FOUND)
+    {
+        printf("'mmaps' directory does not exist\n");
+        return false;
+    }
+
+    dirFiles.clear();
+    if (debugOutput)
+    {
+        if (getDirContents(dirFiles, "meshes") == LISTFILE_DIRECTORY_NOT_FOUND)
+        {
+            printf("'meshes' directory does not exist (no place to put debugOutput files)\n");
+            return false;
+        }
+    }
+
+    return true;
+}
+
+void printUsage()
+{
+    printf("Generator command line args\n\n");
+    printf("-? : This help\n");
+    printf("[#] : Build only the map specified by #.\n");
+    printf("--maxAngle [#] : Max walkable inclination angle\n");
+    printf("--tile [#,#] : Build the specified tile\n");
+    printf("--skipLiquid [true|false] : liquid data for maps\n");
+    printf("--skipContinents [true|false] : skip continents\n");
+    printf("--skipJunkMaps [true|false] : junk maps include some unused\n");
+    printf("--skipBattlegrounds [true|false] : does not include PVP arenas\n");
+    printf("--debugOutput [true|false] : create debugging files for use with RecastDemo\n");
+    printf("--bigBaseUnit [true|false] : Generate tile/map using bigger basic unit.\n");
+    printf("--silent : Make script friendly. No wait for user input, error, completion.\n");
+    printf("--offMeshInput [file.*] : Path to file containing off mesh connections data.\n\n");
+    printf("Exemple:\nmovemapgen (generate all mmap with default arg\n"
+        "movemapgen 0 (generate map 0)\n"
+        "movemapgen --tile 34,46 (builds only tile 34,46 of map 0)\n\n");
+    printf("Please read readme file for more information and exemples.\n");
+}
+
+bool handleArgs(int argc, char** argv,
+                int& mapnum,
+                int& tileX,
+                int& tileY,
+                float& maxAngle,
+                bool& skipLiquid,
+                bool& skipContinents,
+                bool& skipJunkMaps,
+                bool& skipBattlegrounds,
+                bool& debugOutput,
+                bool& silent,
+                bool& bigBaseUnit,
+                char*& offMeshInputPath)
+{
+    char* param = NULL;
+    for (int i = 1; i < argc; ++i)
+    {
+        if (strcmp(argv[i], "--maxAngle") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            float maxangle = atof(param);
+            if (maxangle <= 90.f && maxangle >= 45.f)
+                maxAngle = maxangle;
+            else
+                printf("invalid option for '--maxAngle', using default\n");
+        }
+        else if (strcmp(argv[i], "--tile") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            char* stileX = strtok(param, ",");
+            char* stileY = strtok(NULL, ",");
+            int tilex = atoi(stileX);
+            int tiley = atoi(stileY);
+
+            if ((tilex > 0 && tilex < 64) || (tilex == 0 && strcmp(stileX, "0") == 0))
+                tileX = tilex;
+            if ((tiley > 0 && tiley < 64) || (tiley == 0 && strcmp(stileY, "0") == 0))
+                tileY = tiley;
+
+            if (tileX < 0 || tileY < 0)
+            {
+                printf("invalid tile coords.\n");
+                return false;
+            }
+        }
+        else if (strcmp(argv[i], "--skipLiquid") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            if (strcmp(param, "true") == 0)
+                skipLiquid = true;
+            else if (strcmp(param, "false") == 0)
+                skipLiquid = false;
+            else
+                printf("invalid option for '--skipLiquid', using default\n");
+        }
+        else if (strcmp(argv[i], "--skipContinents") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            if (strcmp(param, "true") == 0)
+                skipContinents = true;
+            else if (strcmp(param, "false") == 0)
+                skipContinents = false;
+            else
+                printf("invalid option for '--skipContinents', using default\n");
+        }
+        else if (strcmp(argv[i], "--skipJunkMaps") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            if (strcmp(param, "true") == 0)
+                skipJunkMaps = true;
+            else if (strcmp(param, "false") == 0)
+                skipJunkMaps = false;
+            else
+                printf("invalid option for '--skipJunkMaps', using default\n");
+        }
+        else if (strcmp(argv[i], "--skipBattlegrounds") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            if (strcmp(param, "true") == 0)
+                skipBattlegrounds = true;
+            else if (strcmp(param, "false") == 0)
+                skipBattlegrounds = false;
+            else
+                printf("invalid option for '--skipBattlegrounds', using default\n");
+        }
+        else if (strcmp(argv[i], "--debugOutput") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            if (strcmp(param, "true") == 0)
+                debugOutput = true;
+            else if (strcmp(param, "false") == 0)
+                debugOutput = false;
+            else
+                printf("invalid option for '--debugOutput', using default true\n");
+        }
+        else if (strcmp(argv[i], "--silent") == 0)
+        {
+            silent = true;
+        }
+        else if (strcmp(argv[i], "--bigBaseUnit") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            if (strcmp(param, "true") == 0)
+                bigBaseUnit = true;
+            else if (strcmp(param, "false") == 0)
+                bigBaseUnit = false;
+            else
+                printf("invalid option for '--bigBaseUnit', using default false\n");
+        }
+        else if (strcmp(argv[i], "--offMeshInput") == 0)
+        {
+            param = argv[++i];
+            if (!param)
+                return false;
+
+            offMeshInputPath = param;
+        }
+        else if (strcmp(argv[i], "-?") == 0)
+        {
+            printUsage();
+            exit(1);
+        }
+        else
+        {
+            int map = atoi(argv[i]);
+            if (map > 0 || (map == 0 && (strcmp(argv[i], "0") == 0)))
+                mapnum = map;
+            else
+            {
+                printf("invalid map id\n");
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
+int finish(const char* message, int returnValue)
+{
+    printf("%s", message);
+    getchar();
+    return returnValue;
+}
+
+int main(int argc, char** argv)
+{
+    int mapnum = -1;
+    float maxAngle = 60.0f;
+    int tileX = -1, tileY = -1;
+    bool skipLiquid = false,
+         skipContinents = false,
+         skipJunkMaps = true,
+         skipBattlegrounds = false,
+         debugOutput = false,
+         silent = false,
+         bigBaseUnit = false;
+    char* offMeshInputPath = NULL;
+
+    bool validParam = handleArgs(argc, argv, mapnum,
+                                 tileX, tileY, maxAngle,
+                                 skipLiquid, skipContinents, skipJunkMaps, skipBattlegrounds,
+                                 debugOutput, silent, bigBaseUnit, offMeshInputPath);
+
+    if (!validParam)
+        return silent ? -1 : finish("You have specified invalid parameters (use -? for more help)", -1);
+
+    if (mapnum == -1 && debugOutput)
+    {
+        if (silent)
+            return -2;
+
+        printf("You have specifed debug output, but didn't specify a map to generate.\n");
+        printf("This will generate debug output for ALL maps.\n");
+        printf("Are you sure you want to continue? (y/n) ");
+        if (getchar() != 'y')
+            return 0;
+    }
+
+    if (!checkDirectories(debugOutput))
+        return silent ? -3 : finish("Press any key to close...", -3);
+
+    MapBuilder builder(maxAngle, skipLiquid, skipContinents, skipJunkMaps,
+                       skipBattlegrounds, debugOutput, bigBaseUnit, offMeshInputPath);
+
+    if (tileX > -1 && tileY > -1 && mapnum >= 0)
+        builder.buildSingleTile(mapnum, tileX, tileY);
+    else if (mapnum >= 0)
+        builder.buildMap(uint32(mapnum));
+    else
+        builder.buildAllMaps();
+
+    return silent ? 1 : finish("Movemap build is complete!", 1);
+}
diff -Nuar clean-build/maptools/mmap_generator/IntermediateValues.cpp temp-build/maptools/mmap_generator/IntermediateValues.cpp
--- clean-build/maptools/mmap_generator/IntermediateValues.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/IntermediateValues.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,259 @@
+#include "IntermediateValues.h"
+
+namespace MMAP
+{
+    IntermediateValues::~IntermediateValues()
+    {
+        rcFreeCompactHeightfield(compactHeightfield);
+        rcFreeHeightField(heightfield);
+        rcFreeContourSet(contours);
+        rcFreePolyMesh(polyMesh);
+        rcFreePolyMeshDetail(polyMeshDetail);
+    }
+
+    void IntermediateValues::writeIV(uint32 mapID, uint32 tileX, uint32 tileY)
+    {
+        char fileName[255];
+        char tileString[25];
+        sprintf(tileString, "[%02u,%02u]: ", tileX, tileY);
+
+        printf("%sWriting debug output...                       \r", tileString);
+
+        string name("meshes/%03u%02i%02i.");
+
+#define DEBUG_WRITE(fileExtension,data) \
+        do { \
+            sprintf(fileName, (name + fileExtension).c_str(), mapID, tileY, tileX); \
+            FILE* file = fopen(fileName, "wb"); \
+            if (!file) \
+            { \
+                char message[1024]; \
+                sprintf(message, "%sFailed to open %s for writing!\n",  tileString, fileName); \
+                perror(message); \
+            } \
+            else \
+                debugWrite(file, data); \
+            if(file) fclose(file); \
+            printf("%sWriting debug output...                       \r", tileString); \
+        } while (false)
+
+        if (heightfield)
+            DEBUG_WRITE("hf", heightfield);
+        if (compactHeightfield)
+            DEBUG_WRITE("chf", compactHeightfield);
+        if (contours)
+            DEBUG_WRITE("cs", contours);
+        if (polyMesh)
+            DEBUG_WRITE("pmesh", polyMesh);
+        if (polyMeshDetail)
+            DEBUG_WRITE("dmesh", polyMeshDetail);
+
+#undef DEBUG_WRITE
+    }
+
+    void IntermediateValues::debugWrite(FILE* file, const rcHeightfield* mesh)
+    {
+        if (!file || !mesh)
+            return;
+
+        fwrite(&(mesh->cs), sizeof(float), 1, file);
+        fwrite(&(mesh->ch), sizeof(float), 1, file);
+        fwrite(&(mesh->width), sizeof(int), 1, file);
+        fwrite(&(mesh->height), sizeof(int), 1, file);
+        fwrite(mesh->bmin, sizeof(float), 3, file);
+        fwrite(mesh->bmax, sizeof(float), 3, file);
+
+        for (int y = 0; y < mesh->height; ++y)
+            for (int x = 0; x < mesh->width; ++x)
+            {
+                rcSpan* span = mesh->spans[x + y * mesh->width];
+
+                // first, count the number of spans
+                int spanCount = 0;
+                while (span)
+                {
+                    spanCount++;
+                    span = span->next;
+                }
+
+                // write the span count
+                fwrite(&spanCount, sizeof(int), 1, file);
+
+                // write the spans
+                span = mesh->spans[x + y * mesh->width];
+                while (span)
+                {
+                    fwrite(span, sizeof(rcSpan), 1, file);
+                    span = span->next;
+                }
+            }
+    }
+
+    void IntermediateValues::debugWrite(FILE* file, const rcCompactHeightfield* chf)
+    {
+        if (!file | !chf)
+            return;
+
+        fwrite(&(chf->width), sizeof(chf->width), 1, file);
+        fwrite(&(chf->height), sizeof(chf->height), 1, file);
+        fwrite(&(chf->spanCount), sizeof(chf->spanCount), 1, file);
+
+        fwrite(&(chf->walkableHeight), sizeof(chf->walkableHeight), 1, file);
+        fwrite(&(chf->walkableClimb), sizeof(chf->walkableClimb), 1, file);
+
+        fwrite(&(chf->maxDistance), sizeof(chf->maxDistance), 1, file);
+        fwrite(&(chf->maxRegions), sizeof(chf->maxRegions), 1, file);
+
+        fwrite(chf->bmin, sizeof(chf->bmin), 1, file);
+        fwrite(chf->bmax, sizeof(chf->bmax), 1, file);
+
+        fwrite(&(chf->cs), sizeof(chf->cs), 1, file);
+        fwrite(&(chf->ch), sizeof(chf->ch), 1, file);
+
+        int tmp = 0;
+        if (chf->cells) tmp |= 1;
+        if (chf->spans) tmp |= 2;
+        if (chf->dist) tmp |= 4;
+        if (chf->areas) tmp |= 8;
+
+        fwrite(&tmp, sizeof(tmp), 1, file);
+
+        if (chf->cells)
+            fwrite(chf->cells, sizeof(rcCompactCell), chf->width * chf->height, file);
+        if (chf->spans)
+            fwrite(chf->spans, sizeof(rcCompactSpan), chf->spanCount, file);
+        if (chf->dist)
+            fwrite(chf->dist, sizeof(unsigned short), chf->spanCount, file);
+        if (chf->areas)
+            fwrite(chf->areas, sizeof(unsigned char), chf->spanCount, file);
+    }
+
+    void IntermediateValues::debugWrite(FILE* file, const rcContourSet* cs)
+    {
+        if (!file || !cs)
+            return;
+
+        fwrite(&(cs->cs), sizeof(float), 1, file);
+        fwrite(&(cs->ch), sizeof(float), 1, file);
+        fwrite(cs->bmin, sizeof(float), 3, file);
+        fwrite(cs->bmax, sizeof(float), 3, file);
+        fwrite(&(cs->nconts), sizeof(int), 1, file);
+        for (int i = 0; i < cs->nconts; ++i)
+        {
+            fwrite(&cs->conts[i].area, sizeof(unsigned char), 1, file);
+            fwrite(&cs->conts[i].reg, sizeof(unsigned short), 1, file);
+            fwrite(&cs->conts[i].nverts, sizeof(int), 1, file);
+            fwrite(cs->conts[i].verts, sizeof(int), cs->conts[i].nverts * 4, file);
+            fwrite(&cs->conts[i].nrverts, sizeof(int), 1, file);
+            fwrite(cs->conts[i].rverts, sizeof(int), cs->conts[i].nrverts * 4, file);
+        }
+    }
+
+    void IntermediateValues::debugWrite(FILE* file, const rcPolyMesh* mesh)
+    {
+        if (!file || !mesh)
+            return;
+
+        fwrite(&(mesh->cs), sizeof(float), 1, file);
+        fwrite(&(mesh->ch), sizeof(float), 1, file);
+        fwrite(&(mesh->nvp), sizeof(int), 1, file);
+        fwrite(mesh->bmin, sizeof(float), 3, file);
+        fwrite(mesh->bmax, sizeof(float), 3, file);
+        fwrite(&(mesh->nverts), sizeof(int), 1, file);
+        fwrite(mesh->verts, sizeof(unsigned short), mesh->nverts * 3, file);
+        fwrite(&(mesh->npolys), sizeof(int), 1, file);
+        fwrite(mesh->polys, sizeof(unsigned short), mesh->npolys * mesh->nvp * 2, file);
+        fwrite(mesh->flags, sizeof(unsigned short), mesh->npolys, file);
+        fwrite(mesh->areas, sizeof(unsigned char), mesh->npolys, file);
+        fwrite(mesh->regs, sizeof(unsigned short), mesh->npolys, file);
+    }
+
+    void IntermediateValues::debugWrite(FILE* file, const rcPolyMeshDetail* mesh)
+    {
+        if (!file || !mesh)
+            return;
+
+        fwrite(&(mesh->nverts), sizeof(int), 1, file);
+        fwrite(mesh->verts, sizeof(float), mesh->nverts * 3, file);
+        fwrite(&(mesh->ntris), sizeof(int), 1, file);
+        fwrite(mesh->tris, sizeof(char), mesh->ntris * 4, file);
+        fwrite(&(mesh->nmeshes), sizeof(int), 1, file);
+        fwrite(mesh->meshes, sizeof(int), mesh->nmeshes * 4, file);
+    }
+
+    void IntermediateValues::generateObjFile(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData)
+    {
+        char objFileName[255];
+        sprintf(objFileName, "meshes/map%03u%02u%02u.obj", mapID, tileY, tileX);
+
+        FILE* objFile = fopen(objFileName, "wb");
+        if (!objFile)
+        {
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", objFileName);
+            perror(message);
+            return;
+        }
+
+        G3D::Array<float> allVerts;
+        G3D::Array<int> allTris;
+
+        allTris.append(meshData.liquidTris);
+        allVerts.append(meshData.liquidVerts);
+        TerrainBuilder::copyIndices(meshData.solidTris, allTris, allVerts.size() / 3);
+        allVerts.append(meshData.solidVerts);
+
+        float* verts = allVerts.getCArray();
+        int vertCount = allVerts.size() / 3;
+        int* tris = allTris.getCArray();
+        int triCount = allTris.size() / 3;
+
+        for (int i = 0; i < allVerts.size() / 3; i++)
+            fprintf(objFile, "v %f %f %f\n", verts[i * 3], verts[i * 3 + 1], verts[i * 3 + 2]);
+
+        for (int i = 0; i < allTris.size() / 3; i++)
+            fprintf(objFile, "f %i %i %i\n", tris[i * 3] + 1, tris[i * 3 + 1] + 1, tris[i * 3 + 2] + 1);
+
+        fclose(objFile);
+
+
+        char tileString[25];
+        sprintf(tileString, "[%02u,%02u]: ", tileY, tileX);
+        printf("%sWriting debug output...                       \r", tileString);
+
+        sprintf(objFileName, "meshes/%03u.map", mapID);
+
+        objFile = fopen(objFileName, "wb");
+        if (!objFile)
+        {
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", objFileName);
+            perror(message);
+            return;
+        }
+
+        char b = '\0';
+        fwrite(&b, sizeof(char), 1, objFile);
+        fclose(objFile);
+
+        sprintf(objFileName, "meshes/%03u%02u%02u.mesh", mapID, tileY, tileX);
+        objFile = fopen(objFileName, "wb");
+        if (!objFile)
+        {
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", objFileName);
+            perror(message);
+            return;
+        }
+
+        fwrite(&vertCount, sizeof(int), 1, objFile);
+        fwrite(verts, sizeof(float), vertCount * 3, objFile);
+        fflush(objFile);
+
+        fwrite(&triCount, sizeof(int), 1, objFile);
+        fwrite(tris, sizeof(int), triCount * 3, objFile);
+        fflush(objFile);
+
+        fclose(objFile);
+    }
+}
diff -Nuar clean-build/maptools/mmap_generator/IntermediateValues.h temp-build/maptools/mmap_generator/IntermediateValues.h
--- clean-build/maptools/mmap_generator/IntermediateValues.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/IntermediateValues.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,36 @@
+#ifndef _INTERMEDIATE_VALUES_H
+#define _INTERMEDIATE_VALUES_H
+
+#include "MMapCommon.h"
+#include "TerrainBuilder.h"
+
+#include "Recast.h"
+#include "DetourNavMesh.h"
+
+namespace MMAP
+{
+    // this class gathers all debug info holding and output
+    struct IntermediateValues
+    {
+        rcHeightfield* heightfield;
+        rcCompactHeightfield* compactHeightfield;
+        rcContourSet* contours;
+        rcPolyMesh* polyMesh;
+        rcPolyMeshDetail* polyMeshDetail;
+
+        IntermediateValues() :  compactHeightfield(NULL), heightfield(NULL),
+            contours(NULL), polyMesh(NULL), polyMeshDetail(NULL) {}
+        ~IntermediateValues();
+
+        void writeIV(uint32 mapID, uint32 tileX, uint32 tileY);
+
+        void debugWrite(FILE* file, const rcHeightfield* mesh);
+        void debugWrite(FILE* file, const rcCompactHeightfield* chf);
+        void debugWrite(FILE* file, const rcContourSet* cs);
+        void debugWrite(FILE* file, const rcPolyMesh* mesh);
+        void debugWrite(FILE* file, const rcPolyMeshDetail* mesh);
+
+        void generateObjFile(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData);
+    };
+}
+#endif
diff -Nuar clean-build/maptools/mmap_generator/MapBuilder.cpp temp-build/maptools/mmap_generator/MapBuilder.cpp
--- clean-build/maptools/mmap_generator/MapBuilder.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/MapBuilder.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,863 @@
+#include "MMapCommon.h"
+#include "MapBuilder.h"
+
+#include "MapTree.h"
+#include "ModelInstance.h"
+
+#include "DetourNavMeshBuilder.h"
+#include "DetourCommon.h"
+
+using namespace VMAP;
+
+namespace MMAP
+{
+    MapBuilder::MapBuilder(float maxWalkableAngle, bool skipLiquid,
+                           bool skipContinents, bool skipJunkMaps, bool skipBattlegrounds,
+                           bool debugOutput, bool bigBaseUnit, const char* offMeshFilePath) :
+        m_terrainBuilder(NULL),
+        m_debugOutput(debugOutput),
+        m_skipContinents(skipContinents),
+        m_skipJunkMaps(skipJunkMaps),
+        m_skipBattlegrounds(skipBattlegrounds),
+        m_maxWalkableAngle(maxWalkableAngle),
+        m_bigBaseUnit(bigBaseUnit),
+        m_rcContext(NULL),
+        m_offMeshFilePath(offMeshFilePath)
+    {
+        m_terrainBuilder = new TerrainBuilder(skipLiquid);
+
+        m_rcContext = new rcContext(false);
+
+        discoverTiles();
+    }
+
+    /**************************************************************************/
+    MapBuilder::~MapBuilder()
+    {
+        for (TileList::iterator it = m_tiles.begin(); it != m_tiles.end(); ++it)
+        {
+            (*it).second->clear();
+            delete(*it).second;
+        }
+
+        delete m_terrainBuilder;
+        delete m_rcContext;
+    }
+
+    /**************************************************************************/
+    void MapBuilder::discoverTiles()
+    {
+        vector<string> files;
+        uint32 mapID, tileX, tileY, tileID, count = 0;
+        char filter[12];
+
+        printf("Discovering maps... ");
+        getDirContents(files, "maps");
+        for (uint32 i = 0; i < files.size(); ++i)
+        {
+            mapID = uint32(atoi(files[i].substr(0, 3).c_str()));
+            if (m_tiles.find(mapID) == m_tiles.end())
+            {
+                m_tiles.insert(pair<uint32, set<uint32>*>(mapID, new set<uint32>));
+                count++;
+            }
+        }
+
+        files.clear();
+        getDirContents(files, "vmaps", "*.vmtree");
+        for (uint32 i = 0; i < files.size(); ++i)
+        {
+            mapID = uint32(atoi(files[i].substr(0, 3).c_str()));
+            m_tiles.insert(pair<uint32, set<uint32>*>(mapID, new set<uint32>));
+            count++;
+        }
+        printf("found %u.\n", count);
+
+        count = 0;
+        printf("Discovering tiles... ");
+        for (TileList::iterator itr = m_tiles.begin(); itr != m_tiles.end(); ++itr)
+        {
+            set<uint32>* tiles = (*itr).second;
+            mapID = (*itr).first;
+
+            sprintf(filter, "%03u*.vmtile", mapID);
+            files.clear();
+            getDirContents(files, "vmaps", filter);
+            for (uint32 i = 0; i < files.size(); ++i)
+            {
+                tileX = uint32(atoi(files[i].substr(7, 2).c_str()));
+                tileY = uint32(atoi(files[i].substr(4, 2).c_str()));
+                tileID = StaticMapTree::packTileID(tileY, tileX);
+
+                tiles->insert(tileID);
+                count++;
+            }
+
+            sprintf(filter, "%03u*", mapID);
+            files.clear();
+            getDirContents(files, "maps", filter);
+            for (uint32 i = 0; i < files.size(); ++i)
+            {
+                tileY = uint32(atoi(files[i].substr(3, 2).c_str()));
+                tileX = uint32(atoi(files[i].substr(5, 2).c_str()));
+                tileID = StaticMapTree::packTileID(tileX, tileY);
+
+                if (tiles->insert(tileID).second)
+                    count++;
+            }
+        }
+        printf("found %u.\n\n", count);
+    }
+
+    /**************************************************************************/
+    set<uint32>* MapBuilder::getTileList(uint32 mapID)
+    {
+        TileList::iterator itr = m_tiles.find(mapID);
+        if (itr != m_tiles.end())
+            return (*itr).second;
+
+        set<uint32>* tiles = new set<uint32>();
+        m_tiles.insert(pair<uint32, set<uint32>*>(mapID, tiles));
+        return tiles;
+    }
+
+    /**************************************************************************/
+    void MapBuilder::buildAllMaps()
+    {
+        for (TileList::iterator it = m_tiles.begin(); it != m_tiles.end(); ++it)
+        {
+            uint32 mapID = (*it).first;
+            if (!shouldSkipMap(mapID))
+                buildMap(mapID);
+        }
+    }
+
+    /**************************************************************************/
+    void MapBuilder::getGridBounds(uint32 mapID, uint32& minX, uint32& minY, uint32& maxX, uint32& maxY)
+    {
+        maxX = INT_MAX;
+        maxY = INT_MAX;
+        minX = INT_MIN;
+        minY = INT_MIN;
+
+        float bmin[3], bmax[3], lmin[3], lmax[3];
+        MeshData meshData;
+
+        // make sure we process maps which don't have tiles
+        // initialize the static tree, which loads WDT models
+        if (!m_terrainBuilder->loadVMap(mapID, 64, 64, meshData))
+            return;
+
+        // get the coord bounds of the model data
+        if (meshData.solidVerts.size() + meshData.liquidVerts.size() == 0)
+            return;
+
+        // get the coord bounds of the model data
+        if (meshData.solidVerts.size() && meshData.liquidVerts.size())
+        {
+            rcCalcBounds(meshData.solidVerts.getCArray(), meshData.solidVerts.size() / 3, bmin, bmax);
+            rcCalcBounds(meshData.liquidVerts.getCArray(), meshData.liquidVerts.size() / 3, lmin, lmax);
+            rcVmin(bmin, lmin);
+            rcVmax(bmax, lmax);
+        }
+        else if (meshData.solidVerts.size())
+            rcCalcBounds(meshData.solidVerts.getCArray(), meshData.solidVerts.size() / 3, bmin, bmax);
+        else
+            rcCalcBounds(meshData.liquidVerts.getCArray(), meshData.liquidVerts.size() / 3, lmin, lmax);
+
+        // convert coord bounds to grid bounds
+        maxX = 32 - bmin[0] / GRID_SIZE;
+        maxY = 32 - bmin[2] / GRID_SIZE;
+        minX = 32 - bmax[0] / GRID_SIZE;
+        minY = 32 - bmax[2] / GRID_SIZE;
+    }
+
+    /**************************************************************************/
+    void MapBuilder::buildSingleTile(uint32 mapID, uint32 tileX, uint32 tileY)
+    {
+        dtNavMesh* navMesh = NULL;
+        buildNavMesh(mapID, navMesh);
+        if (!navMesh)
+        {
+            printf("Failed creating navmesh!              \n");
+            return;
+        }
+
+        buildTile(mapID, tileX, tileY, navMesh);
+        dtFreeNavMesh(navMesh);
+    }
+
+    /**************************************************************************/
+    void MapBuilder::buildMap(uint32 mapID)
+    {
+        printf("Building map %03u:\n", mapID);
+
+        set<uint32>* tiles = getTileList(mapID);
+
+        // make sure we process maps which don't have tiles
+        if (!tiles->size())
+        {
+            // convert coord bounds to grid bounds
+            uint32 minX, minY, maxX, maxY;
+            getGridBounds(mapID, minX, minY, maxX, maxY);
+
+            // add all tiles within bounds to tile list.
+            for (uint32 i = minX; i <= maxX; ++i)
+                for (uint32 j = minY; j <= maxY; ++j)
+                    tiles->insert(StaticMapTree::packTileID(i, j));
+        }
+
+        if (!tiles->size())
+            return;
+
+        // build navMesh
+        dtNavMesh* navMesh = NULL;
+        buildNavMesh(mapID, navMesh);
+        if (!navMesh)
+        {
+            printf("Failed creating navmesh!              \n");
+            return;
+        }
+
+        // now start building mmtiles for each tile
+        printf("We have %u tiles.                          \n", (unsigned int)tiles->size());
+        for (set<uint32>::iterator it = tiles->begin(); it != tiles->end(); ++it)
+        {
+            uint32 tileX, tileY;
+
+            // unpack tile coords
+            StaticMapTree::unpackTileID((*it), tileX, tileY);
+
+            if (shouldSkipTile(mapID, tileX, tileY))
+                continue;
+
+            buildTile(mapID, tileX, tileY, navMesh);
+        }
+
+        dtFreeNavMesh(navMesh);
+
+        printf("Complete!                               \n\n");
+    }
+
+    /**************************************************************************/
+    void MapBuilder::buildTile(uint32 mapID, uint32 tileX, uint32 tileY, dtNavMesh* navMesh)
+    {
+        printf("Building map %03u, tile [%02u,%02u]\n", mapID, tileX, tileY);
+
+        MeshData meshData;
+
+        // get heightmap data
+        m_terrainBuilder->loadMap(mapID, tileX, tileY, meshData);
+
+        // get model data
+        m_terrainBuilder->loadVMap(mapID, tileY, tileX, meshData);
+
+        // if there is no data, give up now
+        if (!meshData.solidVerts.size() && !meshData.liquidVerts.size())
+            return;
+
+        // remove unused vertices
+        TerrainBuilder::cleanVertices(meshData.solidVerts, meshData.solidTris);
+        TerrainBuilder::cleanVertices(meshData.liquidVerts, meshData.liquidTris);
+
+        // gather all mesh data for final data check, and bounds calculation
+        G3D::Array<float> allVerts;
+        allVerts.append(meshData.liquidVerts);
+        allVerts.append(meshData.solidVerts);
+
+        if (!allVerts.size())
+            return;
+
+        // get bounds of current tile
+        float bmin[3], bmax[3];
+        getTileBounds(tileX, tileY, allVerts.getCArray(), allVerts.size() / 3, bmin, bmax);
+
+        m_terrainBuilder->loadOffMeshConnections(mapID, tileX, tileY, meshData, m_offMeshFilePath);
+
+        // build navmesh tile
+        buildMoveMapTile(mapID, tileX, tileY, meshData, bmin, bmax, navMesh);
+    }
+
+    /**************************************************************************/
+    void MapBuilder::buildNavMesh(uint32 mapID, dtNavMesh*& navMesh)
+    {
+        set<uint32>* tiles = getTileList(mapID);
+
+        // old code for non-statically assigned bitmask sizes:
+        ///*** calculate number of bits needed to store tiles & polys ***/
+        //int tileBits = dtIlog2(dtNextPow2(tiles->size()));
+        //if (tileBits < 1) tileBits = 1;                                     // need at least one bit!
+        //int polyBits = sizeof(dtPolyRef)*8 - SALT_MIN_BITS - tileBits;
+
+        int tileBits = STATIC_TILE_BITS;
+        int polyBits = STATIC_POLY_BITS;
+
+        int maxTiles = tiles->size();
+        int maxPolysPerTile = 1 << polyBits;
+
+        /***          calculate bounds of map         ***/
+
+        uint32 tileXMin = 64, tileYMin = 64, tileXMax = 0, tileYMax = 0, tileX, tileY;
+        for (set<uint32>::iterator it = tiles->begin(); it != tiles->end(); ++it)
+        {
+            StaticMapTree::unpackTileID((*it), tileX, tileY);
+
+            if (tileX > tileXMax)
+                tileXMax = tileX;
+            else if (tileX < tileXMin)
+                tileXMin = tileX;
+
+            if (tileY > tileYMax)
+                tileYMax = tileY;
+            else if (tileY < tileYMin)
+                tileYMin = tileY;
+        }
+
+        // use Max because '32 - tileX' is negative for values over 32
+        float bmin[3], bmax[3];
+        getTileBounds(tileXMax, tileYMax, NULL, 0, bmin, bmax);
+
+        /***       now create the navmesh       ***/
+
+        // navmesh creation params
+        dtNavMeshParams navMeshParams;
+        memset(&navMeshParams, 0, sizeof(dtNavMeshParams));
+        navMeshParams.tileWidth = GRID_SIZE;
+        navMeshParams.tileHeight = GRID_SIZE;
+        rcVcopy(navMeshParams.orig, bmin);
+        navMeshParams.maxTiles = maxTiles;
+        navMeshParams.maxPolys = maxPolysPerTile;
+
+        navMesh = dtAllocNavMesh();
+        printf("Creating navMesh...                     \r");
+        if (!navMesh->init(&navMeshParams))
+        {
+            printf("Failed creating navmesh!                \n");
+            return;
+        }
+
+        char fileName[25];
+        sprintf(fileName, "mmaps/%03u.mmap", mapID);
+
+        FILE* file = fopen(fileName, "wb");
+        if (!file)
+        {
+            dtFreeNavMesh(navMesh);
+            char message[1024];
+            sprintf(message, "Failed to open %s for writing!\n", fileName);
+            perror(message);
+            return;
+        }
+
+        // now that we know navMesh params are valid, we can write them to file
+        fwrite(&navMeshParams, sizeof(dtNavMeshParams), 1, file);
+        fclose(file);
+    }
+
+    /**************************************************************************/
+    void MapBuilder::buildMoveMapTile(uint32 mapID, uint32 tileX, uint32 tileY,
+                                      MeshData& meshData, float bmin[3], float bmax[3],
+                                      dtNavMesh* navMesh)
+    {
+        // console output
+        char tileString[10];
+        sprintf(tileString, "[%02i,%02i]: ", tileX, tileY);
+        printf("%s Building movemap tiles...                        \r", tileString);
+
+        IntermediateValues iv;
+
+        float* tVerts = meshData.solidVerts.getCArray();
+        int tVertCount = meshData.solidVerts.size() / 3;
+        int* tTris = meshData.solidTris.getCArray();
+        int tTriCount = meshData.solidTris.size() / 3;
+
+        float* lVerts = meshData.liquidVerts.getCArray();
+        int lVertCount = meshData.liquidVerts.size() / 3;
+        int* lTris = meshData.liquidTris.getCArray();
+        int lTriCount = meshData.liquidTris.size() / 3;
+        uint8* lTriFlags = meshData.liquidType.getCArray();
+
+        // these are WORLD UNIT based metrics
+        // this are basic unit dimentions
+        // value have to divide GRID_SIZE(533.33333f) ( aka: 0.5333, 0.2666, 0.3333, 0.1333, etc )
+        const static float BASE_UNIT_DIM = m_bigBaseUnit ? 0.533333f : 0.266666f;
+
+        // All are in UNIT metrics!
+        const static int VERTEX_PER_MAP = int(GRID_SIZE / BASE_UNIT_DIM + 0.5f);
+        const static int VERTEX_PER_TILE = m_bigBaseUnit ? 40 : 80; // must divide VERTEX_PER_MAP
+        const static int TILES_PER_MAP = VERTEX_PER_MAP / VERTEX_PER_TILE;
+
+        rcConfig config;
+        memset(&config, 0, sizeof(rcConfig));
+
+        rcVcopy(config.bmin, bmin);
+        rcVcopy(config.bmax, bmax);
+
+        config.maxVertsPerPoly = DT_VERTS_PER_POLYGON;
+        config.cs = BASE_UNIT_DIM;
+        config.ch = BASE_UNIT_DIM;
+        config.walkableSlopeAngle = m_maxWalkableAngle;
+        config.tileSize = VERTEX_PER_TILE;
+        config.walkableRadius = m_bigBaseUnit ? 1 : 2;
+        config.borderSize = config.walkableRadius + 3;
+        config.maxEdgeLen = VERTEX_PER_TILE + 1;        //anything bigger than tileSize
+        config.walkableHeight = m_bigBaseUnit ? 3 : 6;
+        config.walkableClimb = m_bigBaseUnit ? 2 : 4;   // keep less than walkableHeight
+        config.minRegionArea = rcSqr(60);
+        config.mergeRegionArea = rcSqr(50);
+        config.maxSimplificationError = 2.0f;       // eliminates most jagged edges (tinny polygons)
+        config.detailSampleDist = config.cs * 64;
+        config.detailSampleMaxError = config.ch * 2;
+
+        // this sets the dimensions of the heightfield - should maybe happen before border padding
+        rcCalcGridSize(config.bmin, config.bmax, config.cs, &config.width, &config.height);
+
+        // allocate subregions : tiles
+        Tile* tiles = new Tile[TILES_PER_MAP * TILES_PER_MAP];
+
+        // Initialize per tile config.
+        rcConfig tileCfg;
+        memcpy(&tileCfg, &config, sizeof(rcConfig));
+        tileCfg.width = config.tileSize + config.borderSize * 2;
+        tileCfg.height = config.tileSize + config.borderSize * 2;
+
+        // build all tiles
+        for (int y = 0; y < TILES_PER_MAP; ++y)
+        {
+            for (int x = 0; x < TILES_PER_MAP; ++x)
+            {
+                Tile& tile = tiles[x + y * TILES_PER_MAP];
+
+                // Calculate the per tile bounding box.
+                tileCfg.bmin[0] = config.bmin[0] + (x * config.tileSize - config.borderSize) * config.cs;
+                tileCfg.bmin[2] = config.bmin[2] + (y * config.tileSize - config.borderSize) * config.cs;
+                tileCfg.bmax[0] = config.bmin[0] + ((x + 1) * config.tileSize + config.borderSize) * config.cs;
+                tileCfg.bmax[2] = config.bmin[2] + ((y + 1) * config.tileSize + config.borderSize) * config.cs;
+
+                float tbmin[2], tbmax[2];
+                tbmin[0] = tileCfg.bmin[0];
+                tbmin[1] = tileCfg.bmin[2];
+                tbmax[0] = tileCfg.bmax[0];
+                tbmax[1] = tileCfg.bmax[2];
+
+                // build heightfield
+                tile.solid = rcAllocHeightfield();
+                if (!tile.solid || !rcCreateHeightfield(m_rcContext, *tile.solid, tileCfg.width, tileCfg.height, tileCfg.bmin, tileCfg.bmax, tileCfg.cs, tileCfg.ch))
+                {
+                    printf("%sFailed building heightfield!            \n", tileString);
+                    continue;
+                }
+
+                // mark all walkable tiles, both liquids and solids
+                unsigned char* triFlags = new unsigned char[tTriCount];
+                memset(triFlags, NAV_GROUND, tTriCount * sizeof(unsigned char));
+                rcClearUnwalkableTriangles(m_rcContext, tileCfg.walkableSlopeAngle, tVerts, tVertCount, tTris, tTriCount, triFlags);
+                rcRasterizeTriangles(m_rcContext, tVerts, tVertCount, tTris, triFlags, tTriCount, *tile.solid, config.walkableClimb);
+                delete [] triFlags;
+
+                rcFilterLowHangingWalkableObstacles(m_rcContext, config.walkableClimb, *tile.solid);
+                rcFilterLedgeSpans(m_rcContext, tileCfg.walkableHeight, tileCfg.walkableClimb, *tile.solid);
+                rcFilterWalkableLowHeightSpans(m_rcContext, tileCfg.walkableHeight, *tile.solid);
+
+                rcRasterizeTriangles(m_rcContext, lVerts, lVertCount, lTris, lTriFlags, lTriCount, *tile.solid, config.walkableClimb);
+
+                // compact heightfield spans
+                tile.chf = rcAllocCompactHeightfield();
+                if (!tile.chf || !rcBuildCompactHeightfield(m_rcContext, tileCfg.walkableHeight, tileCfg.walkableClimb, *tile.solid, *tile.chf))
+                {
+                    printf("%sFailed compacting heightfield!            \n", tileString);
+                    continue;
+                }
+
+                // build polymesh intermediates
+                if (!rcErodeWalkableArea(m_rcContext, config.walkableRadius, *tile.chf))
+                {
+                    printf("%sFailed eroding area!                    \n", tileString);
+                    continue;
+                }
+
+                if (!rcBuildDistanceField(m_rcContext, *tile.chf))
+                {
+                    printf("%sFailed building distance field!         \n", tileString);
+                    continue;
+                }
+
+                if (!rcBuildRegions(m_rcContext, *tile.chf, tileCfg.borderSize, tileCfg.minRegionArea, tileCfg.mergeRegionArea))
+                {
+                    printf("%sFailed building regions!                \n", tileString);
+                    continue;
+                }
+
+                tile.cset = rcAllocContourSet();
+                if (!tile.cset || !rcBuildContours(m_rcContext, *tile.chf, tileCfg.maxSimplificationError, tileCfg.maxEdgeLen, *tile.cset))
+                {
+                    printf("%sFailed building contours!               \n", tileString);
+                    continue;
+                }
+
+                // build polymesh
+                tile.pmesh = rcAllocPolyMesh();
+                if (!tile.pmesh || !rcBuildPolyMesh(m_rcContext, *tile.cset, tileCfg.maxVertsPerPoly, *tile.pmesh))
+                {
+                    printf("%sFailed building polymesh!               \n", tileString);
+                    continue;
+                }
+
+                tile.dmesh = rcAllocPolyMeshDetail();
+                if (!tile.dmesh || !rcBuildPolyMeshDetail(m_rcContext, *tile.pmesh, *tile.chf, tileCfg.detailSampleDist, tileCfg    .detailSampleMaxError, *tile.dmesh))
+                {
+                    printf("%sFailed building polymesh detail!        \n", tileString);
+                    continue;
+                }
+
+                // free those up
+                // we may want to keep them in the future for debug
+                // but right now, we don't have the code to merge them
+                rcFreeHeightField(tile.solid);
+                tile.solid = NULL;
+                rcFreeCompactHeightfield(tile.chf);
+                tile.chf = NULL;
+                rcFreeContourSet(tile.cset);
+                tile.cset = NULL;
+            }
+        }
+
+        // merge per tile poly and detail meshes
+        rcPolyMesh** pmmerge = new rcPolyMesh*[TILES_PER_MAP * TILES_PER_MAP];
+        if (!pmmerge)
+        {
+            printf("%s alloc pmmerge FIALED!          \r", tileString);
+            return;
+        }
+
+        rcPolyMeshDetail** dmmerge = new rcPolyMeshDetail*[TILES_PER_MAP * TILES_PER_MAP];
+        if (!dmmerge)
+        {
+            printf("%s alloc dmmerge FIALED!          \r", tileString);
+            return;
+        }
+
+        int nmerge = 0;
+        for (int y = 0; y < TILES_PER_MAP; ++y)
+        {
+            for (int x = 0; x < TILES_PER_MAP; ++x)
+            {
+                Tile& tile = tiles[x + y * TILES_PER_MAP];
+                if (tile.pmesh)
+                {
+                    pmmerge[nmerge] = tile.pmesh;
+                    dmmerge[nmerge] = tile.dmesh;
+                    nmerge++;
+                }
+            }
+        }
+
+        iv.polyMesh = rcAllocPolyMesh();
+        if (!iv.polyMesh)
+        {
+            printf("%s alloc iv.polyMesh FIALED!          \r", tileString);
+            return;
+        }
+        rcMergePolyMeshes(m_rcContext, pmmerge, nmerge, *iv.polyMesh);
+
+        iv.polyMeshDetail = rcAllocPolyMeshDetail();
+        if (!iv.polyMeshDetail)
+        {
+            printf("%s alloc m_dmesh FIALED!          \r", tileString);
+            return;
+        }
+        rcMergePolyMeshDetails(m_rcContext, dmmerge, nmerge, *iv.polyMeshDetail);
+
+        // free things up
+        delete [] pmmerge;
+        delete [] dmmerge;
+
+        delete [] tiles;
+
+        // remove padding for extraction
+        for (int i = 0; i < iv.polyMesh->nverts; ++i)
+        {
+            unsigned short* v = &iv.polyMesh->verts[i * 3];
+            v[0] -= (unsigned short)config.borderSize;
+            v[2] -= (unsigned short)config.borderSize;
+        }
+
+        // set polygons as walkable
+        // TODO: special flags for DYNAMIC polygons, ie surfaces that can be turned on and off
+        for (int i = 0; i < iv.polyMesh->npolys; ++i)
+            if (iv.polyMesh->areas[i] & RC_WALKABLE_AREA)
+                iv.polyMesh->flags[i] = iv.polyMesh->areas[i];
+
+        // setup mesh parameters
+        dtNavMeshCreateParams params;
+        memset(&params, 0, sizeof(params));
+        params.verts = iv.polyMesh->verts;
+        params.vertCount = iv.polyMesh->nverts;
+        params.polys = iv.polyMesh->polys;
+        params.polyAreas = iv.polyMesh->areas;
+        params.polyFlags = iv.polyMesh->flags;
+        params.polyCount = iv.polyMesh->npolys;
+        params.nvp = iv.polyMesh->nvp;
+        params.detailMeshes = iv.polyMeshDetail->meshes;
+        params.detailVerts = iv.polyMeshDetail->verts;
+        params.detailVertsCount = iv.polyMeshDetail->nverts;
+        params.detailTris = iv.polyMeshDetail->tris;
+        params.detailTriCount = iv.polyMeshDetail->ntris;
+
+        params.offMeshConVerts = meshData.offMeshConnections.getCArray();
+        params.offMeshConCount = meshData.offMeshConnections.size() / 6;
+        params.offMeshConRad = meshData.offMeshConnectionRads.getCArray();
+        params.offMeshConDir = meshData.offMeshConnectionDirs.getCArray();
+        params.offMeshConAreas = meshData.offMeshConnectionsAreas.getCArray();
+        params.offMeshConFlags = meshData.offMeshConnectionsFlags.getCArray();
+
+        params.walkableHeight = BASE_UNIT_DIM * config.walkableHeight;  // agent height
+        params.walkableRadius = BASE_UNIT_DIM * config.walkableRadius;  // agent radius
+        params.walkableClimb = BASE_UNIT_DIM * config.walkableClimb;    // keep less that walkableHeight (aka agent height)!
+        params.tileX = (((bmin[0] + bmax[0]) / 2) - navMesh->getParams()->orig[0]) / GRID_SIZE;
+        params.tileY = (((bmin[2] + bmax[2]) / 2) - navMesh->getParams()->orig[2]) / GRID_SIZE;
+        rcVcopy(params.bmin, bmin);
+        rcVcopy(params.bmax, bmax);
+        params.cs = config.cs;
+        params.ch = config.ch;
+        params.tileSize = VERTEX_PER_MAP;
+
+        // will hold final navmesh
+        unsigned char* navData = NULL;
+        int navDataSize = 0;
+
+        do
+        {
+            // these values are checked within dtCreateNavMeshData - handle them here
+            // so we have a clear error message
+            if (params.nvp > DT_VERTS_PER_POLYGON)
+            {
+                printf("%s Invalid verts-per-polygon value!        \n", tileString);
+                continue;
+            }
+            if (params.vertCount >= 0xffff)
+            {
+                printf("%s Too many vertices!                      \n", tileString);
+                continue;
+            }
+            if (!params.vertCount || !params.verts)
+            {
+                // occurs mostly when adjacent tiles have models
+                // loaded but those models don't span into this tile
+
+                // message is an annoyance
+                //printf("%sNo vertices to build tile!              \n", tileString);
+                continue;
+            }
+            if (!params.polyCount || !params.polys ||
+                    TILES_PER_MAP * TILES_PER_MAP == params.polyCount)
+            {
+                // we have flat tiles with no actual geometry - don't build those, its useless
+                // keep in mind that we do output those into debug info
+                // drop tiles with only exact count - some tiles may have geometry while having less tiles
+                printf("%s No polygons to build on tile!              \n", tileString);
+                continue;
+            }
+            if (!params.detailMeshes || !params.detailVerts || !params.detailTris)
+            {
+                printf("%s No detail mesh to build tile!           \n", tileString);
+                continue;
+            }
+
+            printf("%s Building navmesh tile...                \r", tileString);
+            if (!dtCreateNavMeshData(&params, &navData, &navDataSize))
+            {
+                printf("%s Failed building navmesh tile!           \n", tileString);
+                continue;
+            }
+
+            dtTileRef tileRef = 0;
+            printf("%s Adding tile to navmesh...                \r", tileString);
+            // DT_TILE_FREE_DATA tells detour to unallocate memory when the tile
+            // is removed via removeTile()
+            dtStatus dtResult = navMesh->addTile(navData, navDataSize, DT_TILE_FREE_DATA, 0, &tileRef);
+            if (!tileRef || dtResult != DT_SUCCESS)
+            {
+                printf("%s Failed adding tile to navmesh!           \n", tileString);
+                continue;
+            }
+
+            // file output
+            char fileName[255];
+            sprintf(fileName, "mmaps/%03u%02i%02i.mmtile", mapID, tileY, tileX);
+            FILE* file = fopen(fileName, "wb");
+            if (!file)
+            {
+                char message[1024];
+                sprintf(message, "Failed to open %s for writing!\n", fileName);
+                perror(message);
+                navMesh->removeTile(tileRef, NULL, NULL);
+                continue;
+            }
+
+            printf("%s Writing to file...                      \r", tileString);
+
+            // write header
+            MmapTileHeader header;
+            header.usesLiquids = m_terrainBuilder->usesLiquids();
+            header.size = uint32(navDataSize);
+            fwrite(&header, sizeof(MmapTileHeader), 1, file);
+
+            // write data
+            fwrite(navData, sizeof(unsigned char), navDataSize, file);
+            fclose(file);
+
+            // now that tile is written to disk, we can unload it
+            navMesh->removeTile(tileRef, NULL, NULL);
+        }
+        while (0);
+
+        if (m_debugOutput)
+        {
+            // restore padding so that the debug visualization is correct
+            for (int i = 0; i < iv.polyMesh->nverts; ++i)
+            {
+                unsigned short* v = &iv.polyMesh->verts[i * 3];
+                v[0] += (unsigned short)config.borderSize;
+                v[2] += (unsigned short)config.borderSize;
+            }
+
+            iv.generateObjFile(mapID, tileX, tileY, meshData);
+            iv.writeIV(mapID, tileX, tileY);
+        }
+    }
+
+    /**************************************************************************/
+    void MapBuilder::getTileBounds(uint32 tileX, uint32 tileY, float* verts, int vertCount, float* bmin, float* bmax)
+    {
+        // this is for elevation
+        if (verts && vertCount)
+            rcCalcBounds(verts, vertCount, bmin, bmax);
+        else
+        {
+            bmin[1] = FLT_MIN;
+            bmax[1] = FLT_MAX;
+        }
+
+        // this is for width and depth
+        bmax[0] = (32 - int(tileX)) * GRID_SIZE;
+        bmax[2] = (32 - int(tileY)) * GRID_SIZE;
+        bmin[0] = bmax[0] - GRID_SIZE;
+        bmin[2] = bmax[2] - GRID_SIZE;
+    }
+
+    /**************************************************************************/
+    bool MapBuilder::shouldSkipMap(uint32 mapID)
+    {
+        if (m_skipContinents)
+            switch (mapID)
+            {
+                case 0:
+                case 1:
+                case 530:
+                case 571:
+                    return true;
+                default:
+                    break;
+            }
+
+        if (m_skipJunkMaps)
+            switch (mapID)
+            {
+                case 13:    // test.wdt
+                case 25:    // ScottTest.wdt
+                case 29:    // Test.wdt
+                case 42:    // Colin.wdt
+                case 169:   // EmeraldDream.wdt (unused, and very large)
+                case 451:   // development.wdt
+                case 573:   // ExteriorTest.wdt
+                case 597:   // CraigTest.wdt
+                case 605:   // development_nonweighted.wdt
+                case 606:   // QA_DVD.wdt
+                    return true;
+                default:
+                    if (isTransportMap(mapID))
+                        return true;
+                    break;
+            }
+
+        if (m_skipBattlegrounds)
+            switch (mapID)
+            {
+                case 30:    // AV
+                case 37:    // ?
+                case 489:   // WSG
+                case 529:   // AB
+                case 566:   // EotS
+                case 607:   // SotA
+                case 628:   // IoC
+                    return true;
+                default:
+                    break;
+            }
+
+        return false;
+    }
+
+    /**************************************************************************/
+    bool MapBuilder::isTransportMap(uint32 mapID)
+    {
+        switch (mapID)
+        {
+                // transport maps
+            case 582:
+            case 584:
+            case 586:
+            case 587:
+            case 588:
+            case 589:
+            case 590:
+            case 591:
+            case 592:
+            case 593:
+            case 594:
+            case 596:
+            case 610:
+            case 612:
+            case 613:
+            case 614:
+            case 620:
+            case 621:
+            case 622:
+            case 623:
+            case 641:
+            case 642:
+            case 647:
+            case 672:
+            case 673:
+            case 712:
+            case 713:
+            case 718:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**************************************************************************/
+    bool MapBuilder::shouldSkipTile(uint32 mapID, uint32 tileX, uint32 tileY)
+    {
+        char fileName[255];
+        sprintf(fileName, "mmaps/%03u%02i%02i.mmtile", mapID, tileY, tileX);
+        FILE* file = fopen(fileName, "rb");
+        if (!file)
+            return false;
+
+        MmapTileHeader header;
+        fread(&header, sizeof(MmapTileHeader), 1, file);
+        fclose(file);
+
+        if (header.mmapMagic != MMAP_MAGIC || header.dtVersion != DT_NAVMESH_VERSION)
+            return false;
+
+        if (header.mmapVersion != MMAP_VERSION)
+            return false;
+
+        return true;
+    }
+}
diff -Nuar clean-build/maptools/mmap_generator/MapBuilder.h temp-build/maptools/mmap_generator/MapBuilder.h
--- clean-build/maptools/mmap_generator/MapBuilder.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/MapBuilder.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,110 @@
+#ifndef _MAP_BUILDER_H
+#define _MAP_BUILDER_H
+
+#include <vector>
+#include <set>
+#include <map>
+
+#include "TerrainBuilder.h"
+#include "IntermediateValues.h"
+
+#include "IVMapManager.h"
+#include "WorldModel.h"
+
+#include "Recast.h"
+#include "DetourNavMesh.h"
+
+using namespace std;
+using namespace VMAP;
+// G3D namespace typedefs conflicts with ACE typedefs
+
+namespace MMAP
+{
+    typedef map<uint32, set<uint32>*> TileList;
+    struct Tile
+    {
+        Tile() : chf(NULL), solid(NULL), cset(NULL), pmesh(NULL), dmesh(NULL) {}
+        ~Tile()
+        {
+            rcFreeCompactHeightfield(chf);
+            rcFreeContourSet(cset);
+            rcFreeHeightField(solid);
+            rcFreePolyMesh(pmesh);
+            rcFreePolyMeshDetail(dmesh);
+        }
+        rcCompactHeightfield* chf;
+        rcHeightfield* solid;
+        rcContourSet* cset;
+        rcPolyMesh* pmesh;
+        rcPolyMeshDetail* dmesh;
+    };
+
+    class MapBuilder
+    {
+        public:
+            MapBuilder(float maxWalkableAngle   = 60.f,
+                       bool skipLiquid          = false,
+                       bool skipContinents      = false,
+                       bool skipJunkMaps        = true,
+                       bool skipBattlegrounds   = false,
+                       bool debugOutput         = false,
+                       bool bigBaseUnit         = false,
+                       const char* offMeshFilePath = NULL);
+
+            ~MapBuilder();
+
+            // builds all mmap tiles for the specified map id (ignores skip settings)
+            void buildMap(uint32 mapID);
+
+            // builds an mmap tile for the specified map and its mesh
+            void buildSingleTile(uint32 mapID, uint32 tileX, uint32 tileY);
+
+            // builds list of maps, then builds all of mmap tiles (based on the skip settings)
+            void buildAllMaps();
+
+        private:
+            // detect maps and tiles
+            void discoverTiles();
+            set<uint32>* getTileList(uint32 mapID);
+
+            void buildNavMesh(uint32 mapID, dtNavMesh*& navMesh);
+
+            void buildTile(uint32 mapID, uint32 tileX, uint32 tileY, dtNavMesh* navMesh);
+
+            // move map building
+            void buildMoveMapTile(uint32 mapID,
+                                  uint32 tileX,
+                                  uint32 tileY,
+                                  MeshData& meshData,
+                                  float bmin[3],
+                                  float bmax[3],
+                                  dtNavMesh* navMesh);
+
+            void getTileBounds(uint32 tileX, uint32 tileY,
+                               float* verts, int vertCount,
+                               float* bmin, float* bmax);
+            void getGridBounds(uint32 mapID, uint32& minX, uint32& minY, uint32& maxX, uint32& maxY);
+
+            bool shouldSkipMap(uint32 mapID);
+            bool isTransportMap(uint32 mapID);
+            bool shouldSkipTile(uint32 mapID, uint32 tileX, uint32 tileY);
+
+            TerrainBuilder* m_terrainBuilder;
+            TileList m_tiles;
+
+            bool m_debugOutput;
+
+            const char* m_offMeshFilePath;
+            bool m_skipContinents;
+            bool m_skipJunkMaps;
+            bool m_skipBattlegrounds;
+
+            float m_maxWalkableAngle;
+            bool m_bigBaseUnit;
+
+            // build performance - not really used for now
+            rcContext* m_rcContext;
+    };
+}
+
+#endif
diff -Nuar clean-build/maptools/mmap_generator/mmap_build.sh temp-build/maptools/mmap_generator/mmap_build.sh
--- clean-build/maptools/mmap_generator/mmap_build.sh	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/mmap_build.sh	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,160 @@
+#!/bin/sh
+
+## Syntax of this helper
+## First param must be number of to be used CPUs (only 1, 2, 3, 4 supported) or "offmesh" to recreate the special tiles from the OFFMESH_FILE
+## Second param can be an additional filename for storing log
+## Third param can be an addition filename for storing detailed log
+
+## Additional Parameters to be forwarded to mmap_generator, see mmaps/readme for instructions
+PARAMS="--silent"
+
+## Already a few map extracted, and don't care anymore
+EXCLUDE_MAPS=""
+#EXCLUDE_MAPS="0 1 530 571" # example to exclude the continents
+
+## Offmesh file
+OFFMESH_FILE="offmesh.txt"
+
+## Normal log file (if not overwritten by second param
+LOG_FILE="mmap_generator.log"
+## Detailed log file
+DETAIL_LOG_FILE="mmap_generator_detailed.log"
+
+## ! Use below only for finetuning or if you know what you are doing !
+
+## All maps
+MAP_LIST_A="1 37 543 595 289 572 529 562 531 269 47 649 650 599 548 559 429 230 573 349 13 25 409 229 43 48 546 553 547 604 545 90 576"
+MAP_LIST_B="571 628 560 509 723 532 607 600 668 33 585 566 389 601 369 129 550 189 542 70 109 554 632 552 555 540 598 450 558 249 35 624 557"
+MAP_LIST_C="0 631 609 534 533 619 469 602 329 580 615 578 36 556 44 565 544 34 617 608 618 449 616 42 451 582 584 586 587 588 589 590 591 592"
+MAP_LIST_D="530 169 575 603 309 574 30 564 568 209 724 658 489  593 594 596 597 605 606 610 612 613 614 620 621 622 623 641 642 647 672 673 712 713 718"
+MAP_LIST_D1="209 724 658 489 606 610 612 613 614 620 621"
+MAP_LIST_D2="169 575 603 309 574 30 564 568 622 623 641 642 647 672 673 712 713 718"
+MAP_LIST_D3="530 593 594 596 597 605"
+
+badParam()
+{
+  echo "ERROR! Bad arguments!"
+  echo "You can (re)extract mmaps with this helper script,"
+  echo "or recreate only the tiles from the offmash file"
+  echo
+  echo "Call with number of processes (1 - 4) to create mmaps"
+  echo "Call with 'offmesh' to reextract the tiles from offmash file"
+  echo
+  echo "For further fine-tuning edit this helper script"
+  echo
+}
+
+if [ "$#" = "3" ]
+then
+  LOG_FILE=$2
+  DETAIL_LOG_FILE=$3
+elif [ "$#" = "2" ]
+then
+  LOG_FILE=$2
+fi
+
+# Offmesh file provided?
+OFFMESH=""
+if [ "$OFFMESH_FILE" != "" ]
+then
+  if [ ! -f "$OFFMESH_FILE" ]
+  then
+    echo "ERROR! Offmesh file $OFFMESH_FILE could not be found."
+    echo "Provide valid file or none. You need to edit the script"
+    exit 1
+  else
+    OFFMESH="--offMeshInput $OFFMESH_FILE"
+  fi
+fi
+
+# Get binary location
+echo ""
+/bin/echo -ne "Enter path for mmap_generator [$HOME/bin]: "
+read BINPATH
+echo ""
+
+if [ ! $BINPATH ]; then
+  BINPATH="$HOME/bin"
+fi 
+
+# Function to process a list
+createMMaps()
+{
+  for i in $@
+  do
+    for j in $EXCLUDE_MAPS
+    do
+      if [ "$i" = "$j" ]
+      then
+        continue 2
+      fi
+    done
+    $BINPATH/mmap_generator $PARAMS $OFFMESH $i | tee -a $DETAIL_LOG_FILE
+    echo "`date`: (Re)created map $i" | tee -a $LOG_FILE
+  done
+}
+
+createHeader()
+{
+  echo "`date`: Start creating MoveMaps" | tee -a $LOG_FILE
+  echo "Used params: $PARAMS $OFFMESH" | tee -a $LOG_FILE
+  echo "Detailed log can be found in $DETAIL_LOG_FILE" | tee -a $LOG_FILE
+  echo "Start creating MoveMaps" | tee -a $DETAIL_LOG_FILE
+  echo
+  echo "Be PATIENT - This will take a long time and might also have gaps between visible changes on the console."
+  echo "WAIT until you are informed that 'creating MoveMaps' is 'finished'!"
+}
+
+# Create mmaps directory if not exist
+if [ ! -d mmaps ]
+then
+  mkdir mmaps
+fi
+
+# Param control
+case "$1" in
+  "1" )
+    createHeader $1
+    createMMaps $MAP_LIST_A $MAP_LIST_B $MAP_LIST_C $MAP_LIST_D &
+    ;;
+  "2" )
+    createHeader $1
+    createMMaps $MAP_LIST_A $MAP_LIST_D &
+    createMMaps $MAP_LIST_B $MAP_LIST_C &
+    ;;
+  "3" )
+    createHeader $1
+    createMMaps $MAP_LIST_A $MAP_LIST_D1&
+    createMMaps $MAP_LIST_B $MAP_LIST_D2&
+    createMMaps $MAP_LIST_C $MAP_LIST_D3&
+    ;;
+  "4" )
+    createHeader $1
+    createMMaps $MAP_LIST_A &
+    createMMaps $MAP_LIST_B &
+    createMMaps $MAP_LIST_C &
+    createMMaps $MAP_LIST_D &
+    ;;
+  "offmesh" )
+    echo "`date`: Recreate offmeshs from file $OFFMESH_FILE" | tee -a $LOG_FILE
+    echo "Recreate offmeshs from file $OFFMESH_FILE" | tee -a $DETAIL_LOG_FILE
+    while read map tile line
+    do
+      $BINPATH/mmap_generator $PARAMS $OFFMESH $map --tile $tile | tee -a $DETAIL_LOG_FILE
+      echo "`date`: Recreated $map $tile from $OFFMESH_FILE" | tee -a $LOG_FILE
+    done < $OFFMESH_FILE &
+    ;;
+  * )
+    badParam
+    exit 1
+    ;;
+esac
+
+wait
+
+echo  | tee -a $LOG_FILE
+echo  | tee -a $DETAIL_LOG_FILE
+echo "`date`: Finished creating MoveMaps" | tee -a $LOG_FILE
+echo "`date`: Finished creating MoveMaps" >> $DETAIL_LOG_FILE
+
+# EOF
diff -Nuar clean-build/maptools/mmap_generator/MMapCommon.h temp-build/maptools/mmap_generator/MMapCommon.h
--- clean-build/maptools/mmap_generator/MMapCommon.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/MMapCommon.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,81 @@
+#ifndef _MMAP_COMMON_H
+#define _MMAP_COMMON_H
+
+#include <string>
+#include <vector>
+
+#include "Platform/Define.h"
+
+#include <stddef.h>
+#include <dirent.h>
+
+using namespace std;
+
+namespace MMAP
+{
+    inline bool matchWildcardFilter(const char* filter, const char* str)
+    {
+        if (!filter || !str)
+            return false;
+
+        // end on null character
+        while (*filter && *str)
+        {
+            if (*filter == '*')
+            {
+                if (*++filter == '\0')  // wildcard at end of filter means all remaing chars match
+                    return true;
+
+                while (true)
+                {
+                    if (*filter == *str)
+                        break;
+                    if (*str == '\0')
+                        return false;   // reached end of string without matching next filter character
+                    str++;
+                }
+            }
+            else if (*filter != *str)
+                return false;           // mismatch
+
+            filter++;
+            str++;
+        }
+
+        return ((*filter == '\0' || (*filter == '*' && *++filter == '\0')) && *str == '\0');
+    }
+
+    enum ListFilesResult
+    {
+        LISTFILE_DIRECTORY_NOT_FOUND = 0,
+        LISTFILE_OK = 1
+    };
+
+    inline ListFilesResult getDirContents(vector<string>& fileList, string dirpath = ".", string filter = "*", bool includeSubDirs = false)
+    {
+        const char* p = dirpath.c_str();
+        DIR* dirp = opendir(p);
+        struct dirent* dp;
+
+        while (dirp)
+        {
+            errno = 0;
+            if ((dp = readdir(dirp)) != NULL)
+            {
+                if (matchWildcardFilter(filter.c_str(), dp->d_name))
+                    fileList.push_back(string(dp->d_name));
+            }
+            else
+                break;
+        }
+
+        if (dirp)
+            closedir(dirp);
+        else
+            return LISTFILE_DIRECTORY_NOT_FOUND;
+
+        return LISTFILE_OK;
+    }
+}
+
+#endif
diff -Nuar clean-build/maptools/mmap_generator/mmap_extract.py temp-build/maptools/mmap_generator/mmap_extract.py
--- clean-build/maptools/mmap_generator/mmap_extract.py	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/mmap_extract.py	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,42 @@
+#!/usr/bin/python
+
+import os, sys, threading, time, subprocess
+from multiprocessing import cpu_count
+from collections import deque
+
+mapList = deque([0,1,530,571,13,25,30,33,34,35,36,37,42,43,44,47,48,70,90,109,129,169,189,209,229,230,249,269,289,309,329,349,369,
+    389,409,429,449,450,451,469,489,509,529,531,532,533,534,540,542,543,544,545,546,547,548,550,552,553,554,555,556,557,558,559,
+    560,562,564,565,566,568,572,573,574,575,576,578,580,582,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,
+    601,602,603,604,605,606,607,608,609,610,612,613,614,615,616,617,618,619,620,621,622,623,624,628,631,632,641,642,647,649,650,
+    658,668,672,673,712,713,718,723,724])
+
+class workerThread(threading.Thread):
+    def __init__(self, mapID):
+        threading.Thread.__init__(self)
+        self.mapID = mapID
+
+    def run(self):
+        name = "Worker for map %u" % (self.mapID)
+        print "++ %s" % (name)
+        if sys.platform == 'win32':
+            stInfo = subprocess.STARTUPINFO()
+            stInfo.dwFlags |= 0x00000001
+            stInfo.wShowWindow = 7
+            cFlags = subprocess.CREATE_NEW_CONSOLE
+            binName = "MoveMapGen.exe"
+        else:
+            stInfo = None
+            cFlags = 0
+            binName = "./MoveMapGen"
+        retcode = subprocess.call([binName, "%u" % (self.mapID),"--silent"], startupinfo=stInfo, creationflags=cFlags)
+        print "-- %s" % (name)
+
+if __name__ == "__main__":
+    cpu = cpu_count() - 0 # You can reduce the load by putting 1 instead of 0 if you need to free 1 core/cpu
+    if cpu < 1:
+        cpu = 1
+    print "I will always maintain %u MoveMapGen tasks running in //\n" % (cpu)
+    while (len(mapList) > 0):
+        if (threading.active_count() <= cpu):
+            workerThread(mapList.popleft()).start()
+        time.sleep(0.1)
diff -Nuar clean-build/maptools/mmap_generator/offmesh_example.txt temp-build/maptools/mmap_generator/offmesh_example.txt
--- clean-build/maptools/mmap_generator/offmesh_example.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/offmesh_example.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1 @@
+0 31,59 (-14429.889648 450.344452 15.430828) (-14424.218750 444.332855 12.773965) 2.5 // booty bay dock
diff -Nuar clean-build/maptools/mmap_generator/offmesh.txt temp-build/maptools/mmap_generator/offmesh.txt
--- clean-build/maptools/mmap_generator/offmesh.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/offmesh.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1 @@
+0 31,59 (-14429.889648 450.344452 15.430828) (-14424.218750 444.332855 12.773965) 2.5 // booty bay dock
diff -Nuar clean-build/maptools/mmap_generator/README.txt temp-build/maptools/mmap_generator/README.txt
--- clean-build/maptools/mmap_generator/README.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/README.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,81 @@
+Build Instructions
+------------------
+
+mkdir build
+cd build
+cmake ../ -DCMAKE_INSTALL_PREFIX=$HOME  # Or other install destination
+make install
+
+Binary will be installed as ${CMAKE_INSTALL_PREFIX}/bin/mmap_generator
+
+Execute "mmap_build.sh" from the client (WoW) directory.
+
+=====
+
+Generator command line args
+
+--offMeshInput      [file.*]        Path to file containing off mesh connections data.
+                                    Format must be: (see offmesh_example.txt)
+                                    "map_id tile_x,tile_y (start_x start_y start_z) (end_x end_y end_z) size  //optional comments"
+                                    Single mesh connection per line.
+
+--silent                            Make us script friendly. Do not wait for user input
+                                    on error or completion.
+
+--bigBaseUnit       [true|false]    Generate tile/map using bigger basic unit.
+                                    Use this option only if you have unexpected gaps.
+
+                                    false: use normal metrics (default)
+
+--maxAngle          [#]             Max walkable inclination angle
+
+                                    float between 45 and 90 degrees (default 60)
+
+--skipLiquid                        liquid data for maps
+
+                                    false: include liquid data (default)
+
+--skipContinents    [true|false]    continents are maps 0 (Eastern Kingdoms),
+                                    1 (Kalimdor), 530 (Outlands), 571 (Northrend)
+
+                                    false: build continents (default)
+
+--skipJunkMaps      [true|false]    junk maps include some unused
+                                    maps, transport maps, and some other
+
+                                    true: skip junk maps (default)
+
+--skipBattlegrounds [true|false]    does not include PVP arenas
+
+                                    false: skip battlegrounds (default)
+
+--debugOutput       [true|false]    create debugging files for use with RecastDemo
+                                    if you are only creating mmaps for use with Unity,
+                                    you don't want debugging files
+
+                                    false: don't create debugging files (default)
+
+--tile              [#,#]           Build the specified tile
+                                    seperate number with a comma ','
+                                    must specify a map number (see below)
+                                    if this option is not used, all tiles are built
+
+                    [#]             Build only the map specified by #
+                                    this command will build the map regardless of --skip* option settings
+                                    if you do not specify a map number, builds all maps that pass the filters specified by --skip* options
+
+
+examples:
+
+mmap_generator
+builds maps using the default settings (see above for defaults)
+
+mmap_generator --skipContinents true
+builds the default maps, except continents
+
+mmap_generator 0
+builds all tiles of map 0
+
+mmap_generator 0 --tile 34,46
+builds only tile 34,46 of map 0 (this is the southern face of blackrock mountain)
+
diff -Nuar clean-build/maptools/mmap_generator/TerrainBuilder.cpp temp-build/maptools/mmap_generator/TerrainBuilder.cpp
--- clean-build/maptools/mmap_generator/TerrainBuilder.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/TerrainBuilder.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,836 @@
+#include "TerrainBuilder.h"
+
+#include "MMapCommon.h"
+#include "MapBuilder.h"
+
+#include "VMapManager2.h"
+#include "MapTree.h"
+#include "ModelInstance.h"
+
+
+namespace MMAP
+{
+    TerrainBuilder::TerrainBuilder(bool skipLiquid) : m_skipLiquid(skipLiquid) { }
+    TerrainBuilder::~TerrainBuilder() { }
+
+    /**************************************************************************/
+    void TerrainBuilder::getLoopVars(Spot portion, int& loopStart, int& loopEnd, int& loopInc)
+    {
+        switch (portion)
+        {
+            case ENTIRE:
+                loopStart = 0;
+                loopEnd = V8_SIZE_SQ;
+                loopInc = 1;
+                break;
+            case TOP:
+                loopStart = 0;
+                loopEnd = V8_SIZE;
+                loopInc = 1;
+                break;
+            case LEFT:
+                loopStart = 0;
+                loopEnd = V8_SIZE_SQ - V8_SIZE + 1;
+                loopInc = V8_SIZE;
+                break;
+            case RIGHT:
+                loopStart = V8_SIZE - 1;
+                loopEnd = V8_SIZE_SQ;
+                loopInc = V8_SIZE;
+                break;
+            case BOTTOM:
+                loopStart = V8_SIZE_SQ - V8_SIZE;
+                loopEnd = V8_SIZE_SQ;
+                loopInc = 1;
+                break;
+        }
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::loadMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData)
+    {
+        if (loadMap(mapID, tileX, tileY, meshData, ENTIRE))
+        {
+            loadMap(mapID, tileX + 1, tileY, meshData, LEFT);
+            loadMap(mapID, tileX - 1, tileY, meshData, RIGHT);
+            loadMap(mapID, tileX, tileY + 1, meshData, TOP);
+            loadMap(mapID, tileX, tileY - 1, meshData, BOTTOM);
+        }
+    }
+
+    /**************************************************************************/
+    bool TerrainBuilder::loadMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData, Spot portion)
+    {
+        char mapFileName[255];
+        sprintf(mapFileName, "maps/%03u%02u%02u.map", mapID, tileY, tileX);
+
+        FILE* mapFile = fopen(mapFileName, "rb");
+        if (!mapFile)
+            return false;
+
+        GridMapFileHeader fheader;
+        fread(&fheader, sizeof(GridMapFileHeader), 1, mapFile);
+
+        if (fheader.versionMagic != *((uint32 const*)(MAP_VERSION_MAGIC)))
+        {
+            fclose(mapFile);
+            printf("%s is the wrong version, please extract new .map files\n", mapFileName);
+            return false;
+        }
+
+        GridMapHeightHeader hheader;
+        fseek(mapFile, fheader.heightMapOffset, SEEK_SET);
+        fread(&hheader, sizeof(GridMapHeightHeader), 1, mapFile);
+
+        bool haveTerrain = !(hheader.flags & MAP_HEIGHT_NO_HEIGHT);
+        bool haveLiquid = fheader.liquidMapOffset && !m_skipLiquid;
+
+        // no data in this map file
+        if (!haveTerrain && !haveLiquid)
+        {
+            fclose(mapFile);
+            return false;
+        }
+
+        // data used later
+        uint16 holes[16][16];
+        memset(holes, 0, sizeof(holes));
+        uint8 liquid_type[16][16];
+        memset(liquid_type, 0, sizeof(liquid_type));
+        G3D::Array<int> ltriangles;
+        G3D::Array<int> ttriangles;
+
+        // terrain data
+        if (haveTerrain)
+        {
+            int i;
+            float heightMultiplier;
+            float V9[V9_SIZE_SQ], V8[V8_SIZE_SQ];
+
+            if (hheader.flags & MAP_HEIGHT_AS_INT8)
+            {
+                uint8 v9[V9_SIZE_SQ];
+                uint8 v8[V8_SIZE_SQ];
+                fread(v9, sizeof(uint8), V9_SIZE_SQ, mapFile);
+                fread(v8, sizeof(uint8), V8_SIZE_SQ, mapFile);
+                heightMultiplier = (hheader.gridMaxHeight - hheader.gridHeight) / 255;
+
+                for (i = 0; i < V9_SIZE_SQ; ++i)
+                    V9[i] = (float)v9[i] * heightMultiplier + hheader.gridHeight;
+
+                for (i = 0; i < V8_SIZE_SQ; ++i)
+                    V8[i] = (float)v8[i] * heightMultiplier + hheader.gridHeight;
+            }
+            else if (hheader.flags & MAP_HEIGHT_AS_INT16)
+            {
+                uint16 v9[V9_SIZE_SQ];
+                uint16 v8[V8_SIZE_SQ];
+                fread(v9, sizeof(uint16), V9_SIZE_SQ, mapFile);
+                fread(v8, sizeof(uint16), V8_SIZE_SQ, mapFile);
+                heightMultiplier = (hheader.gridMaxHeight - hheader.gridHeight) / 65535;
+
+                for (i = 0; i < V9_SIZE_SQ; ++i)
+                    V9[i] = (float)v9[i] * heightMultiplier + hheader.gridHeight;
+
+                for (i = 0; i < V8_SIZE_SQ; ++i)
+                    V8[i] = (float)v8[i] * heightMultiplier + hheader.gridHeight;
+            }
+            else
+            {
+                fread(V9, sizeof(float), V9_SIZE_SQ, mapFile);
+                fread(V8, sizeof(float), V8_SIZE_SQ, mapFile);
+            }
+
+            // hole data
+            memset(holes, 0, fheader.holesSize);
+            fseek(mapFile, fheader.holesOffset, SEEK_SET);
+            fread(holes, fheader.holesSize, 1, mapFile);
+
+            int count = meshData.solidVerts.size() / 3;
+            float xoffset = (float(tileX) - 32) * GRID_SIZE;
+            float yoffset = (float(tileY) - 32) * GRID_SIZE;
+
+            float coord[3];
+
+            for (i = 0; i < V9_SIZE_SQ; ++i)
+            {
+                getHeightCoord(i, GRID_V9, xoffset, yoffset, coord, V9);
+                meshData.solidVerts.append(coord[0]);
+                meshData.solidVerts.append(coord[2]);
+                meshData.solidVerts.append(coord[1]);
+            }
+
+            for (i = 0; i < V8_SIZE_SQ; ++i)
+            {
+                getHeightCoord(i, GRID_V8, xoffset, yoffset, coord, V8);
+                meshData.solidVerts.append(coord[0]);
+                meshData.solidVerts.append(coord[2]);
+                meshData.solidVerts.append(coord[1]);
+            }
+
+            int j, indices[3], loopStart, loopEnd, loopInc;
+            getLoopVars(portion, loopStart, loopEnd, loopInc);
+            for (i = loopStart; i < loopEnd; i += loopInc)
+                for (j = TOP; j <= BOTTOM; j += 1)
+                {
+                    getHeightTriangle(i, Spot(j), indices);
+                    ttriangles.append(indices[2] + count);
+                    ttriangles.append(indices[1] + count);
+                    ttriangles.append(indices[0] + count);
+                }
+        }
+
+        // liquid data
+        if (haveLiquid)
+        {
+            GridMapLiquidHeader lheader;
+            fseek(mapFile, fheader.liquidMapOffset, SEEK_SET);
+            fread(&lheader, sizeof(GridMapLiquidHeader), 1, mapFile);
+
+            float* liquid_map = NULL;
+
+            if (!(lheader.flags & MAP_LIQUID_NO_TYPE))
+                fread(liquid_type, sizeof(liquid_type), 1, mapFile);
+
+            if (!(lheader.flags & MAP_LIQUID_NO_HEIGHT))
+            {
+                liquid_map = new float [lheader.width * lheader.height];
+                fread(liquid_map, sizeof(float), lheader.width * lheader.height, mapFile);
+            }
+
+            if (liquid_type && liquid_map)
+            {
+                int count = meshData.liquidVerts.size() / 3;
+                float xoffset = (float(tileX) - 32) * GRID_SIZE;
+                float yoffset = (float(tileY) - 32) * GRID_SIZE;
+
+                float coord[3];
+                int row, col;
+
+                // generate coordinates
+                if (!(lheader.flags & MAP_LIQUID_NO_HEIGHT))
+                {
+                    int j = 0;
+                    for (int i = 0; i < V9_SIZE_SQ; ++i)
+                    {
+                        row = i / V9_SIZE;
+                        col = i % V9_SIZE;
+
+                        if (row < lheader.offsetY || row >= lheader.offsetY + lheader.height ||
+                                col < lheader.offsetX || col >= lheader.offsetX + lheader.width)
+                        {
+                            // dummy vert using invalid height
+                            meshData.liquidVerts.append((xoffset + col * GRID_PART_SIZE) * -1, INVALID_MAP_LIQ_HEIGHT, (yoffset + row * GRID_PART_SIZE) * -1);
+                            continue;
+                        }
+
+                        getLiquidCoord(i, j, xoffset, yoffset, coord, liquid_map);
+                        meshData.liquidVerts.append(coord[0]);
+                        meshData.liquidVerts.append(coord[2]);
+                        meshData.liquidVerts.append(coord[1]);
+                        j++;
+                    }
+                }
+                else
+                {
+                    for (int i = 0; i < V9_SIZE_SQ; ++i)
+                    {
+                        row = i / V9_SIZE;
+                        col = i % V9_SIZE;
+                        meshData.liquidVerts.append((xoffset + col * GRID_PART_SIZE) * -1, lheader.liquidLevel, (yoffset + row * GRID_PART_SIZE) * -1);
+                    }
+                }
+
+                delete [] liquid_map;
+
+                int indices[3], loopStart, loopEnd, loopInc, triInc;
+                getLoopVars(portion, loopStart, loopEnd, loopInc);
+                triInc = BOTTOM - TOP;
+
+                // generate triangles
+                for (int i = loopStart; i < loopEnd; i += loopInc)
+                    for (int j = TOP; j <= BOTTOM; j += triInc)
+                    {
+                        getHeightTriangle(i, Spot(j), indices, true);
+                        ltriangles.append(indices[2] + count);
+                        ltriangles.append(indices[1] + count);
+                        ltriangles.append(indices[0] + count);
+                    }
+            }
+        }
+
+        fclose(mapFile);
+
+        // now that we have gathered the data, we can figure out which parts to keep:
+        // liquid above ground, ground above liquid
+        int loopStart, loopEnd, loopInc, tTriCount = 4;
+        bool useTerrain, useLiquid;
+
+        float* lverts = meshData.liquidVerts.getCArray();
+        int* ltris = ltriangles.getCArray();
+
+        float* tverts = meshData.solidVerts.getCArray();
+        int* ttris = ttriangles.getCArray();
+
+        if (ltriangles.size() + ttriangles.size() == 0)
+            return false;
+
+        // make a copy of liquid vertices
+        // used to pad right-bottom frame due to lost vertex data at extraction
+        float* lverts_copy = NULL;
+        if (meshData.liquidVerts.size())
+        {
+            lverts_copy = new float[meshData.liquidVerts.size()];
+            memcpy(lverts_copy, lverts, sizeof(float)*meshData.liquidVerts.size());
+        }
+
+        getLoopVars(portion, loopStart, loopEnd, loopInc);
+        for (int i = loopStart; i < loopEnd; i += loopInc)
+        {
+            for (int j = 0; j < 2; ++j)
+            {
+                // default is true, will change to false if needed
+                useTerrain = true;
+                useLiquid = true;
+                uint8 liquidType = MAP_LIQUID_TYPE_NO_WATER;
+
+                // if there is no liquid, don't use liquid
+                if (!liquid_type || !meshData.liquidVerts.size() || !ltriangles.size())
+                    useLiquid = false;
+                else
+                {
+                    liquidType = getLiquidType(i, liquid_type);
+                    switch (liquidType)
+                    {
+                        default:
+                            useLiquid = false;
+                            break;
+                        case MAP_LIQUID_TYPE_WATER:
+                        case MAP_LIQUID_TYPE_OCEAN:
+                            // merge different types of water
+                            liquidType = NAV_WATER;
+                            break;
+                        case MAP_LIQUID_TYPE_MAGMA:
+                            liquidType = NAV_MAGMA;
+                            break;
+                        case MAP_LIQUID_TYPE_SLIME:
+                            liquidType = NAV_SLIME;
+                            break;
+                        case MAP_LIQUID_TYPE_DARK_WATER:
+                            // players should not be here, so logically neither should creatures
+                            useTerrain = false;
+                            useLiquid = false;
+                            break;
+                    }
+                }
+
+                // if there is no terrain, don't use terrain
+                if (!ttriangles.size())
+                    useTerrain = false;
+
+                // while extracting ADT data we are losing right-bottom vertices
+                // this code adds fair approximation of lost data
+                if (useLiquid)
+                {
+                    float quadHeight = 0;
+                    uint32 validCount = 0;
+                    for (uint32 idx = 0; idx < 3; idx++)
+                    {
+                        float h = lverts_copy[ltris[idx] * 3 + 1];
+                        if (h != INVALID_MAP_LIQ_HEIGHT && h < INVALID_MAP_LIQ_HEIGHT_MAX)
+                        {
+                            quadHeight += h;
+                            validCount++;
+                        }
+                    }
+
+                    // update vertex height data
+                    if (validCount > 0 && validCount < 3)
+                    {
+                        quadHeight /= validCount;
+                        for (uint32 idx = 0; idx < 3; idx++)
+                        {
+                            float h = lverts[ltris[idx] * 3 + 1];
+                            if (h == INVALID_MAP_LIQ_HEIGHT || h > INVALID_MAP_LIQ_HEIGHT_MAX)
+                                lverts[ltris[idx] * 3 + 1] = quadHeight;
+                        }
+                    }
+
+                    // no valid vertexes - don't use this poly at all
+                    if (validCount == 0)
+                        useLiquid = false;
+                }
+
+                // if there is a hole here, don't use the terrain
+                if (useTerrain)
+                    useTerrain = !isHole(i, holes);
+
+                // we use only one terrain kind per quad - pick higher one
+                if (useTerrain && useLiquid)
+                {
+                    float minLLevel = INVALID_MAP_LIQ_HEIGHT_MAX;
+                    float maxLLevel = INVALID_MAP_LIQ_HEIGHT;
+                    for (uint32 x = 0; x < 3; x++)
+                    {
+                        float h = lverts[ltris[x] * 3 + 1];
+                        if (minLLevel > h)
+                            minLLevel = h;
+
+                        if (maxLLevel < h)
+                            maxLLevel = h;
+                    }
+
+                    float maxTLevel = INVALID_MAP_LIQ_HEIGHT;
+                    float minTLevel = INVALID_MAP_LIQ_HEIGHT_MAX;
+                    for (uint32 x = 0; x < 6; x++)
+                    {
+                        float h = tverts[ttris[x] * 3 + 1];
+                        if (maxTLevel < h)
+                            maxTLevel = h;
+
+                        if (minTLevel > h)
+                            minTLevel = h;
+                    }
+
+                    // terrain under the liquid?
+                    if (minLLevel > maxTLevel)
+                        useTerrain = false;
+
+                    //liquid under the terrain?
+                    if (minTLevel > maxLLevel)
+                        useLiquid = false;
+                }
+
+                // store the result
+                if (useLiquid)
+                {
+                    meshData.liquidType.append(liquidType);
+                    for (int k = 0; k < 3; ++k)
+                        meshData.liquidTris.append(ltris[k]);
+                }
+
+                if (useTerrain)
+                    for (int k = 0; k < 3 * tTriCount / 2; ++k)
+                        meshData.solidTris.append(ttris[k]);
+
+                // advance to next set of triangles
+                ltris += 3;
+                ttris += 3 * tTriCount / 2;
+            }
+        }
+
+        if (lverts_copy)
+            delete [] lverts_copy;
+
+        return meshData.solidTris.size() || meshData.liquidTris.size();
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::getHeightCoord(int index, Grid grid, float xOffset, float yOffset, float* coord, float* v)
+    {
+        // wow coords: x, y, height
+        // coord is mirroed about the horizontal axes
+        switch (grid)
+        {
+            case GRID_V9:
+                coord[0] = (xOffset + index % (V9_SIZE) * GRID_PART_SIZE) * -1.f;
+                coord[1] = (yOffset + (int)(index / (V9_SIZE)) * GRID_PART_SIZE) * -1.f;
+                coord[2] = v[index];
+                break;
+            case GRID_V8:
+                coord[0] = (xOffset + index % (V8_SIZE) * GRID_PART_SIZE + GRID_PART_SIZE / 2.f) * -1.f;
+                coord[1] = (yOffset + (int)(index / (V8_SIZE)) * GRID_PART_SIZE + GRID_PART_SIZE / 2.f) * -1.f;
+                coord[2] = v[index];
+                break;
+        }
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::getHeightTriangle(int square, Spot triangle, int* indices, bool liquid/* = false*/)
+    {
+        int rowOffset = square / V8_SIZE;
+        if (!liquid)
+            switch (triangle)
+            {
+                case TOP:
+                    indices[0] = square + rowOffset;                //           0-----1 .... 128
+                    indices[1] = square + 1 + rowOffset;            //           |\ T /|
+                    indices[2] = (V9_SIZE_SQ) + square;             //           | \ / |
+                    break;                                          //           |L 0 R| .. 127
+                case LEFT:                                          //           | / \ |
+                    indices[0] = square + rowOffset;                //           |/ B \|
+                    indices[1] = (V9_SIZE_SQ) + square;             //          129---130 ... 386
+                    indices[2] = square + V9_SIZE + rowOffset;      //           |\   /|
+                    break;                                          //           | \ / |
+                case RIGHT:                                         //           | 128 | .. 255
+                    indices[0] = square + 1 + rowOffset;            //           | / \ |
+                    indices[1] = square + V9_SIZE + 1 + rowOffset;  //           |/   \|
+                    indices[2] = (V9_SIZE_SQ) + square;             //          258---259 ... 515
+                    break;
+                case BOTTOM:
+                    indices[0] = (V9_SIZE_SQ) + square;
+                    indices[1] = square + V9_SIZE + 1 + rowOffset;
+                    indices[2] = square + V9_SIZE + rowOffset;
+                    break;
+                default: break;
+            }
+        else
+            switch (triangle)
+            {
+                    //           0-----1 .... 128
+                case TOP:                                               //           |\    |
+                    indices[0] = square + rowOffset;                    //           | \ T |
+                    indices[1] = square + 1 + rowOffset;                //           |  \  |
+                    indices[2] = square + V9_SIZE + 1 + rowOffset;      //           | B \ |
+                    break;                                              //           |    \|
+                case BOTTOM:                                            //          129---130 ... 386
+                    indices[0] = square + rowOffset;                    //           |\    |
+                    indices[1] = square + V9_SIZE + 1 + rowOffset;      //           | \   |
+                    indices[2] = square + V9_SIZE + rowOffset;          //           |  \  |
+                    break;                                              //           |   \ |
+                default: break;                                         //           |    \|
+            }                                                           //          258---259 ... 515
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::getLiquidCoord(int index, int index2, float xOffset, float yOffset, float* coord, float* v)
+    {
+        // wow coords: x, y, height
+        // coord is mirroed about the horizontal axes
+        coord[0] = (xOffset + index % (V9_SIZE) * GRID_PART_SIZE) * -1.f;
+        coord[1] = (yOffset + (int)(index / (V9_SIZE)) * GRID_PART_SIZE) * -1.f;
+        coord[2] = v[index2];
+    }
+
+    static uint16 holetab_h[4] = {0x1111, 0x2222, 0x4444, 0x8888};
+    static uint16 holetab_v[4] = {0x000F, 0x00F0, 0x0F00, 0xF000};
+
+    /**************************************************************************/
+    bool TerrainBuilder::isHole(int square, const uint16 holes[16][16])
+    {
+        int row = square / 128;
+        int col = square % 128;
+        int cellRow = row / 8;     // 8 squares per cell
+        int cellCol = col / 8;
+        int holeRow = row % 8 / 2;
+        int holeCol = (square - (row * 128 + cellCol * 8)) / 2;
+
+        uint16 hole = holes[cellRow][cellCol];
+
+        return (hole & holetab_h[holeCol] & holetab_v[holeRow]) != 0;
+    }
+
+    /**************************************************************************/
+    uint8 TerrainBuilder::getLiquidType(int square, const uint8 liquid_type[16][16])
+    {
+        int row = square / 128;
+        int col = square % 128;
+        int cellRow = row / 8;     // 8 squares per cell
+        int cellCol = col / 8;
+
+        return liquid_type[cellRow][cellCol];
+    }
+
+    /**************************************************************************/
+    bool TerrainBuilder::loadVMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData)
+    {
+        IVMapManager* vmapManager = new VMapManager2();
+        VMAPLoadResult result = vmapManager->loadMap("vmaps", mapID, tileX, tileY);
+        bool retval = false;
+
+        do
+        {
+            if (result == VMAP_LOAD_RESULT_ERROR)
+                break;
+
+            InstanceTreeMap instanceTrees;
+            ((VMapManager2*)vmapManager)->getInstanceMapTree(instanceTrees);
+
+            if (!instanceTrees[mapID])
+                break;
+
+            ModelInstance* models = NULL;
+            uint32 count = 0;
+            instanceTrees[mapID]->getModelInstances(models, count);
+
+            if (!models)
+                break;
+
+            for (uint32 i = 0; i < count; ++i)
+            {
+                ModelInstance instance = models[i];
+
+                // model instances exist in tree even though there are instances of that model in this tile
+                WorldModel* worldModel = instance.getWorldModel();
+                if (!worldModel)
+                    continue;
+
+                // now we have a model to add to the meshdata
+                retval = true;
+
+                vector<GroupModel> groupModels;
+                worldModel->getGroupModels(groupModels);
+
+                // all M2s need to have triangle indices reversed
+                bool isM2 = instance.name.find(".m2") != instance.name.npos || instance.name.find(".M2") != instance.name.npos;
+
+                // transform data
+                float scale = instance.iScale;
+                G3D::Matrix3 rotation = G3D::Matrix3::fromEulerAnglesXYZ(G3D::pi() * instance.iRot.z / -180.f, G3D::pi() * instance.iRot.x / -180.f, G3D::pi() * instance.iRot.y / -180.f);
+                Vector3 position = instance.iPos;
+                position.x -= 32 * GRID_SIZE;
+                position.y -= 32 * GRID_SIZE;
+
+                for (vector<GroupModel>::iterator it = groupModels.begin(); it != groupModels.end(); ++it)
+                {
+                    vector<Vector3> tempVertices;
+                    vector<Vector3> transformedVertices;
+                    vector<MeshTriangle> tempTriangles;
+                    WmoLiquid* liquid = NULL;
+
+                    (*it).getMeshData(tempVertices, tempTriangles, liquid);
+
+                    // first handle collision mesh
+                    transform(tempVertices, transformedVertices, scale, rotation, position);
+
+                    int offset = meshData.solidVerts.size() / 3;
+
+                    copyVertices(transformedVertices, meshData.solidVerts);
+                    copyIndices(tempTriangles, meshData.solidTris, offset, isM2);
+
+                    // now handle liquid data
+                    if (liquid)
+                    {
+                        vector<Vector3> liqVerts;
+                        vector<int> liqTris;
+                        uint32 tilesX, tilesY, vertsX, vertsY;
+                        Vector3 corner;
+                        liquid->getPosInfo(tilesX, tilesY, corner);
+                        vertsX = tilesX + 1;
+                        vertsY = tilesY + 1;
+                        uint8* flags = liquid->GetFlagsStorage();
+                        float* data = liquid->GetHeightStorage();
+                        uint8 type = NAV_EMPTY;
+
+                        // convert liquid type to NavTerrain
+                        switch (liquid->GetType())
+                        {
+                            case 0:
+                            case 1:
+                                type = NAV_WATER;
+                                break;
+                            case 2:
+                                type = NAV_MAGMA;
+                                break;
+                            case 3:
+                                type = NAV_SLIME;
+                                break;
+                        }
+
+                        // indexing is weird...
+                        // after a lot of trial and error, this is what works:
+                        // vertex = y*vertsX+x
+                        // tile   = x*tilesY+y
+                        // flag   = y*tilesY+x
+
+                        Vector3 vert;
+                        for (uint32 x = 0; x < vertsX; ++x)
+                            for (uint32 y = 0; y < vertsY; ++y)
+                            {
+                                vert = Vector3(corner.x + x * GRID_PART_SIZE, corner.y + y * GRID_PART_SIZE, data[y * vertsX + x]);
+                                vert = vert * rotation * scale + position;
+                                vert.x *= -1.f;
+                                vert.y *= -1.f;
+                                liqVerts.push_back(vert);
+                            }
+
+                        int idx1, idx2, idx3, idx4;
+                        uint32 square;
+                        for (uint32 x = 0; x < tilesX; ++x)
+                            for (uint32 y = 0; y < tilesY; ++y)
+                                if ((flags[x + y * tilesX] & 0x0f) != 0x0f)
+                                {
+                                    square = x * tilesY + y;
+                                    idx1 = square + x;
+                                    idx2 = square + 1 + x;
+                                    idx3 = square + tilesY + 1 + 1 + x;
+                                    idx4 = square + tilesY + 1 + x;
+
+                                    // top triangle
+                                    liqTris.push_back(idx3);
+                                    liqTris.push_back(idx2);
+                                    liqTris.push_back(idx1);
+                                    // bottom triangle
+                                    liqTris.push_back(idx4);
+                                    liqTris.push_back(idx3);
+                                    liqTris.push_back(idx1);
+                                }
+
+                        uint32 liqOffset = meshData.liquidVerts.size() / 3;
+                        for (uint32 i = 0; i < liqVerts.size(); ++i)
+                            meshData.liquidVerts.append(liqVerts[i].y, liqVerts[i].z, liqVerts[i].x);
+
+                        for (uint32 i = 0; i < liqTris.size() / 3; ++i)
+                        {
+                            meshData.liquidTris.append(liqTris[i * 3 + 1] + liqOffset, liqTris[i * 3 + 2] + liqOffset, liqTris[i * 3] + liqOffset);
+                            meshData.liquidType.append(type);
+                        }
+                    }
+                }
+            }
+        }
+        while (false);
+
+        vmapManager->unloadMap(mapID, tileX, tileY);
+        delete vmapManager;
+
+        return retval;
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::transform(vector<Vector3>& source, vector<Vector3>& transformedVertices, float scale, G3D::Matrix3& rotation, Vector3& position)
+    {
+        for (vector<Vector3>::iterator it = source.begin(); it != source.end(); ++it)
+        {
+            // apply tranform, then mirror along the horizontal axes
+            Vector3 v((*it) * rotation * scale + position);
+            v.x *= -1.f;
+            v.y *= -1.f;
+            transformedVertices.push_back(v);
+        }
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::copyVertices(vector<Vector3>& source, G3D::Array<float>& dest)
+    {
+        for (vector<Vector3>::iterator it = source.begin(); it != source.end(); ++it)
+        {
+            dest.push_back((*it).y);
+            dest.push_back((*it).z);
+            dest.push_back((*it).x);
+        }
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::copyIndices(vector<MeshTriangle>& source, G3D::Array<int>& dest, int offset, bool flip)
+    {
+        if (flip)
+        {
+            for (vector<MeshTriangle>::iterator it = source.begin(); it != source.end(); ++it)
+            {
+                dest.push_back((*it).idx2 + offset);
+                dest.push_back((*it).idx1 + offset);
+                dest.push_back((*it).idx0 + offset);
+            }
+        }
+        else
+        {
+            for (vector<MeshTriangle>::iterator it = source.begin(); it != source.end(); ++it)
+            {
+                dest.push_back((*it).idx0 + offset);
+                dest.push_back((*it).idx1 + offset);
+                dest.push_back((*it).idx2 + offset);
+            }
+        }
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::copyIndices(G3D::Array<int>& source, G3D::Array<int>& dest, int offset)
+    {
+        int* src = source.getCArray();
+        for (int32 i = 0; i < source.size(); ++i)
+            dest.append(src[i] + offset);
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::cleanVertices(G3D::Array<float>& verts, G3D::Array<int>& tris)
+    {
+        map<int, int> vertMap;
+
+        int* t = tris.getCArray();
+        float* v = verts.getCArray();
+
+        // collect all the vertex indices from triangle
+        for (int i = 0; i < tris.size(); ++i)
+        {
+            if (vertMap.find(t[i]) != vertMap.end())
+                continue;
+
+            vertMap.insert(std::pair<int, int>(t[i], 0));
+        }
+
+        // collect the vertices
+        G3D::Array<float> cleanVerts;
+        int index, count = 0;
+        for (map<int, int>::iterator it = vertMap.begin(); it != vertMap.end(); ++it)
+        {
+            index = (*it).first;
+            (*it).second = count;
+            cleanVerts.append(v[index * 3], v[index * 3 + 1], v[index * 3 + 2]);
+            count++;
+        }
+        verts.fastClear();
+        verts.append(cleanVerts);
+        cleanVerts.clear();
+
+        // update triangles to use new indices
+        for (int i = 0; i < tris.size(); ++i)
+        {
+            map<int, int>::iterator it;
+            if ((it = vertMap.find(t[i])) == vertMap.end())
+                continue;
+
+            t[i] = (*it).second;
+        }
+
+        vertMap.clear();
+    }
+
+    /**************************************************************************/
+    void TerrainBuilder::loadOffMeshConnections(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData, const char* offMeshFilePath)
+    {
+        // no meshfile input given?
+        if (offMeshFilePath == NULL)
+            return;
+
+        FILE* fp = fopen(offMeshFilePath, "rb");
+        if (!fp)
+        {
+            printf(" loadOffMeshConnections:: input file %s not found!\n", offMeshFilePath);
+            return;
+        }
+
+        // pretty silly thing, as we parse entire file and load only the tile we need
+        // but we don't expect this file to be too large
+        char* buf = new char[512];
+        while (fgets(buf, 512, fp))
+        {
+            float p0[3], p1[3];
+            int mid, tx, ty;
+            float size;
+            if (10 != sscanf(buf, "%d %d,%d (%f %f %f) (%f %f %f) %f", &mid, &tx, &ty,
+                             &p0[0], &p0[1], &p0[2], &p1[0], &p1[1], &p1[2], &size))
+                continue;
+
+            if (mapID == mid, tileX == tx, tileY == ty)
+            {
+                meshData.offMeshConnections.append(p0[1]);
+                meshData.offMeshConnections.append(p0[2]);
+                meshData.offMeshConnections.append(p0[0]);
+
+                meshData.offMeshConnections.append(p1[1]);
+                meshData.offMeshConnections.append(p1[2]);
+                meshData.offMeshConnections.append(p1[0]);
+
+                meshData.offMeshConnectionDirs.append(1);          // 1 - both direction, 0 - one sided
+                meshData.offMeshConnectionRads.append(size);       // agent size equivalent
+                // can be used same way as polygon flags
+                meshData.offMeshConnectionsAreas.append((unsigned char)0xFF);
+                meshData.offMeshConnectionsFlags.append((unsigned short)0xFF);  // all movement masks can make this path
+            }
+        }
+
+        delete [] buf;
+        fclose(fp);
+    }
+}
diff -Nuar clean-build/maptools/mmap_generator/TerrainBuilder.h temp-build/maptools/mmap_generator/TerrainBuilder.h
--- clean-build/maptools/mmap_generator/TerrainBuilder.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/TerrainBuilder.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,119 @@
+#ifndef _MMAP_TERRAIN_BUILDER_H
+#define _MMAP_TERRAIN_BUILDER_H
+
+#include "MMapCommon.h"
+#include "CoreMap.h"
+#include "game/MoveMapSharedDefines.h"
+
+#include "WorldModel.h"
+
+#include "G3D/Array.h"
+#include "G3D/Vector3.h"
+#include "G3D/Matrix3.h"
+
+using namespace System;
+
+namespace MMAP
+{
+    enum Spot
+    {
+        TOP     = 1,
+        RIGHT   = 2,
+        LEFT    = 3,
+        BOTTOM  = 4,
+        ENTIRE  = 5
+    };
+
+    enum Grid
+    {
+        GRID_V8,
+        GRID_V9
+    };
+
+    static const int V9_SIZE = 129;
+    static const int V9_SIZE_SQ = V9_SIZE* V9_SIZE;
+    static const int V8_SIZE = 128;
+    static const int V8_SIZE_SQ = V8_SIZE* V8_SIZE;
+    static const float GRID_SIZE = 533.33333f;
+    static const float GRID_PART_SIZE = GRID_SIZE / V8_SIZE;
+
+    // see contrib/extractor/system.cpp, CONF_use_minHeight
+    static const float INVALID_MAP_LIQ_HEIGHT = -500.f;
+    static const float INVALID_MAP_LIQ_HEIGHT_MAX = 5000.0f;
+
+    // see following files:
+    // contrib/extractor/system.cpp
+    // src/game/GridMap.cpp
+    static char const* MAP_VERSION_MAGIC = "v1.3";
+
+    struct MeshData
+    {
+        G3D::Array<float> solidVerts;
+        G3D::Array<int> solidTris;
+
+        G3D::Array<float> liquidVerts;
+        G3D::Array<int> liquidTris;
+        G3D::Array<uint8> liquidType;
+
+        // offmesh connection data
+        G3D::Array<float> offMeshConnections;   // [p0y,p0z,p0x,p1y,p1z,p1x] - per connection
+        G3D::Array<float> offMeshConnectionRads;
+        G3D::Array<unsigned char> offMeshConnectionDirs;
+        G3D::Array<unsigned char> offMeshConnectionsAreas;
+        G3D::Array<unsigned short> offMeshConnectionsFlags;
+    };
+
+    class TerrainBuilder
+    {
+        public:
+            TerrainBuilder(bool skipLiquid);
+            ~TerrainBuilder();
+
+            void loadMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData);
+            bool loadVMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData);
+            void loadOffMeshConnections(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData, const char* offMeshFilePath);
+
+            bool usesLiquids() { return !m_skipLiquid; }
+
+            // vert and triangle methods
+            static void transform(vector<G3D::Vector3>& original, vector<G3D::Vector3>& transformed,
+                                  float scale, G3D::Matrix3& rotation, G3D::Vector3& position);
+            static void copyVertices(vector<G3D::Vector3>& source, G3D::Array<float>& dest);
+            static void copyIndices(vector<VMAP::MeshTriangle>& source, G3D::Array<int>& dest, int offest, bool flip);
+            static void copyIndices(G3D::Array<int>& src, G3D::Array<int>& dest, int offset);
+            static void cleanVertices(G3D::Array<float>& verts, G3D::Array<int>& tris);
+        private:
+            /// Loads a portion of a map's terrain
+            bool loadMap(uint32 mapID, uint32 tileX, uint32 tileY, MeshData& meshData, Spot portion);
+
+            /// Sets loop variables for selecting only certain parts of a map's terrain
+            void getLoopVars(Spot portion, int& loopStart, int& loopEnd, int& loopInc);
+
+            /// Controls whether liquids are loaded
+            bool m_skipLiquid;
+
+            /// Load the map terrain from file
+            bool loadHeightMap(uint32 mapID, uint32 tileX, uint32 tileY, G3D::Array<float>& vertices, G3D::Array<int>& triangles, Spot portion);
+
+            /// Get the vector coordinate for a specific position
+            void getHeightCoord(int index, Grid grid, float xOffset, float yOffset, float* coord, float* v);
+
+            /// Get the triangle's vector indices for a specific position
+            void getHeightTriangle(int square, Spot triangle, int* indices, bool liquid = false);
+
+            /// Determines if the specific position's triangles should be rendered
+            bool isHole(int square, const uint16 holes[16][16]);
+
+            /// Get the liquid vector coordinate for a specific position
+            void getLiquidCoord(int index, int index2, float xOffset, float yOffset, float* coord, float* v);
+
+            /// Get the liquid type for a specific position
+            uint8 getLiquidType(int square, const uint8 liquid_type[16][16]);
+
+            // hide parameterless and copy constructor
+            TerrainBuilder();
+            TerrainBuilder(const TerrainBuilder& tb);
+    };
+}
+
+#endif
diff -Nuar clean-build/maptools/mmap_generator/VMapExtensions.cpp temp-build/maptools/mmap_generator/VMapExtensions.cpp
--- clean-build/maptools/mmap_generator/VMapExtensions.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/mmap_generator/VMapExtensions.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,55 @@
+#include <vector>
+
+#include "MapTree.h"
+#include "VMapManager2.h"
+#include "WorldModel.h"
+#include "ModelInstance.h"
+
+using namespace std;
+
+namespace VMAP
+{
+    // Need direct access to encapsulated VMAP data, so we add functions for MMAP generator
+    // maybe add MapBuilder as friend to all of the below classes would be better?
+
+    // declared in src/shared/vmap/MapTree.h
+    void StaticMapTree::getModelInstances(ModelInstance*& models, uint32& count)
+    {
+        models = iTreeValues;
+        count = iNTreeValues;
+    }
+
+    // declared in src/shared/vmap/VMapManager2.h
+    void VMapManager2::getInstanceMapTree(InstanceTreeMap& instanceMapTree)
+    {
+        instanceMapTree = iInstanceMapTrees;
+    }
+
+    // declared in src/shared/vmap/WorldModel.h
+    void WorldModel::getGroupModels(vector<GroupModel>& groupModels)
+    {
+        groupModels = this->groupModels;
+    }
+
+    // declared in src/shared/vmap/WorldModel.h
+    void GroupModel::getMeshData(vector<Vector3>& vertices, vector<MeshTriangle>& triangles, WmoLiquid*& liquid)
+    {
+        vertices = this->vertices;
+        triangles = this->triangles;
+        liquid = iLiquid;
+    }
+
+    // declared in src/shared/vmap/ModelInstance.h
+    WorldModel* const ModelInstance::getWorldModel()
+    {
+        return iModel;
+    }
+
+    // declared in src/shared/vmap/WorldModel.h
+    void WmoLiquid::getPosInfo(uint32& tilesX, uint32& tilesY, Vector3& corner) const
+    {
+        tilesX = iTilesX;
+        tilesY = iTilesY;
+        corner = iCorner;
+    }
+}
diff -Nuar clean-build/maptools/vmap_assembler/CMakeLists.txt temp-build/maptools/vmap_assembler/CMakeLists.txt
--- clean-build/maptools/vmap_assembler/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_assembler/CMakeLists.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,19 @@
+ADD_DEFINITIONS("-DNO_CORE_FUNCS")
+
+add_library(vmap_mt1
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/BIH.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/VMapManager2.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/MapTree.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/TileAssembler.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/WorldModel.cpp
+        ${CMAKE_SOURCE_DIR}/src/game/vmap/ModelInstance.cpp
+        )
+
+target_link_libraries(vmap_mt1 g3dlite zlib_mt)
+
+add_executable(vmap_assembler vmap_assembler.cpp)
+
+target_link_libraries(vmap_assembler vmap_mt1)
+
+install(TARGETS vmap_assembler DESTINATION ${CMAKE_INSTALL_PREFIX}/maptools)
+
diff -Nuar clean-build/maptools/vmap_assembler/README.txt temp-build/maptools/vmap_assembler/README.txt
--- clean-build/maptools/vmap_assembler/README.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_assembler/README.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,14 @@
+Build Instructions
+------------------
+
+mkdir build
+cd build
+cmake ../ -DCMAKE_INSTALL_PREFIX=$HOME  # Or other install destination
+make install
+
+Binary will be installed as ${CMAKE_INSTALL_PREFIX}/bin/vmap_assembler
+
+Run "mkdir vmaps" in the client (WoW) directory.
+
+Execute "vmap_assembler Buildings vmaps" from the client (WoW) directory.
+
diff -Nuar clean-build/maptools/vmap_assembler/vmap_assembler.cpp temp-build/maptools/vmap_assembler/vmap_assembler.cpp
--- clean-build/maptools/vmap_assembler/vmap_assembler.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_assembler/vmap_assembler.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,32 @@
+#include <string>
+#include <iostream>
+
+#include "TileAssembler.h"
+
+int main(int argc, char* argv[])
+{
+    if (argc != 3)
+    {
+        std::cout << "usage: " << argv[0] << " <raw data dir> <vmap dest dir>" << std::endl;
+        return 1;
+    }
+
+    std::string src = argv[1];
+    std::string dest = argv[2];
+
+    std::cout << "using " << src << " as source directory and writing output to " << dest << std::endl;
+
+    VMAP::TileAssembler* ta = new VMAP::TileAssembler(src, dest);
+
+    if (!ta->convertWorld2())
+    {
+        std::cout << "exit with errors" << std::endl;
+        delete ta;
+        return 1;
+    }
+
+    delete ta;
+    std::cout << "Ok, all done" << std::endl;
+    return 0;
+}
+
diff -Nuar clean-build/maptools/vmap_extractor/adtfile.cpp temp-build/maptools/vmap_extractor/adtfile.cpp
--- clean-build/maptools/vmap_extractor/adtfile.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/adtfile.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,198 @@
+#include "vmapexport.h"
+#include "adtfile.h"
+
+#include <algorithm>
+#include <cstdio>
+
+const char* GetPlainName(const char* FileName)
+{
+    const char* szTemp;
+
+    if ((szTemp = strrchr(FileName, '\\')) != NULL)
+        FileName = szTemp + 1;
+    return FileName;
+}
+
+char* GetPlainName(char* FileName)
+{
+    char* szTemp;
+
+    if ((szTemp = strrchr(FileName, '\\')) != NULL)
+        FileName = szTemp + 1;
+    return FileName;
+}
+
+void fixnamen(char* name, size_t len)
+{
+    for (size_t i = 0; i < len - 3; i++)
+    {
+        if (i > 0 && name[i] >= 'A' && name[i] <= 'Z' && isalpha(name[i - 1]))
+        {
+            name[i] |= 0x20;
+        }
+        else if ((i == 0 || !isalpha(name[i - 1])) && name[i] >= 'a' && name[i] <= 'z')
+        {
+            name[i] &= ~0x20;
+        }
+    }
+    //extension in lowercase
+    for (size_t i = len - 3; i < len; i++)
+        name[i] |= 0x20;
+}
+
+void fixname2(char* name, size_t len)
+{
+    for (size_t i = 0; i < len - 3; i++)
+    {
+        if (name[i] == ' ')
+            name[i] = '_';
+    }
+}
+
+char const* GetExtension(char const* FileName)
+{
+    char const* szTemp;
+    if ((szTemp = strrchr(FileName, '.')) != NULL)
+        return szTemp;
+    return NULL;
+}
+
+ADTFile::ADTFile(char* filename): ADT(filename)
+{
+    Adtfilename.append(filename);
+}
+
+bool ADTFile::init(uint32 map_num, uint32 tileX, uint32 tileY, StringSet& failedPaths)
+{
+    if (ADT.isEof())
+        return false;
+
+    uint32 size;
+
+    string xMap;
+    string yMap;
+
+    Adtfilename.erase(Adtfilename.find(".adt"), 4);
+    string TempMapNumber;
+    TempMapNumber = Adtfilename.substr(Adtfilename.length() - 6, 6);
+    xMap = TempMapNumber.substr(TempMapNumber.find("_") + 1, (TempMapNumber.find_last_of("_") - 1) - (TempMapNumber.find("_")));
+    yMap = TempMapNumber.substr(TempMapNumber.find_last_of("_") + 1, (TempMapNumber.length()) - (TempMapNumber.find_last_of("_")));
+    Adtfilename.erase((Adtfilename.length() - xMap.length() - yMap.length() - 2), (xMap.length() + yMap.length() + 2));
+    string AdtMapNumber = xMap + ' ' + yMap + ' ' + GetPlainName((char*)Adtfilename.c_str());
+    //printf("Processing map %s...\n", AdtMapNumber.c_str());
+    //printf("MapNumber = %s\n", TempMapNumber.c_str());
+    //printf("xMap = %s\n", xMap.c_str());
+    //printf("yMap = %s\n", yMap.c_str());
+
+    std::string dirname = std::string(szWorkDirWmo) + "/dir_bin";
+    FILE* dirfile;
+    dirfile = fopen(dirname.c_str(), "ab");
+    if (!dirfile)
+    {
+        printf("Can't open dirfile!'%s'\n", dirname.c_str());
+        return false;
+    }
+
+    while (!ADT.isEof())
+    {
+        char fourcc[5];
+        ADT.read(&fourcc, 4);
+        ADT.read(&size, 4);
+        flipcc(fourcc);
+        fourcc[4] = 0;
+
+        size_t nextpos = ADT.getPos() + size;
+
+        if (!strcmp(fourcc, "MCIN"))
+        {
+        }
+        else if (!strcmp(fourcc, "MTEX"))
+        {
+        }
+        else if (!strcmp(fourcc, "MMDX"))
+        {
+            if (size)
+            {
+                char* buf = new char[size];
+                ADT.read(buf, size);
+                char* p = buf;
+                int t = 0;
+                ModelInstansName = new string[size];
+                while (p < buf + size)
+                {
+                    fixnamen(p, strlen(p));
+                    char* s = GetPlainName(p);
+                    fixname2(s, strlen(s));
+                    string path(p);                         // Store copy after name fixed
+
+                    std::string fixedName;
+                    ExtractSingleModel(path, fixedName, failedPaths);
+                    ModelInstansName[t++] = fixedName;
+
+                    p = p + strlen(p) + 1;
+                }
+                delete[] buf;
+            }
+        }
+        else if (!strcmp(fourcc, "MWMO"))
+        {
+            if (size)
+            {
+                char* buf = new char[size];
+                ADT.read(buf, size);
+                char* p = buf;
+                int q = 0;
+                WmoInstansName = new string[size];
+                while (p < buf + size)
+                {
+                    string path(p);
+                    char* s = GetPlainName(p);
+                    fixnamen(s, strlen(s));
+                    fixname2(s, strlen(s));
+                    p = p + strlen(p) + 1;
+                    WmoInstansName[q++] = s;
+                }
+                delete[] buf;
+            }
+        }
+        else if (!strcmp(fourcc, "MDDF"))
+        {
+            if (size)
+            {
+                nMDX = (int)size / 36;
+                for (int i = 0; i < nMDX; ++i)
+                {
+                    uint32 id;
+                    ADT.read(&id, 4);
+                    ModelInstance inst(ADT, ModelInstansName[id].c_str(), map_num, tileX, tileY, dirfile);
+                }
+                delete[] ModelInstansName;
+            }
+        }
+        else if (!strcmp(fourcc, "MODF"))
+        {
+            if (size)
+            {
+                nWMO = (int)size / 64;
+                for (int i = 0; i < nWMO; ++i)
+                {
+                    uint32 id;
+                    ADT.read(&id, 4);
+                    WMOInstance inst(ADT, WmoInstansName[id].c_str(), map_num, tileX, tileY, dirfile);
+                }
+                delete[] WmoInstansName;
+            }
+        }
+        ADT.seek(nextpos);
+    }
+    ADT.close();
+    fclose(dirfile);
+
+    return true;
+}
+
+ADTFile::~ADTFile()
+{
+    ADT.close();
+}
+
diff -Nuar clean-build/maptools/vmap_extractor/adtfile.h temp-build/maptools/vmap_extractor/adtfile.h
--- clean-build/maptools/vmap_extractor/adtfile.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/adtfile.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,127 @@
+#ifndef ADT_H
+#define ADT_H
+
+#include "mpq_libmpq04.h"
+#include "wmo.h"
+#include "vmapexport.h"
+#include "model.h"
+#include "libmpq04/mpq.h"
+
+#define TILESIZE (533.33333f)
+#define CHUNKSIZE ((TILESIZE) / 16.0f)
+#define UNITSIZE (CHUNKSIZE / 8.0f)
+
+class Liquid;
+
+typedef struct
+{
+    float x;
+    float y;
+    float z;
+} svec;
+
+struct vec
+{
+    double x;
+    double y;
+    double z;
+};
+
+struct triangle
+{
+    vec v[3];
+};
+
+typedef struct
+{
+    float v9[16 * 8 + 1][16 * 8 + 1];
+    float v8[16 * 8][16 * 8];
+} Cell;
+
+typedef struct
+{
+    double v9[9][9];
+    double v8[8][8];
+    uint16 area_id;
+    //Liquid *lq;
+    float waterlevel[9][9];
+    uint8 flag;
+} chunk;
+
+typedef struct
+{
+    chunk ch[16][16];
+} mcell;
+
+struct MapChunkHeader
+{
+    uint32 flags;
+    uint32 ix;
+    uint32 iy;
+    uint32 nLayers;
+    uint32 nDoodadRefs;
+    uint32 ofsHeight;
+    uint32 ofsNormal;
+    uint32 ofsLayer;
+    uint32 ofsRefs;
+    uint32 ofsAlpha;
+    uint32 sizeAlpha;
+    uint32 ofsShadow;
+    uint32 sizeShadow;
+    uint32 areaid;
+    uint32 nMapObjRefs;
+    uint32 holes;
+    uint16 s1;
+    uint16 s2;
+    uint32 d1;
+    uint32 d2;
+    uint32 d3;
+    uint32 predTex;
+    uint32 nEffectDoodad;
+    uint32 ofsSndEmitters;
+    uint32 nSndEmitters;
+    uint32 ofsLiquid;
+    uint32 sizeLiquid;
+    float  zpos;
+    float  xpos;
+    float  ypos;
+    uint32 textureId;
+    uint32 props;
+    uint32 effectId;
+};
+
+
+class ADTFile
+{
+    public:
+        ADTFile(char* filename);
+        ~ADTFile();
+        int nWMO;
+        int nMDX;
+        string* WmoInstansName;
+        string* ModelInstansName;
+        bool init(uint32 map_num, uint32 tileX, uint32 tileY, StringSet& failedPaths);
+        //void LoadMapChunks();
+
+        //uint32 wmo_count;
+        /*
+            const mcell& Getmcell() const
+            {
+                return Mcell;
+            }
+        */
+    private:
+        //size_t mcnk_offsets[256], mcnk_sizes[256];
+        MPQFile ADT;
+        //mcell Mcell;
+        string Adtfilename;
+};
+
+const char* GetPlainName(const char* FileName);
+char* GetPlainName(char* FileName);
+char const* GetExtension(char const* FileName);
+void fixnamen(char* name, size_t len);
+void fixname2(char* name, size_t len);
+//void fixMapNamen(char *name, size_t len);
+
+#endif
diff -Nuar clean-build/maptools/vmap_extractor/CMakeLists.txt temp-build/maptools/vmap_extractor/CMakeLists.txt
--- clean-build/maptools/vmap_extractor/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/CMakeLists.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,22 @@
+# build setup currently only supports libmpq 0.4.x
+ADD_DEFINITIONS("-DUSE_LIBMPQ04")
+
+add_subdirectory(libmpq04)
+
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+
+add_executable(vmap_extractor
+    adtfile.cpp
+    dbcfile.cpp
+    model.cpp
+    mpq_libmpq.cpp
+    vmapexport.cpp
+    wdtfile.cpp
+    wmo.cpp
+    gameobject_extract.cpp
+)
+
+target_link_libraries(vmap_extractor mpq04 bz2 zlib_mt)
+
+install(TARGETS vmap_extractor DESTINATION ${CMAKE_INSTALL_PREFIX}/maptools)
+
diff -Nuar clean-build/maptools/vmap_extractor/dbcfile.cpp temp-build/maptools/vmap_extractor/dbcfile.cpp
--- clean-build/maptools/vmap_extractor/dbcfile.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/dbcfile.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,77 @@
+#include "dbcfile.h"
+#include "mpq_libmpq04.h"
+#undef min
+#undef max
+
+#include <cstdio>
+
+DBCFile::DBCFile(const std::string& filename) : filename(filename)
+{
+    data = NULL;
+}
+
+bool DBCFile::open()
+{
+    MPQFile f(filename.c_str());
+
+    // Need some error checking, otherwise an unhandled exception error occurs
+    // if people screw with the data path.
+    if (f.isEof() == true)
+        return false;
+
+    unsigned char header[4];
+    unsigned int na, nb, es, ss;
+
+    f.read(header, 4); // File Header
+
+    if (header[0] != 'W' || header[1] != 'D' || header[2] != 'B' || header[3] != 'C')
+    {
+        f.close();
+        data = NULL;
+        printf("Critical Error: An error occured while trying to read the DBCFile %s.", filename.c_str());
+        return false;
+    }
+
+    //assert(header[0]=='W' && header[1]=='D' && header[2]=='B' && header[3] == 'C');
+
+    f.read(&na, 4); // Number of records
+    f.read(&nb, 4); // Number of fields
+    f.read(&es, 4); // Size of a record
+    f.read(&ss, 4); // String size
+
+    recordSize = es;
+    recordCount = na;
+    fieldCount = nb;
+    stringSize = ss;
+    //assert(fieldCount*4 == recordSize);
+    assert(fieldCount * 4 >= recordSize);
+
+    data = new unsigned char[recordSize * recordCount + stringSize];
+    stringTable = data + recordSize * recordCount;
+    f.read(data, recordSize * recordCount + stringSize);
+    f.close();
+    return true;
+}
+
+DBCFile::~DBCFile()
+{
+    delete [] data;
+}
+
+DBCFile::Record DBCFile::getRecord(size_t id)
+{
+    assert(data);
+    return Record(*this, data + id * recordSize);
+}
+
+DBCFile::Iterator DBCFile::begin()
+{
+    assert(data);
+    return Iterator(*this, data);
+}
+
+DBCFile::Iterator DBCFile::end()
+{
+    assert(data);
+    return Iterator(*this, stringTable);
+}
diff -Nuar clean-build/maptools/vmap_extractor/dbcfile.h temp-build/maptools/vmap_extractor/dbcfile.h
--- clean-build/maptools/vmap_extractor/dbcfile.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/dbcfile.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,139 @@
+#ifndef DBCFILE_H
+#define DBCFILE_H
+
+#include <cassert>
+#include <string>
+
+class DBCFile
+{
+    public:
+        DBCFile(const std::string& filename);
+        ~DBCFile();
+
+        // Open database. It must be openened before it can be used.
+        bool open();
+
+        // TODO: Add a close function?
+
+        // Database exceptions
+        class Exception
+        {
+            public:
+                Exception(const std::string& message): message(message)
+                { }
+                virtual ~Exception()
+                { }
+                const std::string& getMessage() {return message;}
+            private:
+                std::string message;
+        };
+
+        //
+        class NotFound: public Exception
+        {
+            public:
+                NotFound(): Exception("Key was not found")
+                { }
+        };
+
+        // Iteration over database
+        class Iterator;
+        class Record
+        {
+            public:
+                Record& operator= (const Record& r)
+                {
+                    file = r.file;
+                    offset = r.offset;
+                    return *this;
+                }
+                float getFloat(size_t field) const
+                {
+                    assert(field < file.fieldCount);
+                    return *reinterpret_cast<float*>(offset + field * 4);
+                }
+                unsigned int getUInt(size_t field) const
+                {
+                    assert(field < file.fieldCount);
+                    return *reinterpret_cast<unsigned int*>(offset + (field * 4));
+                }
+                int getInt(size_t field) const
+                {
+                    assert(field < file.fieldCount);
+                    return *reinterpret_cast<int*>(offset + field * 4);
+                }
+                unsigned char getByte(size_t ofs) const
+                {
+                    assert(ofs < file.recordSize);
+                    return *reinterpret_cast<unsigned char*>(offset + ofs);
+                }
+                const char* getString(size_t field) const
+                {
+                    assert(field < file.fieldCount);
+                    size_t stringOffset = getUInt(field);
+                    assert(stringOffset < file.stringSize);
+                    //char * tmp = (char*)file.stringTable + stringOffset;
+                    //unsigned char * tmp2 = file.stringTable + stringOffset;
+                    return reinterpret_cast<char*>(file.stringTable + stringOffset);
+                }
+            private:
+                Record(DBCFile& file, unsigned char* offset): file(file), offset(offset) {}
+                DBCFile& file;
+                unsigned char* offset;
+
+                friend class DBCFile;
+                friend class Iterator;
+        };
+
+        /* Iterator that iterates over records */
+        class Iterator
+        {
+            public:
+                Iterator(DBCFile& file, unsigned char* offset):
+                    record(file, offset) {}
+                /// Advance (prefix only)
+                Iterator& operator++()
+                {
+                    record.offset += record.file.recordSize;
+                    return *this;
+                }
+                /// Return address of current instance
+                Record const& operator*() const { return record; }
+                const Record* operator->() const
+                {
+                    return &record;
+                }
+                /// Comparison
+                bool operator==(const Iterator& b) const
+                {
+                    return record.offset == b.record.offset;
+                }
+                bool operator!=(const Iterator& b) const
+                {
+                    return record.offset != b.record.offset;
+                }
+            private:
+                Record record;
+        };
+
+        // Get record by id
+        Record getRecord(size_t id);
+        /// Get begin iterator over records
+        Iterator begin();
+        /// Get begin iterator over records
+        Iterator end();
+        /// Trivial
+        size_t getRecordCount() const { return recordCount;}
+        size_t getFieldCount() const { return fieldCount; }
+
+    private:
+        std::string filename;
+        size_t recordSize;
+        size_t recordCount;
+        size_t fieldCount;
+        size_t stringSize;
+        unsigned char* data;
+        unsigned char* stringTable;
+};
+
+#endif
diff -Nuar clean-build/maptools/vmap_extractor/gameobject_extract.cpp temp-build/maptools/vmap_extractor/gameobject_extract.cpp
--- clean-build/maptools/vmap_extractor/gameobject_extract.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/gameobject_extract.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,111 @@
+#include "model.h"
+#include "dbcfile.h"
+#include "adtfile.h"
+#include "vmapexport.h"
+
+#include <algorithm>
+#include <stdio.h>
+
+bool ExtractSingleModel(std::string& origPath, std::string& fixedName, StringSet& failedPaths)
+{
+    char const* ext = GetExtension(GetPlainName(origPath.c_str()));
+
+    // < 3.1.0 ADT MMDX section store filename.mdx filenames for corresponded .m2 file
+    if (!strcmp(ext, ".mdx"))
+    {
+        // replace .mdx -> .m2
+        origPath.erase(origPath.length() - 2, 2);
+        origPath.append("2");
+    }
+    // >= 3.1.0 ADT MMDX section store filename.m2 filenames for corresponded .m2 file
+    // nothing do
+
+    fixedName = GetPlainName(origPath.c_str());
+
+    std::string output(szWorkDirWmo);                       // Stores output filename (possible changed)
+    output += "/";
+    output += fixedName;
+
+    if (FileExists(output.c_str()))
+        return true;
+
+    Model mdl(origPath);                                    // Possible changed fname
+    if (!mdl.open(failedPaths))
+        return false;
+
+    return mdl.ConvertToVMAPModel(output.c_str());
+}
+
+void ExtractGameobjectModels()
+{
+    printf("\n");
+    printf("Extracting GameObject models...\n");
+    DBCFile dbc("DBFilesClient\\GameObjectDisplayInfo.dbc");
+    if (!dbc.open())
+    {
+        printf("Fatal error: Invalid GameObjectDisplayInfo.dbc file format!\n");
+        exit(1);
+    }
+
+    std::string basepath = szWorkDirWmo;
+    basepath += "/";
+    std::string path;
+    StringSet failedPaths;
+
+    FILE* model_list = fopen((basepath + "temp_gameobject_models").c_str(), "wb");
+
+    for (DBCFile::Iterator it = dbc.begin(); it != dbc.end(); ++it)
+    {
+        path = it->getString(1);
+
+        if (path.length() < 4)
+            continue;
+
+        fixnamen((char*)path.c_str(), path.size());
+        char* name = GetPlainName((char*)path.c_str());
+        fixname2(name, strlen(name));
+
+        char const* ch_ext = GetExtension(name);
+        if (!ch_ext)
+            continue;
+
+        //strToLower(ch_ext);
+
+        bool result = false;
+        if (!strcmp(ch_ext, ".wmo"))
+        {
+            result = ExtractSingleWmo(path);
+        }
+        else if (!strcmp(ch_ext, ".mdl"))
+        {
+            // TODO: extract .mdl files, if needed
+            continue;
+        }
+        else //if (!strcmp(ch_ext, ".mdx") || !strcmp(ch_ext, ".m2"))
+        {
+            std::string fixedName;
+            result = ExtractSingleModel(path, fixedName, failedPaths);
+        }
+
+        if (result)
+        {
+            uint32 displayId = it->getUInt(0);
+            uint32 path_length = strlen(name);
+            fwrite(&displayId, sizeof(uint32), 1, model_list);
+            fwrite(&path_length, sizeof(uint32), 1, model_list);
+            fwrite(name, sizeof(char), path_length, model_list);
+        }
+    }
+
+    fclose(model_list);
+
+    if (!failedPaths.empty())
+    {
+        printf("Warning: Some models could not be extracted, see below\n");
+        for (StringSet::const_iterator itr = failedPaths.begin(); itr != failedPaths.end(); ++itr)
+            printf("Could not find file of model %s\n", itr->c_str());
+        printf("A few of these warnings are expected to happen, so be not alarmed!\n");
+    }
+
+    printf("Done!\n");
+}
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/CMakeLists.txt temp-build/maptools/vmap_extractor/libmpq04/CMakeLists.txt
--- clean-build/maptools/vmap_extractor/libmpq04/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/CMakeLists.txt	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,4 @@
+add_library (mpq04 common.c explode.c extract.c huffman.c mpq.c wave.c)
+
+target_link_libraries (mpq04 zlib_mt)
+
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/common.c temp-build/maptools/vmap_extractor/libmpq04/common.c
--- clean-build/maptools/vmap_extractor/libmpq04/common.c	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/common.c	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,220 @@
+/*
+ *  common.c -- shared functions used by mpq-tools.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* generic includes. */
+#include <ctype.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+/* libmpq main includes. */
+#include "mpq.h"
+#include "mpq-internal.h"
+
+/* libmpq generic includes. */
+#include "extract.h"
+
+#include "common.h"
+
+/* the global shared decryption buffer. it's a static array compiled into the
+ * library, and can be re-created by compiling and running crypt_buf_gen.c
+ */
+#include "crypt_buf.h"
+
+/* function to return the hash to a given string. */
+uint32_t libmpq__hash_string(const char *key, uint32_t offset) {
+
+	/* some common variables. */
+	uint32_t seed1 = 0x7FED7FED;
+	uint32_t seed2 = 0xEEEEEEEE;
+
+	/* one key character. */
+	uint32_t ch;
+
+	/* prepare seeds. */
+	while (*key != 0) {
+		ch    = toupper(*key++);
+		seed1 = crypt_buf[offset + ch] ^ (seed1 + seed2);
+		seed2 = ch + seed1 + seed2 + (seed2 << 5) + 3;
+	}
+
+	return seed1;
+}
+
+/* function to encrypt a block. */
+int32_t libmpq__encrypt_block(uint32_t *in_buf, uint32_t in_size, uint32_t seed) {
+
+	/* some common variables. */
+	uint32_t seed2 = 0xEEEEEEEE;
+	uint32_t ch;
+
+	/* we're processing the data 4 bytes at a time. */
+	for (; in_size >= 4; in_size -= 4) {
+		seed2    += crypt_buf[0x400 + (seed & 0xFF)];
+		ch        = *in_buf ^ (seed + seed2);
+		seed      = ((~seed << 0x15) + 0x11111111) | (seed >> 0x0B);
+		seed2     = *in_buf + seed2 + (seed2 << 5) + 3;
+		*in_buf++ = ch;
+	}
+
+	/* if no error was found, return decrypted bytes. */
+	return LIBMPQ_SUCCESS;
+}
+
+
+/* function to decrypt a block. */
+int32_t libmpq__decrypt_block(uint32_t *in_buf, uint32_t in_size, uint32_t seed) {
+
+	/* some common variables. */
+	uint32_t seed2 = 0xEEEEEEEE;
+	uint32_t ch;
+
+	/* we're processing the data 4 bytes at a time. */
+	for (; in_size >= 4; in_size -= 4) {
+		seed2    += crypt_buf[0x400 + (seed & 0xFF)];
+		ch        = *in_buf ^ (seed + seed2);
+		seed      = ((~seed << 0x15) + 0x11111111) | (seed >> 0x0B);
+		seed2     = ch + seed2 + (seed2 << 5) + 3;
+		*in_buf++ = ch;
+	}
+
+	/* if no error was found, return decrypted bytes. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* function to detect decryption key. */
+int32_t libmpq__decrypt_key(uint8_t *in_buf, uint32_t in_size, uint32_t block_size) {
+
+	/* some common variables. */
+	uint32_t saveseed1;
+
+	/* temp = seed1 + seed2 */
+	uint32_t temp;
+	uint32_t i = 0;
+
+	/* temp = seed1 + buffer[0x400 + (seed1 & 0xFF)] */
+	temp = (*(uint32_t *)in_buf ^ in_size) - 0xEEEEEEEE;
+
+	/* try all 255 possibilities. */
+	for (i = 0; i < 0x100; i++) {
+
+		/* some common variables. */
+		uint32_t seed1;
+		uint32_t seed2 = 0xEEEEEEEE;
+		uint32_t ch;
+		uint32_t ch2;
+
+		/* try the first uint32_t's (we exactly know the value). */
+		seed1  = temp - crypt_buf[0x400 + i];
+		seed2 += crypt_buf[0x400 + (seed1 & 0xFF)];
+		ch     = ((uint32_t *)in_buf)[0] ^ (seed1 + seed2);
+
+		if (ch != in_size) {
+			continue;
+		}
+
+		/* add one because we are decrypting block positions. */
+		saveseed1 = seed1 + 1;
+		ch2       = ch;
+
+		/*
+		 *  if ok, continue and test the second value. we don't know exactly the value,
+		 *  but we know that the second one has lower 16 bits set to zero (no compressed
+		 *  block is larger than 0xFFFF bytes)
+		 */
+		seed1  = ((~seed1 << 0x15) + 0x11111111) | (seed1 >> 0x0B);
+		seed2  = ch + seed2 + (seed2 << 5) + 3;
+		seed2 += crypt_buf[0x400 + (seed1 & 0xFF)];
+		ch     = ((uint32_t *)in_buf)[1] ^ (seed1 + seed2);
+
+		/* check if we found the file seed. */
+		if ((ch - ch2) <= block_size) {
+
+			/* file seed found, so return it. */
+			return saveseed1;
+		}
+	}
+
+	/* if no file seed was found return with error. */
+	return LIBMPQ_ERROR_DECRYPT;
+}
+
+/* function to decompress or explode a block from mpq archive. */
+int32_t libmpq__decompress_block(uint8_t *in_buf, uint32_t in_size, uint8_t *out_buf, uint32_t out_size, uint32_t compression_type) {
+
+	/* some common variables. */
+	int32_t tb = 0;
+
+	/* check if buffer is not compressed. */
+	if (compression_type == LIBMPQ_FLAG_COMPRESS_NONE) {
+
+		/* no compressed data, so copy input buffer to output buffer. */
+		memcpy(out_buf, in_buf, out_size);
+
+		/* store number of bytes copied. */
+		tb = out_size;
+	}
+
+	/* check if one compression mode is used. */
+	else if (compression_type == LIBMPQ_FLAG_COMPRESS_PKZIP ||
+	    compression_type == LIBMPQ_FLAG_COMPRESS_MULTI) {
+
+		/* check if block is really compressed, some blocks have set the compression flag, but are not compressed. */
+		if (in_size < out_size) {
+
+			/* check if we are using pkzip compression algorithm. */
+			if (compression_type == LIBMPQ_FLAG_COMPRESS_PKZIP) {
+
+				/* decompress using pkzip. */
+				if ((tb = libmpq__decompress_pkzip(in_buf, in_size, out_buf, out_size)) < 0) {
+
+					/* something on decompression failed. */
+					return tb;
+				}
+			}
+
+			/* check if we are using multiple compression algorithm. */
+			else if (compression_type == LIBMPQ_FLAG_COMPRESS_MULTI) {
+
+				/*
+				 *  check if it is a file compressed by blizzard's multiple compression, note that storm.dll
+				 *  version 1.0.9 distributed with warcraft 3 passes the full path name of the opened archive
+				 *  as the new last parameter.
+				 */
+				if ((tb = libmpq__decompress_multi(in_buf, in_size, out_buf, out_size)) < 0) {
+
+					/* something on decompression failed. */
+					return tb;
+				}
+			}
+		} else {
+
+			/* block has set compression flag, but is not compressed, so copy data to output buffer. */
+			memcpy(out_buf, in_buf, out_size);
+
+			/* save the number of transferred bytes. */
+			tb = in_size;
+		}
+	}
+
+	/* if no error was found, return transferred bytes. */
+	return tb;
+}
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/common.h temp-build/maptools/vmap_extractor/libmpq04/common.h
--- clean-build/maptools/vmap_extractor/libmpq04/common.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/common.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,60 @@
+/*
+ *  common.h -- header functions used by mpq-tools.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */       
+
+#ifndef _COMMON_H
+#define _COMMON_H
+
+/* function to return the hash to a given string. */
+uint32_t libmpq__hash_string(
+	const char	*key,
+	uint32_t	offset
+);
+
+/* function to encrypt a block. */
+int32_t libmpq__encrypt_block(
+	uint32_t	*in_buf,
+	uint32_t	in_size,
+	uint32_t	seed
+);
+
+/* function to decrypt a block. */
+int32_t libmpq__decrypt_block(
+	uint32_t	*in_buf,
+	uint32_t	in_size,
+	uint32_t	seed
+);
+
+/* function to detect decryption key. */
+int32_t libmpq__decrypt_key(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint32_t	block_size
+);
+
+/* function to decompress or explode block from archive. */
+int32_t libmpq__decompress_block(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint8_t		*out_buf,
+	uint32_t	out_size,
+	uint32_t	compression_type
+);
+
+#endif						/* _COMMON_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/config.h temp-build/maptools/vmap_extractor/libmpq04/config.h
--- clean-build/maptools/vmap_extractor/libmpq04/config.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/config.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,81 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#define HAVE_FSEEKO 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `bz2' library (-lbz2). */
+#define HAVE_LIBBZ2 1
+
+/* Define to 1 if you have the `z' library (-lz). */
+#define HAVE_LIBZ 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "libmpq"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "mbroemme@plusserver.de"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libmpq"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "libmpq 0.4.2"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "libmpq"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.4.2"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "0.4.2"
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+/* #undef _LARGEFILE_SOURCE */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/crypt_buf.h temp-build/maptools/vmap_extractor/libmpq04/crypt_buf.h
--- clean-build/maptools/vmap_extractor/libmpq04/crypt_buf.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/crypt_buf.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,217 @@
+/* DO NOT CHANGE! this file is auto-generated by crypt_buf_gen.c */
+static const uint32_t crypt_buf[0x500] = {
+	0x55c636e2, 0x02be0170, 0x584b71d4, 0x2984f00e, 0xb682c809, 0x91cf876b,
+	0x775a9c24, 0x597d5ca5, 0x5a1afeb2, 0xd3e9ce0d, 0x32cdcdf8, 0xb18201cd,
+	0x3cce05ce, 0xa55d13be, 0xbb0afe71, 0x9376ab33, 0x848f645e, 0x87e45a45,
+	0x45b86017, 0x5e656ca8, 0x1b851a95, 0x2542dbd7, 0xab4df9e4, 0x5976ae9b,
+	0x6c317e7d, 0xcddd2f94, 0x3c3c13e5, 0x335b1371, 0x31a592ca, 0x51e4fc4c,
+	0xf7db5b2f, 0x8abdbe41, 0x8beaa674, 0x20d6b319, 0xde6c9a9d, 0xc5ac84e5,
+	0x445a5feb, 0x94958cb0, 0x1e7d3847, 0xf35d29b0, 0xca5cceda, 0xb732c8b5,
+	0xfdcc41dd, 0x0edcec16, 0x9d01feae, 0x1165d38e, 0x9ee193c8, 0xbf33b13c,
+	0x61bc0dfc, 0xef3e7be9, 0xf8d4d4c5, 0xc79b7694, 0x5a255943, 0x0b3dd20a,
+	0x9d1ab5a3, 0xcfa8ba57, 0x5e6d7069, 0xcb89b731, 0x3dc0d15b, 0x0d4d7e7e,
+	0x97e37f2b, 0xfefc2bb1, 0xf95b16b5, 0x27a55b93, 0x45f22729, 0x4c986630,
+	0x7c666862, 0x5fa40847, 0xa3f16205, 0x791b7764, 0x386b36d6, 0x6e6c3fef,
+	0xc75855db, 0x4abc7dc7, 0x4a328f9b, 0xcef20c0f, 0x60b88f07, 0xf7bb4b8f,
+	0x830b5192, 0x94f711ec, 0x20250752, 0x399d21a3, 0xe5c0840d, 0xe76cffa5,
+	0x624fab29, 0x5df133e6, 0x83e0b9b8, 0xc5796bfb, 0x4a7ab2d0, 0xba59a821,
+	0x03a81e4c, 0xcd3adfdb, 0x32b26b8c, 0x8e35c533, 0x9e6300e9, 0x8cf92ac5,
+	0x880d18eb, 0x131a53b3, 0x2ed2dc64, 0xb23257c1, 0xa06450c1, 0x1b92cb8e,
+	0x72ed730e, 0x19a685f0, 0x82836483, 0x42d94e8a, 0xee9bd6f6, 0x556d0b6a,
+	0xba65589a, 0xde24cce4, 0x53329f6c, 0xc754fe8b, 0x503d2dc7, 0x10027ba4,
+	0xd3b60a8b, 0x68e68d83, 0x0a9128a9, 0x595fa35f, 0x0b03b5be, 0x150a45c4,
+	0xb1629cce, 0xe5f7497b, 0x8a7098a4, 0xb8233e69, 0x8ea0f978, 0x5b579970,
+	0xeab14318, 0x4b28b263, 0xb6766cef, 0x06782877, 0x155c6dd0, 0xc711333c,
+	0xf819cedf, 0x00eb1d68, 0xd6fffa6e, 0x439e5962, 0xd765d6db, 0xcb0bcee9,
+	0x6d3c5647, 0x965466f3, 0x0ca983c9, 0x74ecc1ce, 0xfc0563b6, 0x42b08fee,
+	0xc5b38853, 0xfe502ceb, 0x7b432faf, 0xc309e610, 0x2c3997d8, 0x43774654,
+	0x15bd9d2c, 0xed6a420d, 0xc7ff520c, 0xb8a97fd1, 0x5e4d60cc, 0xb9738d11,
+	0xda2181ff, 0x73ac2597, 0x3a8eec8d, 0xac85e779, 0xf3f975d6, 0xb9fe7b91,
+	0x0f155d1e, 0x2860b6dd, 0x835977cb, 0xb0607436, 0x9cab7f6b, 0x8ab91186,
+	0xc12b51e9, 0x20084e8b, 0x44ba8ead, 0xa542b130, 0x82bcd5c4, 0xcc747f4e,
+	0x0f1909d8, 0xda242e1c, 0x6f7d1aa0, 0xd2626486, 0x88d0781e, 0xab695ccd,
+	0xfa569145, 0xb4feb55c, 0xbe47e896, 0xe70a7a88, 0xd56185a2, 0xacf4c871,
+	0x09282332, 0x1ddeeaa8, 0x590c7adb, 0xf4a97667, 0xbfd85705, 0x0ea77ccc,
+	0xa9f85364, 0x83195869, 0x8bfb041a, 0xdb842f5c, 0xd6f0f315, 0xa7756ea7,
+	0x0a51b439, 0xa9edf8a3, 0xd9084e2f, 0x827407f8, 0xd4ac8284, 0x09739d0d,
+	0xb3bb6cfc, 0xd539c77d, 0x6bbc9ac0, 0x35c641aa, 0x934c96b0, 0xd17af317,
+	0x29c6baef, 0xb275cdac, 0xd72662de, 0x9f5c2544, 0xc1a98f75, 0xd98e8f9a,
+	0x47bd5c86, 0x70c610a6, 0xb5482ed4, 0x23b9c68c, 0x3c1bae66, 0x69556e7f,
+	0xd902f5e0, 0x653d195b, 0xde6541fb, 0x07bcc6ac, 0xc6ee7788, 0x801534d4,
+	0x2c1f35c0, 0xd9de614d, 0xbdccac85, 0xb4d4a0da, 0x242d549b, 0x9d964796,
+	0xb9ceb982, 0x59fa99a9, 0xd8986cc1, 0x9e90c1a1, 0x01bbd82f, 0xd7f1c5fd,
+	0xdd847eba, 0x883d305d, 0x25f13152, 0x4a92694d, 0x77f1e601, 0x8024e6e7,
+	0x02a5f53d, 0x9c3ef4d9, 0xaf403ccc, 0xe2ad03c0, 0x46edf6ec, 0x6f9bd3e6,
+	0xcc24ad7a, 0x47afab12, 0x82298df7, 0x708c9eec, 0x76f8c1b1, 0xb39459d2,
+	0x3f1e26d9, 0xe1811be7, 0x56ed1c4d, 0xc9d18af8, 0xe828060e, 0x91cada2e,
+	0x5ccbf9b7, 0xf1a552d4, 0x3c9d4343, 0xe1008785, 0x2adfeebf, 0xf90240a0,
+	0x3d08cce7, 0x426e6fb0, 0x573c984f, 0x13a843ae, 0x406b7439, 0x636085d9,
+	0x5000ba9a, 0xad4a47ab, 0xaf001d8d, 0x419907ae, 0x185c8f96, 0xe5e9ed4d,
+	0x61764133, 0xd3703d97, 0xac98f0c6, 0xdbc3a37c, 0x85f010c4, 0x90491e32,
+	0xf12e18bf, 0xc88c96e1, 0xd3fbd6d9, 0xe3c28b08, 0xd5bf08cc, 0xb1e78859,
+	0x2546ddcf, 0xb030b200, 0xaafd2811, 0x55b22d21, 0xd38bf567, 0x469c7a2b,
+	0x5ad05792, 0xa1a5981e, 0x7dfb8384, 0x34d1ca0a, 0x7eb0dbe0, 0xd61ce0f6,
+	0x398068b7, 0xe6406d1f, 0x95ae6b47, 0xe4281230, 0xb0843061, 0xa70a3a68,
+	0xe340f625, 0x72dcbffd, 0x8eb8afcd, 0x18b6661f, 0x17ef5a5c, 0x000c5b22,
+	0x6ba13836, 0x6165e383, 0x74481c5b, 0xe56f0711, 0xa26f5024, 0x5ff22e60,
+	0x31a5e829, 0xa1094bf0, 0xc680ec6c, 0x8cf327d7, 0xebf1348a, 0x6a227d2f,
+	0x74065184, 0x8df65112, 0x2bbd05ee, 0xe4d00ed6, 0x2980ee1a, 0x6ae1da73,
+	0xe84614da, 0x6c9906ab, 0xcf8e02db, 0xd3723e97, 0x92f66caf, 0xac8491c7,
+	0xaec65696, 0xb98997cf, 0xfa16c762, 0x6d73c65f, 0x205d22a6, 0x4dd3aaa5,
+	0x2deb6bc0, 0x9f37686c, 0x71a5282b, 0x376bb9e0, 0x7fff2a1b, 0xde67982f,
+	0x9cbf33ce, 0x2e6dab37, 0x6e3424b9, 0x0ee143bc, 0x832a60d9, 0xbb6329e1,
+	0x13f6befd, 0x5965fb84, 0xf60b233c, 0x3d695183, 0x433224a1, 0xb5d9cae5,
+	0x82459bab, 0x9f21b311, 0xaf6c5247, 0xb447b13a, 0x7b2676c3, 0xc38979cd,
+	0x8526ae25, 0xc550ad5b, 0x685099a7, 0x65e9c2bd, 0xe5c6dc36, 0xe10b37a9,
+	0x88016878, 0xce81d4e4, 0x24d6fc80, 0x4106152d, 0x6d4f5f90, 0xc4dc74be,
+	0xdb48676c, 0x6cb569b7, 0xf3bf598f, 0x042b08d9, 0x02ccb2de, 0xb1056f65,
+	0x47994af4, 0xfa141ba4, 0x9376ab2e, 0x07a76737, 0x75e7e6fc, 0x449d80a1,
+	0x03b7259d, 0xf6df358a, 0x5a75d5b9, 0x47286923, 0x3b1a30ef, 0xeebe3d6a,
+	0x9db1aa00, 0x007a90d9, 0x24667071, 0x019c73cf, 0x69039bcd, 0x95900744,
+	0x6518b1eb, 0x6905f202, 0xee3951b2, 0xe141fca9, 0x797fa832, 0x5a95e55b,
+	0xd6263b15, 0x5b61f394, 0x897acb1c, 0x005f83a9, 0x22420f71, 0xf495176e,
+	0x7e138f3d, 0x1392e384, 0x373bf7aa, 0x8e512816, 0xa960b3ca, 0x0474d74c,
+	0xffacd6d7, 0x2ef5ed9e, 0x60992aaa, 0x7e690e99, 0x23c0749d, 0xd8e29105,
+	0x555d5909, 0x15631bfe, 0xa69c5a1c, 0x501017ca, 0x99438048, 0x38733ac7,
+	0xe682e2c8, 0xd4655fd6, 0x956e4c04, 0x347df643, 0x2f4b177b, 0x93ed3aa4,
+	0xa77e1dd5, 0x7ae55702, 0xd2a52fd9, 0xef8ba18c, 0xb7d3c1ee, 0x8078ba8d,
+	0xab5aaadb, 0x752be08f, 0x068b31c1, 0x078aae3c, 0xaa5a8343, 0x123d9268,
+	0x2ceaee43, 0x8ebdb239, 0x650251f3, 0x04883648, 0x8c62e12e, 0x12b32167,
+	0xe5112e9a, 0x10002548, 0x3e7a818d, 0x077e5327, 0xf140cc21, 0x6ce7d75d,
+	0x9b99f9a5, 0x3215741c, 0xb6aadbae, 0x738768dc, 0x82a3742f, 0x76517020,
+	0xdd872ad8, 0x9d0902b2, 0x7d1a6b04, 0x49381592, 0x63a652a5, 0x0c15e626,
+	0xe22f70d6, 0x01e84385, 0xb29de134, 0x20c5000e, 0xe961f443, 0x2d31662e,
+	0x3ce6bc28, 0x34f9dd94, 0xfa45de53, 0x497588bd, 0x9468215b, 0x0777fa5c,
+	0x6f7114c0, 0xe0e82694, 0xe4371986, 0x57112de2, 0xe0cac289, 0xf2a3cee0,
+	0x6a41e1b9, 0xbfcea77d, 0xf927fd52, 0x69747d98, 0xbea76cdb, 0x8dd39557,
+	0x04db5ece, 0x2a0885c8, 0x3be4e8ee, 0x21d785dc, 0x09de7c0e, 0x3258ea33,
+	0x51922982, 0xee8dd024, 0x3df6965d, 0x30c1237b, 0xf7f6686a, 0x9faca186,
+	0x7c400076, 0x85acef8a, 0xf4b6d220, 0xddc3481c, 0x439eaec4, 0x717bbe63,
+	0x8259faa7, 0xd682bd68, 0x932a8610, 0x38bf0a7f, 0x6212e2c7, 0x88ee3168,
+	0xb3c27047, 0x6133cb1e, 0x15295506, 0x5ae66246, 0x1d208ddd, 0xa91d3dba,
+	0xc315968d, 0x6aa2664b, 0x716d0cca, 0x891f4956, 0x80866bff, 0xbd56c847,
+	0x9093425a, 0x28dd9e87, 0x84ef3e08, 0x690a49d6, 0x6a7eff82, 0xabcfe400,
+	0x3d3be5ca, 0x381b650c, 0x4b7c8622, 0x3e0246f3, 0xa3561654, 0x9488865c,
+	0x3aef1bf2, 0x5e5d68a2, 0xd32f1ddc, 0x51972bf0, 0x177a213b, 0x469375c2,
+	0x37640bd0, 0xfc3324c8, 0x07091a09, 0x2d63d3fb, 0x2153f023, 0x48223875,
+	0x61a55826, 0x8c136538, 0x49f71d98, 0x84c7d51e, 0x85551a73, 0x13d604c5,
+	0xd701a626, 0x87b844ca, 0x741eb29d, 0x2a2c977c, 0xc797ca03, 0x6c4085d7,
+	0x2dacf79b, 0x734fa2eb, 0xcc290557, 0xfa1e75e4, 0x06b29a27, 0xbece2a7a,
+	0x70a4554b, 0xc935942e, 0xa764bbc1, 0x1fe391d6, 0x7807f0c2, 0x40606ed9,
+	0xe5153086, 0xe91d7dd2, 0xed5d3ba9, 0xaa14b64a, 0x83b24dd9, 0xec1ff5cd,
+	0xba33ead3, 0xe4ef735c, 0xbc062438, 0xd8bfd523, 0x473d1e04, 0x2007f8a7,
+	0xb02903ed, 0x86ea8ada, 0x95ab69cf, 0xfd1f9809, 0x9cb3d8bb, 0x51f45958,
+	0x9cdd4276, 0xc245865e, 0x8f0c836b, 0x4ee7dc07, 0xf6368d9d, 0xef2c1dc1,
+	0xee56b54b, 0xbd62ce2f, 0xf4916aad, 0xc81cb594, 0x41729f49, 0x24bef0a4,
+	0xdef487a9, 0x222e05b8, 0x8d3bf5c6, 0x11b55009, 0xad09d2b3, 0x19db9fd1,
+	0xd7427085, 0x33dbfc8b, 0x526b9378, 0x790e1bc8, 0xb2998a00, 0xa5641703,
+	0x0676d249, 0x6b9185cc, 0x30e4348f, 0x82c52f65, 0x57c7dc24, 0x489c1ecd,
+	0x9fcab02a, 0x56d61117, 0xfe869cac, 0x55fc5140, 0x7fbbb382, 0x9e5afc79,
+	0x10047c99, 0xfc9f5984, 0x56587e2d, 0xb98193f0, 0x98fe5e8e, 0x29b15b6b,
+	0x9561f055, 0xbb0caa25, 0x1e4ecc15, 0x23f5393b, 0x0845b458, 0xceff67ca,
+	0xb099900c, 0x00b1564f, 0x39eef3d1, 0xfcc1bf84, 0xac8893b5, 0x6484bf0e,
+	0x91c02ab3, 0x8c0c0c70, 0x686fa8c6, 0xe171bed6, 0xdfae37df, 0xd5a1a4e7,
+	0xe3eb49a1, 0x5e6014e0, 0x205b21ac, 0xfd58b3da, 0x2e7c07cd, 0xef2cc85a,
+	0xd7587b46, 0xf417847d, 0x8a30cec1, 0x70984f6c, 0xf0b63388, 0xc220c98d,
+	0xede62936, 0x92c0a7b3, 0x1ef371e8, 0x2005f7af, 0x91a47265, 0xb0cf5504,
+	0xd500aba8, 0xcb5c4bd3, 0x9b3bcbc3, 0xcf6644b5, 0xce9488ef, 0x003fc96e,
+	0xaa42222f, 0x4844f3d0, 0x4db89d77, 0x08681aae, 0x662f3a28, 0x761552db,
+	0x1df7a17a, 0x93feed9a, 0xcc496a4f, 0xa217cfcd, 0x3ba3c930, 0x268f7e77,
+	0x0797b4a1, 0x8bebfc51, 0x068930c4, 0x16c874e2, 0xc242da24, 0xfb229f76,
+	0xa0795b02, 0x689fc036, 0x17a73732, 0xd21aec00, 0xac00a692, 0x5b217f18,
+	0xae421624, 0x2bc05cc0, 0x48c1db7a, 0x4f4e63b4, 0x1667f04e, 0x34020f94,
+	0x972b2555, 0x9a07355b, 0x01665970, 0x7db60c6f, 0x3ad7103b, 0x5c3d09c0,
+	0xeea3dada, 0x88c21c10, 0x102436d7, 0x6a3b3400, 0xeb523c4c, 0xfb97d896,
+	0x964cb86b, 0xdd878038, 0x0529da4d, 0x0b1468a5, 0x18739ac8, 0xf7f26668,
+	0xf64f4471, 0x5c14f5c3, 0x44a081fb, 0x39ac7e37, 0x8a17c26b, 0x868f5e67,
+	0x3931978d, 0x6edf7817, 0x4951cc67, 0x943407f3, 0xcc5e748f, 0x2b7ee729,
+	0xcbb320f0, 0x11fec8e7, 0xfccfc658, 0x03454354, 0x373aa1ec, 0x1d58fe9a,
+	0x064710ae, 0xa88aa0ba, 0xd183a23e, 0x40d150a3, 0xf531b8d1, 0xa7d99f85,
+	0x11838cd5, 0xb19e64b3, 0x3d67a5e9, 0xb02c5ac6, 0x99b9b9e8, 0x4c202b7a,
+	0x15f261d3, 0xa84c2d0d, 0x50f185a6, 0x33ba41d5, 0x39791013, 0x4baff44e,
+	0xeeeeaa1c, 0xe0488314, 0x559ccd2b, 0xa104f445, 0x636f37c4, 0x264d5e3b,
+	0x75c17f35, 0x75424131, 0xbb115739, 0x74fe755a, 0x7d3a7aa6, 0x2d8be784,
+	0x83ed154a, 0xfc2673d8, 0x44dd4a7f, 0x79056cc8, 0x82cc8831, 0x9d3c1b7c,
+	0xe9453bfa, 0x24315694, 0x661f3253, 0x75549f5c, 0xbb2b63ed, 0x67e00d96,
+	0xf48966c7, 0x0d7bea56, 0xc25f92ef, 0xa947a79d, 0xde4adf6f, 0xac0f0342,
+	0xd3eb246b, 0xa4aa118e, 0x3c3e6a46, 0x457f4441, 0xa50a406f, 0x6c508d9f,
+	0xe9ac18e7, 0x1ecdb4ba, 0x39ac7e3a, 0x7fb304fa, 0x6f38f8e8, 0x4aecea6d,
+	0x61035e73, 0x81708907, 0xebc07205, 0x90fd7614, 0xb52d217f, 0x6c4de195,
+	0x1dd49084, 0x64ee482c, 0x94c7a521, 0x540c09d8, 0x75df8dd5, 0x414131f7,
+	0x3698fd76, 0xf784db4f, 0xf8c97a03, 0x048f39b9, 0x3bf4f0bd, 0x8cb50992,
+	0x9b58d9ee, 0xe5ab79cc, 0x9a5f6052, 0xbd9591b0, 0xfad2232b, 0x5a632254,
+	0x0286e618, 0x8ad3c8f7, 0xe4060176, 0x754c4617, 0x5c10490b, 0x6f7d6fff,
+	0x2187b42a, 0x5775095b, 0x02f4c663, 0x5a5dca06, 0xfe4ad4c7, 0x53e19f7d,
+	0x59ff46b5, 0xbcc42ba5, 0xfd2f4a97, 0xbed6d905, 0x95629b6b, 0x21a1c0db,
+	0xaa10b45d, 0xe6ef6d58, 0x2892cf4d, 0x9fed6c10, 0x1e386bf7, 0x9be0c6e8,
+	0x2b2f15ef, 0x19f5ac7b, 0x7aff0e72, 0x31da576f, 0x30252cb4, 0x577960ac,
+	0x166e9e5a, 0xa9374a61, 0x71369c96, 0x7ff826ae, 0xe8175326, 0xcabbfd33,
+	0x0191190e, 0x699d3c3e, 0x36b40b22, 0xb3950513, 0x9b889bfa, 0xa52a5007,
+	0xac290fed, 0x3b4e4a4f, 0xb753d8d6, 0x3c531f22, 0x582f6427, 0xa9cd93a9,
+	0x546e39ae, 0x242faad2, 0xd2e0f747, 0x09f6325d, 0x59d48719, 0xad7eb66e,
+	0xd5512878, 0x56debf9d, 0x5107e5a5, 0xf1c00aa4, 0x814ccca8, 0x600d90f0,
+	0x9be97619, 0x915fa5f2, 0x2b5628dd, 0xa33d5f5a, 0x595df7c1, 0x6966215d,
+	0x50ec8337, 0xf1d21372, 0x0ee2eefb, 0xad9e70b7, 0xab0d2fe4, 0xcf277b5d,
+	0x62585a2c, 0x835a7844, 0x74b1fa6b, 0x49baffd5, 0x2ea9c864, 0x129311a8,
+	0xbdfa1867, 0x83ca5997, 0x9d1db719, 0x84bb79e6, 0x9e3f99f2, 0x313f6101,
+	0x1b99245b, 0xd15d8fb2, 0xcef90f81, 0x2945268d, 0xdbbcf573, 0xb1021886,
+	0x9ee7ec1d, 0x1cf824f7, 0x7eaa2e32, 0x69c0a2b5, 0x7494419c, 0xe253d7d3,
+	0x48da3d12, 0x45b8b571, 0xdb4d147a, 0xd82d8dde, 0x265d10a2, 0xb0a6eb9a,
+	0x7e1c93a6, 0x36fe2f46, 0xdcad6b00, 0x05439191, 0xb0ce5484, 0x61d1c309,
+	0x8da62a03, 0x06d0fe2f, 0xbac6dd3c, 0xca2006f3, 0x8321b1af, 0x0411a6f3,
+	0xe8918eac, 0x21a2c152, 0x91c0d54f, 0x6aaa14fa, 0xdd22a440, 0x88cb2075,
+	0x7a4eb813, 0x67afa071, 0xd8d98c9c, 0x31f10d47, 0x6ff1a8a8, 0x2faaf0a1,
+	0x48a221bb, 0x3be6948b, 0xaa79e79b, 0x0ea7278c, 0x7a3857ef, 0x49b7fe55,
+	0xd51cb931, 0x041c018d, 0x00b90501, 0x45ea7881, 0x8fc1dbcf, 0xb80b32a9,
+	0xabacd2e9, 0x677bdc40, 0xecace542, 0x6d6514eb, 0x31c09ff7, 0x5e6c1abd,
+	0x1c391d0f, 0x0e9d77f1, 0x7119392d, 0x6be9b0ba, 0x6194fa77, 0x45e62148,
+	0x42234af2, 0xc3239d66, 0x939cbdbc, 0x56200d9c, 0x6b275208, 0x001a61f3,
+	0xccc2a546, 0x4b722be0, 0xee25f2b7, 0x6d86cf9e, 0xaa6be0cd, 0x4dcda7b6,
+	0x78d4aa13, 0x36ea7ad9, 0x3f29d700, 0xdeea2d84, 0x6a6af5bd, 0x18afb81c,
+	0xd8e4e73c, 0x8aa708ba, 0x658b94d9, 0xa676478c, 0xcfa10c22, 0x25593c74,
+	0x8d962235, 0x5f980270, 0x3df6ebc0, 0x8e7d92fa, 0xc3ee55e1, 0xd5f72447,
+	0x02b0fa95, 0x52b0b520, 0x70d2c11f, 0x3a6fdd6c, 0x193aa698, 0x5496f7d5,
+	0x4208931b, 0x7a4106ec, 0x83e86840, 0xf49b6f8c, 0xba3d9a51, 0x55f54ddd,
+	0x2de51372, 0x9afb571b, 0x3ab35406, 0xad64ff1f, 0xc77764fe, 0x7f864466,
+	0x416d9cd4, 0xa2489278, 0xe30b86e4, 0x0b5231b6, 0xba67aed6, 0xe5ab2467,
+	0x60028b90, 0x1d9e20c6, 0x2a7c692a, 0x6b691cdb, 0x9e51f817, 0x9b763dec,
+	0x3d29323f, 0xcfe12b68, 0x754b459b, 0xa2238047, 0xd9c55514, 0x6bdcffc1,
+	0x693e6340, 0x82383fe7, 0x1916ea5f, 0xec7bcd59, 0x72de165a, 0xe79a1617,
+	0x8ec86234, 0xa8f0d284, 0x20c90226, 0x7bf98884, 0x28a58331, 0x3ec3fa6e,
+	0x4ce0895b, 0xc353b4d0, 0x33ef064f, 0x21e5e210, 0xc8bb589d, 0xe85dcab2,
+	0xac65829f, 0xa7bf92d0, 0x05a6174d, 0x25a50c2e, 0xe5c78777, 0x3d75021f,
+	0x4baa9c98, 0x23bdc884, 0x9653bbd7, 0xbadce7f5, 0xc283a484, 0xc040df2e,
+	0x9370a841, 0x2f316022, 0x36eed231, 0xac2cbc0c, 0x13c0a49b, 0xcdd12997,
+	0x07fe91b2, 0xcd7eabcd, 0x2c01271d, 0x18432df8, 0x599c6bc7, 0x75e93d5a,
+	0xb67a6ee2, 0x8e738e16, 0xff9073fd, 0xaf77026a, 0xf86ea2fc, 0x91509ea3,
+	0x33a78dc6, 0x4f79234a, 0x3a7535bc, 0x3539fcb1, 0x3103ee52, 0x4f6f1e69,
+	0x6bb3ebbc, 0x4cb77555, 0x8dd1e999, 0x2ade439d, 0x11521fae, 0xb94d2545,
+	0x8dde9abd, 0x1909393f, 0xb792a23d, 0x749c455b, 0xb5b60f2c, 0x380459ce,
+	0x0dad5820, 0xb130845b, 0x291cbd52, 0xde9a5bb7, 0x51def961, 0x515b6408,
+	0xca6e823e, 0x382e6e74, 0xeebe3d71, 0x4c8f0c6a, 0xe676dcea, 0x14e1dc7c,
+	0x6f7fc634, 0xcf85a943, 0xd39ea96e, 0x136e7c93, 0x7164b304, 0xf32f1333,
+	0x35c34034, 0xde39d721, 0x91a87439, 0xc410111f, 0x29f17aac, 0x1316a6ff,
+	0x12f194ee, 0x420b9499, 0xf72db0dc, 0x690b9f93, 0x17d14bb2, 0x8f931ab8,
+	0x217500bc, 0x875413f8, 0x98b2e43d, 0xc51f9571, 0x54cebdca, 0x0719cc79,
+	0xf3c7080d, 0xe4286771, 0xa3eab3cd, 0x4a6b00e0, 0x11cf0759, 0x7e897379,
+	0x5b32876c, 0x5e8cd4f6, 0x0cedfa64, 0x919ac2c7, 0xb214f3b3, 0x0e89c38c,
+	0xf0c43a39, 0xeae10522, 0x835bce06, 0x9eec43c2, 0xea26a9d6, 0x69531821,
+	0x6725b24a, 0xda81b0e2, 0xd5b4ae33, 0x080f99fb, 0x15a83daf, 0x29dfc720,
+	0x91e1900f, 0x28163d58, 0x83d107a2, 0x4eac149a, 0x9f71da18, 0x61d5c4fa,
+	0xe3ab2a5f, 0xc7b0d63f, 0xb3cc752a, 0x61ebcfb6, 0x26ffb52a, 0xed789e3f,
+	0xaa3bc958, 0x455a8788, 0xc9c082a9, 0x0a1bef0e, 0xc29a5a7e, 0x150d4735,
+	0x943809e0, 0x69215510, 0xef0b0da9, 0x3b4e9fb3, 0xd8b5d04c, 0xc7a023a8,
+	0xb0d50288, 0x64821375, 0xc260e8cf, 0x8496bd2c, 0xff4f5435, 0x0fb5560c,
+	0x7cd74a52, 0x93589c80, 0x88975c47, 0x83bda89d, 0x8bcc4296, 0x01b82c21,
+	0xfd821dbf, 0x26520b47, 0x04983e19, 0xd3e1ca27, 0x782c580f, 0x326ff573,
+	0xc157bcc7, 0x4f5e6b84, 0x44ebfbfb, 0xda26d9d8, 0x6cd9d08e, 0x1719f1d8,
+	0x715c0487, 0x2c2d3c92, 0x53faaba9, 0xbc836146, 0x510c92d6, 0xe089f82a,
+	0x4680171f, 0x369f00de, 0x70ec2331, 0x0e253d55, 0xdafb9717, 0xe5dd922d,
+	0x95915d21, 0xa0202f96, 0xa161cc47, 0xeacfa6f1, 0xed5e9189, 0xdab87684,
+	0xa4b76d4a, 0xfa704897, 0x631f10ba, 0xd39da8f9, 0x5db4c0e4, 0x16fde42a,
+	0x2dff7580, 0xb56fec7e, 0xc3ffb370, 0x8e6f36bc, 0x6097d459, 0x514d5d36,
+	0xa5a737e2, 0x3977b9b3, 0xfd31a0ca, 0x903368db, 0xe8370d61, 0x98109520,
+	0xade23cac, 0x99f82e04, 0x41de7ea3, 0x84a1c295, 0x09191be0, 0x30930d02,
+	0x1c9fa44a, 0xc406b6d7, 0xeedca152, 0x6149809c, 0xb0099ef4, 0xc5f653a5,
+	0x4c10790d, 0x7303286c
+};
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/explode.c temp-build/maptools/vmap_extractor/libmpq04/explode.c
--- clean-build/maptools/vmap_extractor/libmpq04/explode.c	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/explode.c	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,602 @@
+/*
+ *  explode.c -- explode function of pkware data compression library.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of pkware.cpp included
+ *  in stormlib. The C++ version belongs to the following authors:
+ *
+ *  Ladislav Zezula <ladik@zezula.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* generic includes. */
+#include <string.h>
+
+/* libmpq main includes. */
+#include "mpq.h"
+
+/* libmpq generic includes. */
+#include "explode.h"
+
+/* tables used for data extraction. */
+static const uint8_t pkzip_dist_bits[] = {
+	0x02, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
+};
+
+/* tables used for data extraction. */
+static const uint8_t pkzip_dist_code[] = {
+	0x03, 0x0D, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3E, 0x1E, 0x2E, 0x0E, 0x36, 0x16, 0x26, 0x06, 0x3A,
+	0x1A, 0x2A, 0x0A, 0x32, 0x12, 0x22, 0x42, 0x02, 0x7C, 0x3C, 0x5C, 0x1C, 0x6C, 0x2C, 0x4C, 0x0C,
+	0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04, 0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
+	0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50, 0x90, 0x10, 0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00
+};
+
+/* tables used for data extraction. */
+static const uint8_t pkzip_clen_bits[] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
+};
+
+/* tables used for data extraction. */
+static const uint16_t pkzip_len_base[] = {
+	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
+	0x0008, 0x000A, 0x000E, 0x0016, 0x0026, 0x0046, 0x0086, 0x0106
+};
+
+/* tables used for data extraction. */
+static const uint8_t pkzip_slen_bits[] = {
+	0x03, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07
+};
+
+/* tables used for data extraction. */
+static const uint8_t pkzip_len_code[] = {
+	0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14, 0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00
+};
+
+/* tables used for data extraction. */
+static const uint8_t pkzip_bits_asc[] = {
+	0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x0C, 0x0C, 0x07, 0x0C, 0x0C,
+	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+	0x04, 0x0A, 0x08, 0x0C, 0x0A, 0x0C, 0x0A, 0x08, 0x07, 0x07, 0x08, 0x09, 0x07, 0x06, 0x07, 0x08,
+	0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x07, 0x07, 0x08, 0x08, 0x0C, 0x0B, 0x07, 0x09, 0x0B,
+	0x0C, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x08, 0x08, 0x06, 0x0B, 0x09, 0x06, 0x07, 0x06, 0x06,
+	0x07, 0x0B, 0x06, 0x06, 0x06, 0x07, 0x09, 0x08, 0x09, 0x09, 0x0B, 0x08, 0x0B, 0x09, 0x0C, 0x08,
+	0x0C, 0x05, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05, 0x0B, 0x07, 0x05, 0x06, 0x05, 0x05,
+	0x06, 0x0A, 0x05, 0x05, 0x05, 0x05, 0x08, 0x07, 0x08, 0x08, 0x0A, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C,
+	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
+	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
+	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
+	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+	0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D,
+	0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D
+};
+
+/* tables used for data extraction. */
+static const uint16_t pkzip_code_asc[] = {
+	0x0490, 0x0FE0, 0x07E0, 0x0BE0, 0x03E0, 0x0DE0, 0x05E0, 0x09E0,
+	0x01E0, 0x00B8, 0x0062, 0x0EE0, 0x06E0, 0x0022, 0x0AE0, 0x02E0,
+	0x0CE0, 0x04E0, 0x08E0, 0x00E0, 0x0F60, 0x0760, 0x0B60, 0x0360,
+	0x0D60, 0x0560, 0x1240, 0x0960, 0x0160, 0x0E60, 0x0660, 0x0A60,
+	0x000F, 0x0250, 0x0038, 0x0260, 0x0050, 0x0C60, 0x0390, 0x00D8,
+	0x0042, 0x0002, 0x0058, 0x01B0, 0x007C, 0x0029, 0x003C, 0x0098,
+	0x005C, 0x0009, 0x001C, 0x006C, 0x002C, 0x004C, 0x0018, 0x000C,
+	0x0074, 0x00E8, 0x0068, 0x0460, 0x0090, 0x0034, 0x00B0, 0x0710,
+	0x0860, 0x0031, 0x0054, 0x0011, 0x0021, 0x0017, 0x0014, 0x00A8,
+	0x0028, 0x0001, 0x0310, 0x0130, 0x003E, 0x0064, 0x001E, 0x002E,
+	0x0024, 0x0510, 0x000E, 0x0036, 0x0016, 0x0044, 0x0030, 0x00C8,
+	0x01D0, 0x00D0, 0x0110, 0x0048, 0x0610, 0x0150, 0x0060, 0x0088,
+	0x0FA0, 0x0007, 0x0026, 0x0006, 0x003A, 0x001B, 0x001A, 0x002A,
+	0x000A, 0x000B, 0x0210, 0x0004, 0x0013, 0x0032, 0x0003, 0x001D,
+	0x0012, 0x0190, 0x000D, 0x0015, 0x0005, 0x0019, 0x0008, 0x0078,
+	0x00F0, 0x0070, 0x0290, 0x0410, 0x0010, 0x07A0, 0x0BA0, 0x03A0,
+	0x0240, 0x1C40, 0x0C40, 0x1440, 0x0440, 0x1840, 0x0840, 0x1040,
+	0x0040, 0x1F80, 0x0F80, 0x1780, 0x0780, 0x1B80, 0x0B80, 0x1380,
+	0x0380, 0x1D80, 0x0D80, 0x1580, 0x0580, 0x1980, 0x0980, 0x1180,
+	0x0180, 0x1E80, 0x0E80, 0x1680, 0x0680, 0x1A80, 0x0A80, 0x1280,
+	0x0280, 0x1C80, 0x0C80, 0x1480, 0x0480, 0x1880, 0x0880, 0x1080,
+	0x0080, 0x1F00, 0x0F00, 0x1700, 0x0700, 0x1B00, 0x0B00, 0x1300,
+	0x0DA0, 0x05A0, 0x09A0, 0x01A0, 0x0EA0, 0x06A0, 0x0AA0, 0x02A0,
+	0x0CA0, 0x04A0, 0x08A0, 0x00A0, 0x0F20, 0x0720, 0x0B20, 0x0320,
+	0x0D20, 0x0520, 0x0920, 0x0120, 0x0E20, 0x0620, 0x0A20, 0x0220,
+	0x0C20, 0x0420, 0x0820, 0x0020, 0x0FC0, 0x07C0, 0x0BC0, 0x03C0,
+	0x0DC0, 0x05C0, 0x09C0, 0x01C0, 0x0EC0, 0x06C0, 0x0AC0, 0x02C0,
+	0x0CC0, 0x04C0, 0x08C0, 0x00C0, 0x0F40, 0x0740, 0x0B40, 0x0340,
+	0x0300, 0x0D40, 0x1D00, 0x0D00, 0x1500, 0x0540, 0x0500, 0x1900,
+	0x0900, 0x0940, 0x1100, 0x0100, 0x1E00, 0x0E00, 0x0140, 0x1600,
+	0x0600, 0x1A00, 0x0E40, 0x0640, 0x0A40, 0x0A00, 0x1200, 0x0200,
+	0x1C00, 0x0C00, 0x1400, 0x0400, 0x1800, 0x0800, 0x1000, 0x0000  
+};
+
+/* local unused variables. */
+char pkware_copyright[] = "PKWARE Data Compression Library for Win32\r\n"
+			  "Copyright 1989-1995 PKWARE Inc.  All Rights Reserved\r\n"
+			  "Patent No. 5,051,745\r\n"
+			  "PKWARE Data Compression Library Reg. U.S. Pat. and Tm. Off.\r\n"
+			  "Version 1.11\r\n";
+
+/* skips given number of bits. */
+static int32_t skip_bit(pkzip_cmp_s *mpq_pkzip, uint32_t bits) {
+
+	/* check if number of bits required is less than number of bits in the buffer. */
+	if (bits <= mpq_pkzip->extra_bits) {
+		mpq_pkzip->extra_bits  -= bits;
+		mpq_pkzip->bit_buf    >>= bits;
+		return 0;
+	}
+
+	/* load input buffer if necessary. */
+	mpq_pkzip->bit_buf >>= mpq_pkzip->extra_bits;
+	if (mpq_pkzip->in_pos == mpq_pkzip->in_bytes) {
+		mpq_pkzip->in_pos = sizeof(mpq_pkzip->in_buf);
+		if ((mpq_pkzip->in_bytes = mpq_pkzip->read_buf((char *)mpq_pkzip->in_buf, &mpq_pkzip->in_pos, mpq_pkzip->param)) == 0) {
+			return 1;
+		}
+		mpq_pkzip->in_pos = 0;
+	}
+
+	/* update bit buffer. */
+	mpq_pkzip->bit_buf     |= (mpq_pkzip->in_buf[mpq_pkzip->in_pos++] << 8);
+	mpq_pkzip->bit_buf    >>= (bits - mpq_pkzip->extra_bits);
+	mpq_pkzip->extra_bits   = (mpq_pkzip->extra_bits - bits) + 8;
+
+	/* if no error was found, return zero. */
+	return 0;
+}
+
+/* this function generate the decode tables used for decryption. */
+static void generate_tables_decode(int32_t count, uint8_t *bits, const uint8_t *code, uint8_t *buf2) {
+
+	/* some common variables. */
+	int32_t i;
+
+	/* EBX - count */
+	for (i = count-1; i >= 0; i--) {
+
+		/* some common variables. */
+		uint32_t idx1 = code[i];
+		uint32_t idx2 = 1 << bits[i];
+
+		/* loop until table is ready. */
+		do {
+			buf2[idx1] = (uint8_t)i;
+			idx1      += idx2;
+		} while (idx1 < 0x100);
+	}
+}
+
+/* this function generate the tables for ascii decompression. */
+static void generate_tables_ascii(pkzip_cmp_s *mpq_pkzip) {
+
+	/* some common variables. */
+	const uint16_t *code_asc = &pkzip_code_asc[0xFF];
+	uint32_t acc;
+	uint32_t add;
+	uint16_t count;
+
+	/* loop through ascii table. */
+	for (count = 0x00FF; code_asc >= pkzip_code_asc; code_asc--, count--) {
+		uint8_t *bits_asc = mpq_pkzip->bits_asc + count;
+		uint8_t bits_tmp  = *bits_asc;
+
+		/* check if byte is finished. */
+		if (bits_tmp <= 8) {
+			add = (1 << bits_tmp);
+			acc = *code_asc;
+			do {
+				mpq_pkzip->offs_2c34[acc]  = (uint8_t)count;
+				acc                       += add;
+			} while (acc < 0x100);
+		} else {
+			if ((acc = (*code_asc & 0xFF)) != 0) {
+				mpq_pkzip->offs_2c34[acc] = 0xFF;
+				if (*code_asc & 0x3F) {
+
+					/* decrease bit by four. */
+					bits_tmp  -= 4;
+					*bits_asc  = bits_tmp;
+					add        = (1 << bits_tmp);
+					acc        = *code_asc >> 4;
+					do {
+						mpq_pkzip->offs_2d34[acc]  = (uint8_t)count;
+						acc                       += add;
+					} while (acc < 0x100);
+				} else {
+
+					/* decrease bit by six. */
+					bits_tmp  -= 6;
+					*bits_asc  = bits_tmp;
+					add        = (1 << bits_tmp);
+					acc        = *code_asc >> 6;
+					do {
+						mpq_pkzip->offs_2e34[acc]  = (uint8_t)count;
+						acc                       += add;
+					} while (acc < 0x80);
+				}
+			} else {
+
+				/* decrease bit by eight. (one byte) */
+				bits_tmp  -= 8;
+				*bits_asc  = bits_tmp;
+				add        = (1 << bits_tmp);
+				acc        = *code_asc >> 8;
+				do {
+					mpq_pkzip->offs_2eb4[acc]  = (uint8_t)count;
+					acc                       += add;
+				} while (acc < 0x100);
+			}
+		}
+	}
+}
+
+/*
+ *  decompress the imploded data using coded literals.
+ *
+ *  returns: 0x000 - 0x0FF : one byte from compressed file.
+ *           0x100 - 0x305 : copy previous block. (0x100 = 1 byte)
+ *           0x306         : out of buffer?
+ */
+static uint32_t decode_literal(pkzip_cmp_s *mpq_pkzip) {
+
+	/* number of bits to skip. */
+	uint32_t bits;
+
+	/* position in buffers. */
+	uint32_t value;
+
+	/* check if bit the current buffer is set, if not return the next byte. */
+	if (mpq_pkzip->bit_buf & 1) {
+
+		/* skip current bit in the buffer. */
+		if (skip_bit(mpq_pkzip, 1)) {
+			return 0x306;
+		}
+
+		/* the next bits are position in buffers. */
+		value = mpq_pkzip->pos2[(mpq_pkzip->bit_buf & 0xFF)];
+
+		/* get number of bits to skip. */
+		if (skip_bit(mpq_pkzip, mpq_pkzip->slen_bits[value])) {
+			return 0x306;
+		}
+
+		/* check bits. */
+		if ((bits = mpq_pkzip->clen_bits[value]) != 0) {
+
+			/* some common variables. */
+			uint32_t val2 = mpq_pkzip->bit_buf & ((1 << bits) - 1);
+
+			/* check if we should skip one bit. */
+			if (skip_bit(mpq_pkzip, bits)) {
+
+				/* check position if we should skip the bit. */
+				if ((value + val2) != 0x10E) {
+					return 0x306;
+				}
+			}
+
+			/* fill values. */
+			value = mpq_pkzip->len_base[value] + val2;
+		}
+
+		/* return number of bytes to repeat. */
+		return value + 0x100;
+	}
+
+	/* skip one bit. */
+	if (skip_bit(mpq_pkzip, 1)) {
+		return 0x306;
+	}
+
+	/* check the binary compression type, read 8 bits and return them as one byte. */
+	if (mpq_pkzip->cmp_type == LIBMPQ_PKZIP_CMP_BINARY) {
+
+		/* fill values. */
+		value = mpq_pkzip->bit_buf & 0xFF;
+
+		/* check if we should skip one bit. */
+		if (skip_bit(mpq_pkzip, 8)) {
+			return 0x306;
+		}
+
+		/* return value from bit buffer. */
+		return value;
+	}
+
+	/* check if ascii compression is used. */
+	if (mpq_pkzip->bit_buf & 0xFF) {
+
+		/* fill values. */
+		value = mpq_pkzip->offs_2c34[mpq_pkzip->bit_buf & 0xFF];
+
+		/* check value. */
+		if (value == 0xFF) {
+			if (mpq_pkzip->bit_buf & 0x3F) {
+
+				/* check if four bits are in bit buffer for skipping. */
+				if (skip_bit(mpq_pkzip, 4)) {
+					return 0x306;
+				}
+
+				/* fill values. */
+				value = mpq_pkzip->offs_2d34[mpq_pkzip->bit_buf & 0xFF];
+			} else {
+
+				/* check if six bits are in bit buffer for skipping. */
+				if (skip_bit(mpq_pkzip, 6)) {
+					return 0x306;
+				}
+
+				/* fill values. */
+				value = mpq_pkzip->offs_2e34[mpq_pkzip->bit_buf & 0x7F];
+			}
+		}
+	} else {
+
+		/* check if eight bits are in bit buffer for skipping. */
+		if (skip_bit(mpq_pkzip, 8)) {
+			return 0x306;
+		}
+
+		/* fill values. */
+		value = mpq_pkzip->offs_2eb4[mpq_pkzip->bit_buf & 0xFF];
+	}
+
+	/* return out of buffer error (0x306) or position in buffer. */
+	return skip_bit(mpq_pkzip, mpq_pkzip->bits_asc[value]) ? 0x306 : value;
+}
+
+/* this function retrieves the number of bytes to move back. */
+static uint32_t decode_distance(pkzip_cmp_s *mpq_pkzip, uint32_t length) {
+
+	/* some common variables. */
+	uint32_t pos  = mpq_pkzip->pos1[(mpq_pkzip->bit_buf & 0xFF)];
+
+	/* number of bits to skip. */
+	uint32_t skip = mpq_pkzip->dist_bits[pos];
+
+	/* skip the appropriate number of bits. */
+	if (skip_bit(mpq_pkzip, skip) == 1) {
+		return 0;
+	}
+
+	/* check if length is two. */
+	if (length == 2) {
+		pos = (pos << 2) | (mpq_pkzip->bit_buf & 0x03);
+
+		/* skip the bits. */
+		if (skip_bit(mpq_pkzip, 2) == 1) {
+			return 0;
+		}
+	} else {
+		pos = (pos << mpq_pkzip->dsize_bits) | (mpq_pkzip->bit_buf & mpq_pkzip->dsize_mask);
+
+		/* skip the bits */
+		if (skip_bit(mpq_pkzip, mpq_pkzip->dsize_bits) == 1) {
+			return 0;
+		}
+	}
+
+	/* return the bytes to move back. */
+	return pos + 1;
+}
+
+/*
+ *  function loads data from the input buffer used by mpq_pkzip
+ *  "implode" and "explode" function as user defined callback and
+ *  returns number of bytes loaded.
+ *
+ *  char		*buf	- pointer to a buffer where to store loaded data.
+ *  uint32_t		*size	- maximum number of bytes to read.
+ *  void		*param	- custom pointer, parameter of implode/explode.
+ */
+static uint32_t data_read_input(char *buf, uint32_t *size, void *param) {
+
+	/* some common variables. */
+	pkzip_data_s *info   = (pkzip_data_s *)param;
+	uint32_t max_avail = (info->in_bytes - info->in_pos);
+	uint32_t to_read   = *size;
+
+	/* check the case when not enough data available. */
+	if (to_read > max_avail) {
+		to_read = max_avail;
+	}
+
+	/* load data and increment offsets. */
+	memcpy(buf, info->in_buf + info->in_pos, to_read);
+	info->in_pos += to_read;
+
+	/* return bytes read. */
+	return to_read;
+}
+
+/*
+ *  function for store output data used by mpq_pkzip "implode" and
+ *  "explode" as userdefined callback.
+ *
+ *  char		*buf	- pointer to data to be written.
+ *  uint32_t		*size	- number of bytes to write.
+ *  void		*param	- custom pointer, parameter of implode/explode.
+ */
+static void data_write_output(char *buf, uint32_t *size, void *param) {
+
+	/* some common variables. */
+	pkzip_data_s *info   = (pkzip_data_s *)param;
+	uint32_t max_write = (info->max_out - info->out_pos);
+	uint32_t to_write  = *size;
+
+	/* check the case when not enough space in the output buffer. */
+	if (to_write > max_write) {
+		to_write = max_write;
+	}
+
+	/* write output data and increments offsets. */
+	memcpy(info->out_buf + info->out_pos, buf, to_write);
+	info->out_pos += to_write;
+}
+
+/* this function extract the data from input stream. */
+static uint32_t expand(pkzip_cmp_s *mpq_pkzip) {
+
+	/* number of bytes to copy. */
+	uint32_t copy_bytes;
+
+	/* one byte from compressed file. */
+	uint32_t one_byte;
+
+	/* some common variables. */
+	uint32_t result;
+
+	/* initialize output buffer position. */
+	mpq_pkzip->out_pos = 0x1000;
+
+	/* check if end of data or error, so terminate decompress. */
+	while ((result = one_byte = decode_literal(mpq_pkzip)) < 0x305) {
+
+		/* check if one byte is greater than 0x100, which means 'repeat n - 0xFE bytes'. */
+		if (one_byte >= 0x100) {
+
+			/* ECX */
+			uint8_t *source;
+
+			/* EDX */
+			uint8_t *target;
+
+			/* some common variables. */
+			uint32_t copy_length = one_byte - 0xFE;
+			uint32_t move_back;
+
+			/* get length of data to copy. */
+			if ((move_back = decode_distance(mpq_pkzip, copy_length)) == 0) {
+				result = 0x306;
+				break;
+			}
+
+			/* target and source pointer. */
+			target              = &mpq_pkzip->out_buf[mpq_pkzip->out_pos];
+			source              = target - move_back;
+			mpq_pkzip->out_pos += copy_length;
+
+			/* copy until nothing left. */
+			while (copy_length-- > 0) {
+				*target++ = *source++;
+			}
+		} else {
+
+			/* byte is 0x100 great, so add one byte. */
+			mpq_pkzip->out_buf[mpq_pkzip->out_pos++] = (uint8_t)one_byte;
+		}
+
+		/* check if number of extracted bytes has reached 1/2 of output buffer, so flush output buffer. */
+		if (mpq_pkzip->out_pos >= 0x2000) {
+
+			/* copy decompressed data into user buffer. */
+			copy_bytes = 0x1000;
+			mpq_pkzip->write_buf((char *)&mpq_pkzip->out_buf[0x1000], &copy_bytes, mpq_pkzip->param);
+
+			/* check if there are some data left, keep them alive. */
+			memcpy(mpq_pkzip->out_buf, &mpq_pkzip->out_buf[0x1000], mpq_pkzip->out_pos - 0x1000);
+			mpq_pkzip->out_pos -= 0x1000;
+		}
+	}
+
+	/* copy the rest. */
+	copy_bytes = mpq_pkzip->out_pos - 0x1000;
+	mpq_pkzip->write_buf((char *)&mpq_pkzip->out_buf[0x1000], &copy_bytes, mpq_pkzip->param);
+
+	/* return copied bytes. */
+	return result;
+}
+
+/* this function explode the data stream. */
+uint32_t libmpq__do_decompress_pkzip(uint8_t *work_buf, void *param) {
+
+	/* some common variables. */
+	pkzip_cmp_s *mpq_pkzip = (pkzip_cmp_s *)work_buf;
+
+	/* set the whole work buffer to zeros. */
+	memset(mpq_pkzip, 0, sizeof(pkzip_cmp_s));
+
+	/* initialize work struct and load compressed data. */
+	mpq_pkzip->read_buf   = data_read_input;
+	mpq_pkzip->write_buf  = data_write_output;
+	mpq_pkzip->param      = param;
+	mpq_pkzip->in_pos     = sizeof(mpq_pkzip->in_buf);
+	mpq_pkzip->in_bytes   = mpq_pkzip->read_buf((char *)mpq_pkzip->in_buf, &mpq_pkzip->in_pos, mpq_pkzip->param);
+
+	/* check if we have pkzip data. */
+	if (mpq_pkzip->in_bytes <= 4) {
+		return LIBMPQ_PKZIP_CMP_BAD_DATA;
+	}
+
+	/* get the compression type. */
+	mpq_pkzip->cmp_type   = mpq_pkzip->in_buf[0];
+
+	/* get the dictionary size. */
+	mpq_pkzip->dsize_bits = mpq_pkzip->in_buf[1];
+
+	/* initialize 16-bit bit buffer. */
+	mpq_pkzip->bit_buf    = mpq_pkzip->in_buf[2];
+
+	/* extra (over 8) bits. */
+	mpq_pkzip->extra_bits = 0;
+
+	/* position in input buffer. */
+	mpq_pkzip->in_pos     = 3;
+
+	/* check if valid dictionary size. */
+	if (4 > mpq_pkzip->dsize_bits || mpq_pkzip->dsize_bits > 6) {
+		return LIBMPQ_PKZIP_CMP_INV_DICTSIZE;
+	}
+
+	/* shifted by 'sar' instruction. */
+	mpq_pkzip->dsize_mask = 0xFFFF >> (0x10 - mpq_pkzip->dsize_bits);
+
+	/* check if we are using binary compression. */
+	if (mpq_pkzip->cmp_type != LIBMPQ_PKZIP_CMP_BINARY) {
+
+		/* check if we are using ascii compression. */
+		if (mpq_pkzip->cmp_type != LIBMPQ_PKZIP_CMP_ASCII) {
+			return LIBMPQ_PKZIP_CMP_INV_MODE;
+		}
+
+		/* create ascii buffer. */
+		memcpy(mpq_pkzip->bits_asc, pkzip_bits_asc, sizeof(mpq_pkzip->bits_asc));
+		generate_tables_ascii(mpq_pkzip);
+	}
+
+	/* create the tables for decode. */
+	memcpy(mpq_pkzip->slen_bits, pkzip_slen_bits, sizeof(mpq_pkzip->slen_bits));
+	generate_tables_decode(0x10, mpq_pkzip->slen_bits, pkzip_len_code, mpq_pkzip->pos2);
+
+	/* create the tables for decode. */
+	memcpy(mpq_pkzip->clen_bits, pkzip_clen_bits, sizeof(mpq_pkzip->clen_bits));
+	memcpy(mpq_pkzip->len_base, pkzip_len_base, sizeof(mpq_pkzip->len_base));
+	memcpy(mpq_pkzip->dist_bits, pkzip_dist_bits, sizeof(mpq_pkzip->dist_bits));
+	generate_tables_decode(0x40, mpq_pkzip->dist_bits, pkzip_dist_code, mpq_pkzip->pos1);
+
+	/* check if data extraction works. */
+	if (expand(mpq_pkzip) != 0x306) {
+		return LIBMPQ_PKZIP_CMP_NO_ERROR;
+	}
+
+	/* something failed, so return error. */
+	return LIBMPQ_PKZIP_CMP_ABORT;
+}
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/explode.h temp-build/maptools/vmap_extractor/libmpq04/explode.h
--- clean-build/maptools/vmap_extractor/libmpq04/explode.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/explode.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,87 @@
+/*
+ *  explode.h -- header file for pkware data decompression library
+ *               used by mpq-tools.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of pklib.h included
+ *  in stormlib. The C++ version belongs to the following authors:
+ *
+ *  Ladislav Zezula <ladik@zezula.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _EXPLODE_H
+#define _EXPLODE_H
+
+/* define compression constants and return values. */
+#define LIBMPQ_PKZIP_CMP_BINARY			0		/* binary compression. */
+#define LIBMPQ_PKZIP_CMP_ASCII			1		/* ascii compression. */
+#define LIBMPQ_PKZIP_CMP_NO_ERROR		0
+#define LIBMPQ_PKZIP_CMP_INV_DICTSIZE		1
+#define LIBMPQ_PKZIP_CMP_INV_MODE		2
+#define LIBMPQ_PKZIP_CMP_BAD_DATA		3
+#define LIBMPQ_PKZIP_CMP_ABORT			4
+
+#include "pack_begin.h"
+/* compression structure. */
+typedef struct {
+	uint32_t	offs0000;		/* 0000 - start. */
+	uint32_t	cmp_type;		/* 0004 - compression type (binary or ascii). */
+	uint32_t	out_pos;		/* 0008 - position in output buffer. */
+	uint32_t	dsize_bits;		/* 000C - dict size (4, 5, 6 for 0x400, 0x800, 0x1000). */
+	uint32_t	dsize_mask;		/* 0010 - dict size bitmask (0x0F, 0x1F, 0x3F for 0x400, 0x800, 0x1000). */
+	uint32_t	bit_buf;		/* 0014 - 16-bit buffer for processing input data. */
+	uint32_t	extra_bits;		/* 0018 - number of extra (above 8) bits in bit buffer. */
+	uint32_t	in_pos;			/* 001C - position in in_buf. */
+	uint32_t	in_bytes;		/* 0020 - number of bytes in input buffer. */
+	void		*param;			/* 0024 - custom parameter. */
+	uint32_t	(*read_buf)(char *buf, uint32_t *size, void *param);	/* 0028 offset.*/
+	void		(*write_buf)(char *buf, uint32_t *size, void *param);	/* 002C offset. */
+	uint8_t		out_buf[0x2000];	/* 0030 - output circle buffer, starting position is 0x1000. */
+	uint8_t		offs_2030[0x204];	/* 2030 - whats that? */
+	uint8_t		in_buf[0x800];		/* 2234 - buffer for data to be decompressed. */
+	uint8_t		pos1[0x100];		/* 2A34 - positions in buffers. */
+	uint8_t		pos2[0x100];		/* 2B34 - positions in buffers. */
+	uint8_t		offs_2c34[0x100];	/* 2C34 - buffer. */
+	uint8_t		offs_2d34[0x100];	/* 2D34 - buffer. */
+	uint8_t		offs_2e34[0x80];	/* 2EB4 - buffer. */
+	uint8_t		offs_2eb4[0x100];	/* 2EB4 - buffer. */
+	uint8_t		bits_asc[0x100];	/* 2FB4 - buffer. */
+	uint8_t		dist_bits[0x40];	/* 30B4 - numbers of bytes to skip copied block length. */
+	uint8_t		slen_bits[0x10];	/* 30F4 - numbers of bits for skip copied block length. */
+	uint8_t		clen_bits[0x10];	/* 3104 - number of valid bits for copied block. */
+	uint16_t	len_base[0x10];		/* 3114 - buffer. */
+} PACK_STRUCT pkzip_cmp_s;
+#include "pack_end.h"
+
+/* data structure. */
+typedef struct {
+	uint8_t		*in_buf;		/* pointer to input data buffer. */
+	uint32_t	in_pos;			/* current offset in input data buffer. */
+	int32_t		in_bytes;		/* number of bytes in the input buffer. */
+	uint8_t		*out_buf;		/* pointer to output data buffer. */
+	uint32_t	out_pos;		/* position in the output buffer. */
+	int32_t		max_out;		/* maximum number of bytes in the output buffer. */
+} pkzip_data_s;
+
+/* decompress the stream using pkzip compression. */
+uint32_t libmpq__do_decompress_pkzip(
+	uint8_t		*work_buf,
+	void		*param
+);
+
+#endif						/* _EXPLODE_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/extract.c temp-build/maptools/vmap_extractor/libmpq04/extract.c
--- clean-build/maptools/vmap_extractor/libmpq04/extract.c	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/extract.c	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,361 @@
+/*
+ *  extract.c -- global extracting function for all known file compressions
+ *               in a mpq archive.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* generic includes. */
+#include <stdlib.h>
+#include <string.h>
+
+/* zlib includes. */
+#include <zlib.h>
+#include <bzlib.h>
+
+/* libmpq main includes. */
+#include "mpq.h"
+
+/* libmpq generic includes. */
+#include "explode.h"
+#include "extract.h"
+#include "huffman.h"
+#include "wave.h"
+
+/* table with decompression bits and functions. */
+static decompress_table_s dcmp_table[] = {
+	{LIBMPQ_COMPRESSION_HUFFMAN, libmpq__decompress_huffman},	/* decompression using huffman trees. */
+	{LIBMPQ_COMPRESSION_ZLIB, libmpq__decompress_zlib},	/* decompression with the zlib library. */
+	{LIBMPQ_COMPRESSION_PKZIP, libmpq__decompress_pkzip},	/* decompression with pkware data compression library. */
+	{LIBMPQ_COMPRESSION_BZIP2, libmpq__decompress_bzip2},	/* decompression with bzip2 library. */
+	{LIBMPQ_COMPRESSION_WAVE_MONO, libmpq__decompress_wave_mono},	/* decompression for mono waves. */
+	{LIBMPQ_COMPRESSION_WAVE_STEREO, libmpq__decompress_wave_stereo}	/* decompression for stereo waves. */
+};
+
+/* this function decompress a stream using huffman algorithm. */
+int32_t libmpq__decompress_huffman(uint8_t *in_buf, uint32_t in_size, uint8_t *out_buf, uint32_t out_size) {
+
+	/* TODO: make typdefs of this structs? */
+	/* some common variables. */
+	int32_t tb     = 0;
+	struct huffman_tree_s *ht;
+	struct huffman_input_stream_s *is;
+
+	/* allocate memory for the huffman tree. */
+	if ((ht = malloc(sizeof(struct huffman_tree_s))) == NULL ||
+	    (is = malloc(sizeof(struct huffman_input_stream_s))) == NULL) {
+
+		/* memory allocation problem. */
+		return LIBMPQ_ERROR_MALLOC;
+	}
+
+	/* cleanup structures. */
+	memset(ht, 0, sizeof(struct huffman_tree_s));
+	memset(is, 0, sizeof(struct huffman_input_stream_s));
+
+	/* initialize input stream. */
+	is->bit_buf  = *(uint32_t *)in_buf;
+	in_buf      += sizeof(int32_t);
+	is->in_buf   = (uint8_t *)in_buf;
+	is->bits     = 32;
+
+// TODO: add all the mallocs to init function and add function libmpq__huffman_tree_free() */
+//	if ((result = libmpq__huffman_tree_init(ht, LIBMPQ_HUFF_DECOMPRESS)) < 0) {
+//
+//		/* something on zlib initialization failed. */
+//		return LIBMPQ_ERROR_UNPACK;
+//	}
+
+	/* initialize the huffman tree for decompression. */
+	libmpq__huffman_tree_init(ht, LIBMPQ_HUFF_DECOMPRESS);
+
+	/* save the number of copied bytes. */
+	tb = libmpq__do_decompress_huffman(ht, is, out_buf, out_size);
+
+	/* free structures. */
+	free(is);
+	free(ht);
+
+	/* return transferred bytes. */
+	return tb;
+}
+
+/* this function decompress a stream using zlib algorithm. */
+int32_t libmpq__decompress_zlib(uint8_t *in_buf, uint32_t in_size, uint8_t *out_buf, uint32_t out_size) {
+
+	/* some common variables. */
+	int32_t result = 0;
+	int32_t tb     = 0;
+	z_stream z;
+
+	/* fill the stream structure for zlib. */
+	z.next_in   = (Bytef *)in_buf;
+	z.avail_in  = (uInt)in_size;
+	z.total_in  = in_size;
+	z.next_out  = (Bytef *)out_buf;
+	z.avail_out = (uInt)out_size;
+	z.total_out = 0;
+	z.zalloc    = NULL;
+	z.zfree     = NULL;
+
+	/* initialize the decompression structure, storm.dll uses zlib version 1.1.3. */
+	if ((result = inflateInit(&z)) != Z_OK) {
+
+		/* something on zlib initialization failed. */
+		return result;
+	}
+
+	/* call zlib to decompress the data. */
+	if ((result = inflate(&z, Z_FINISH)) != Z_STREAM_END) {
+
+		/* something on zlib decompression failed. */
+		return result;
+	}
+
+	/* save transferred bytes. */
+	tb = z.total_out;
+
+	/* cleanup zlib. */
+	if ((result = inflateEnd(&z)) != Z_OK) {
+
+		/* something on zlib finalization failed. */
+		return result;
+	}
+
+	/* return transferred bytes. */
+	return tb;
+}
+
+/* this function decompress a stream using pkzip algorithm. */
+int32_t libmpq__decompress_pkzip(uint8_t *in_buf, uint32_t in_size, uint8_t *out_buf, uint32_t out_size) {
+
+	/* some common variables. */
+	int32_t tb = 0;
+	uint8_t *work_buf;
+	pkzip_data_s info;
+
+	/* allocate memory for pkzip data structure. */
+	if ((work_buf = malloc(sizeof(pkzip_cmp_s))) == NULL) {
+
+		/* memory allocation problem. */
+		return LIBMPQ_ERROR_MALLOC;
+	}
+
+	/* cleanup. */
+	memset(work_buf, 0, sizeof(pkzip_cmp_s));
+
+	/* fill data information structure. */
+	info.in_buf   = in_buf;
+	info.in_pos   = 0;
+	info.in_bytes = in_size;
+	info.out_buf  = out_buf;
+	info.out_pos  = 0;
+	info.max_out  = out_size;
+
+	/* do the decompression. */
+	if ((tb = libmpq__do_decompress_pkzip(work_buf, &info)) < 0) {
+
+		/* free working buffer. */
+		free(work_buf);
+
+		/* something failed on pkzip decompression. */
+		return tb;
+	}
+
+	/* save transferred bytes. */
+	tb = info.out_pos;
+
+	/* free working buffer. */
+	free(work_buf);
+
+	/* return transferred bytes. */
+	return tb;
+}
+
+/* this function decompress a stream using bzip2 library. */
+int32_t libmpq__decompress_bzip2(uint8_t *in_buf, uint32_t in_size, uint8_t *out_buf, uint32_t out_size) {
+
+	/* some common variables. */
+	int32_t result = 0;
+	int32_t tb     = 0;
+	bz_stream strm;
+
+	/* initialize the bzlib decompression. */
+	strm.bzalloc = NULL;
+	strm.bzfree  = NULL;
+
+	/* initialize the structure. */
+	if ((result = BZ2_bzDecompressInit(&strm, 0, 0)) != BZ_OK) {
+
+		/* something on bzlib initialization failed. */
+		return result;
+	}
+
+	/* fill the stream structure for bzlib. */
+	strm.next_in   = (char *)in_buf;
+	strm.avail_in  = in_size;
+	strm.next_out  = (char *)out_buf;
+	strm.avail_out = out_size;
+
+	/* do the decompression. */
+	while (BZ2_bzDecompress(&strm) != BZ_STREAM_END);
+
+	/* save transferred bytes. */
+	tb = strm.total_out_lo32;
+
+	/* cleanup of bzip stream. */
+	BZ2_bzDecompressEnd(&strm);
+
+	/* return transferred bytes. */
+	return tb;
+}
+
+/* this function decompress a stream using wave algorithm. (1 channel) */
+int32_t libmpq__decompress_wave_mono(uint8_t *in_buf, uint32_t in_size, uint8_t *out_buf, uint32_t out_size) {
+
+	/* some common variables. */
+	int32_t tb = 0;
+
+	/* save the number of copied bytes. */
+	if ((tb = libmpq__do_decompress_wave(out_buf, out_size, in_buf, in_size, 1)) < 0) {
+
+		/* something on wave decompression failed. */
+		return tb;
+	}
+
+	/* return transferred bytes. */
+	return tb;
+}
+
+/* this function decompress a stream using wave algorithm. (2 channels) */
+int32_t libmpq__decompress_wave_stereo(uint8_t *in_buf, uint32_t in_size, uint8_t *out_buf, uint32_t out_size) {
+
+	/* some common variables. */
+	int32_t tb = 0;
+
+	/* save the number of copied bytes. */
+	if ((tb = libmpq__do_decompress_wave(out_buf, out_size, in_buf, in_size, 2)) < 0) {
+
+		/* something on wave decompression failed. */
+		return tb;
+	}
+
+	/* return transferred bytes. */
+	return tb;
+}
+
+/* this function decompress a stream using a combination of the other compression algorithm. */
+int32_t libmpq__decompress_multi(uint8_t *in_buf, uint32_t in_size, uint8_t *out_buf, uint32_t out_size) {
+
+	/* some common variables. */
+	int32_t tb        = 0;
+	uint32_t count    = 0;
+	uint32_t entries  = (sizeof(dcmp_table) / sizeof(decompress_table_s));
+	uint8_t *temp_buf = NULL;
+	uint8_t *work_buf = 0;
+	uint8_t decompress_flag, decompress_unsupp;
+	uint32_t i;
+
+	/* get applied compression types. */
+	decompress_flag = decompress_unsupp = *in_buf++;
+
+	/* decrement data size. */
+	in_size--;
+
+	/* search decompression table type and get all types of compression. */
+	for (i = 0; i < entries; i++) {
+
+		/* check if have to apply this decompression. */
+		if (decompress_flag & dcmp_table[i].mask) {
+
+			/* increase counter for used compression algorithms. */
+			count++;
+			/* this algorithm is supported, remove from unsupp mask */
+			decompress_unsupp &= ~dcmp_table[i].mask;
+		}
+	}
+
+	/* check if there is some method unhandled. (e.g. compressed by future versions) */
+	if (decompress_unsupp) {
+
+		/* compression type is unknown and we need to implement it. :) */
+		return LIBMPQ_ERROR_UNPACK;
+	}
+
+	/* if multiple decompressions should be made, we need temporary buffer for the data. */
+	if (count > 1) {
+
+		/* allocate memory for temporary buffer. */
+		if ((temp_buf = malloc(out_size)) == NULL) {
+
+			/* memory allocation problem. */
+			return LIBMPQ_ERROR_MALLOC;
+		}
+
+		/* cleanup. */
+		memset(temp_buf, 0, out_size);
+	}
+
+	/* apply all decompressions. */
+	for (i = 0, count = 0; i < entries; i++) {
+
+		/* check if not used this kind of compression. */
+		if (decompress_flag & dcmp_table[i].mask) {
+
+			/* if multiple decompressions should be made, we need temporary buffer for the data. */
+			if (count == 0) {
+
+				/* use output buffer as working buffer. */
+				work_buf = out_buf;
+			} else {
+
+				/* use temporary buffer as working buffer. */
+				work_buf = temp_buf;
+			}
+
+			/* decompress buffer using corresponding function. */
+			if ((tb = dcmp_table[i].decompress(in_buf, in_size, work_buf, out_size)) < 0) {
+
+				/* free temporary buffer. */
+				free(temp_buf);
+
+				/* something on decompression failed. */
+				return tb;
+			}
+
+			/* move output size to source size for next compression. */
+			in_size = out_size;
+			in_buf  = work_buf;
+
+			/* increase counter. */
+			count++;
+		}
+	}
+
+	/* if output buffer is not the same like target buffer, we have to copy data (this will happen on multiple decompressions). */
+	if (work_buf != out_buf) {
+
+		/* copy buffer. */
+		memcpy(out_buf, in_buf, out_size);
+	}
+
+	/* free temporary buffer. */
+	free(temp_buf);
+
+	/* return transferred bytes. */
+	return tb;
+}
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/extract.h temp-build/maptools/vmap_extractor/libmpq04/extract.h
--- clean-build/maptools/vmap_extractor/libmpq04/extract.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/extract.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,106 @@
+/*
+ *  extract.h -- header for the extraction functions used by mpq-tools.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */       
+
+#ifndef _EXTRACT_H
+#define _EXTRACT_H
+
+/* define compression types for multilpe compressions. */
+#define LIBMPQ_COMPRESSION_HUFFMAN		0x01		/* huffman compression. (used on wave files only and introduced in starcraft) */
+#define LIBMPQ_COMPRESSION_ZLIB			0x02		/* zlib compression. (introduced in warcraft 3) */
+#define LIBMPQ_COMPRESSION_PKZIP		0x08		/* pkware dcl compression. (first used compression algorithm) */
+#define LIBMPQ_COMPRESSION_BZIP2		0x10		/* bzip compression. (introduced in warcraft 3 - the frozen throne) */
+#define LIBMPQ_COMPRESSION_WAVE_MONO		0x40		/* adpcm 4:1 compression. (introduced in starcraft) */
+#define LIBMPQ_COMPRESSION_WAVE_STEREO		0x80		/* adpcm 4:1 compression. (introduced in starcraft) */
+
+/*
+ *  table for decompression functions, return value for all functions
+ *  is the transferred data size or one of the following error constants:
+ *
+ *  LIBMPQ_ERROR_MALLOC
+ *  LIBMPQ_ERROR_DECOMPRESS
+ */
+typedef int32_t		(*DECOMPRESS)(uint8_t *, uint32_t, uint8_t *, uint32_t);
+typedef struct {
+	uint32_t	mask;			/* decompression bit. */
+	DECOMPRESS	decompress;		/* decompression function. */
+} decompress_table_s;
+
+/*
+ *  huffman decompression routine, the in_size parameter is not used,
+ *  but needs to be specified due to compatibility reasons.
+ *
+ *  1500F5F0
+ */
+extern int32_t libmpq__decompress_huffman(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint8_t		*out_buf,
+	uint32_t	out_size
+);
+
+/* decompression using zlib. */
+extern int32_t libmpq__decompress_zlib(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint8_t		*out_buf,
+	uint32_t	out_size
+);
+
+/* decompression using pkzip. */
+extern int32_t libmpq__decompress_pkzip(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint8_t		*out_buf,
+	uint32_t	out_size
+);
+
+/* decompression using bzip2. */
+extern int32_t libmpq__decompress_bzip2(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint8_t		*out_buf,
+	uint32_t	out_size
+);
+
+/* decompression using wave. (1 channel) */
+extern int32_t libmpq__decompress_wave_mono(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint8_t		*out_buf,
+	uint32_t	out_size
+);
+
+/* decompression using wave. (2 channels) */
+extern int32_t libmpq__decompress_wave_stereo(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint8_t		*out_buf,
+	uint32_t	out_size
+);
+
+/* decompression using multiple of the above algorithm. */
+extern int32_t libmpq__decompress_multi(
+	uint8_t		*in_buf,
+	uint32_t	in_size,
+	uint8_t		*out_buf,
+	uint32_t	out_size
+);
+
+#endif						/* _EXTRACT_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/huffman.c temp-build/maptools/vmap_extractor/libmpq04/huffman.c
--- clean-build/maptools/vmap_extractor/libmpq04/huffman.c	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/huffman.c	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,1101 @@
+/*
+ *  huffman.c -- functions do decompress files in mpq files which
+ *               uses a modified huffman version.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  Differences between C++ and C version:
+ *
+ *    - Removed the object oriented stuff.
+ *    - Replaced the goto things with some better C code.
+ *
+ *  This source was adepted from the C++ version of huffman.cpp included
+ *  in stormlib. The C++ version belongs to the following authors:
+ *
+ *  Ladislav Zezula <ladik@zezula.net>
+ *  ShadowFlare <BlakFlare@hotmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* generic includes. */
+#include <stdlib.h>
+#include <string.h>
+
+/* libmpq main includes. */
+#include "mpq.h"
+#include "mpq-internal.h"
+
+/* libmpq generic includes. */
+#include "huffman.h"
+
+/* tables for huffman tree. */
+static const uint8_t table_1502A630[] = {
+
+	/* data for compression type 0x00. */
+	0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
+	0x00, 0x00,
+
+	/* data for compression type 0x01. */
+	0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08, 0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04, 0x03, 0x05,
+	0x0E, 0x0B, 0x14, 0x13, 0x13, 0x09, 0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02,
+	0x0D, 0x07, 0x09, 0x06, 0x06, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02,
+	0x09, 0x06, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04,
+	0x08, 0x03, 0x04, 0x07, 0x09, 0x05, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02,
+	0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
+	0x06, 0x0A, 0x08, 0x08, 0x06, 0x07, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03,
+	0x04, 0x03, 0x07, 0x07, 0x09, 0x06, 0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02,
+	0x0A, 0x02, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05, 0x02, 0x03,
+	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01,
+	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x04, 0x07, 0x09, 0x08, 0x0C, 0x02,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03,
+	0x04, 0x01, 0x02, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
+	0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x4B,
+	0x00, 0x00,
+
+	/* data for compression type 0x02. */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x23, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x06, 0x0E, 0x10, 0x04,
+	0x06, 0x08, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01,
+	0x01, 0x04, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x03, 0x03, 0x02,
+	0x03, 0x01, 0x03, 0x06, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01,
+	0x01, 0x29, 0x07, 0x16, 0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03, 0x17, 0x10, 0x26, 0x2A,
+	0x10, 0x01, 0x23, 0x23, 0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+
+	/* data for compression type 0x03. */
+	0xFF, 0x0B, 0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02, 0x02, 0x01, 0x04, 0x02, 0x01, 0x03,
+	0x09, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
+	0x05, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x02, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
+	0x0A, 0x04, 0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01,
+	0x05, 0x02, 0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03,
+	0x01, 0x03, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x05, 0x01, 0x03, 0x01, 0x03, 0x03,
+	0x02, 0x01, 0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x02, 0x02, 0x01, 0x0A, 0x02, 0x05, 0x01, 0x01, 0x02, 0x07, 0x02, 0x17, 0x01, 0x05, 0x01, 0x01,
+	0x0E, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x06, 0x02, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
+	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11,
+	0x00, 0x00,
+
+	/* data for compression type 0x04. */
+	0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64, 0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+
+	/* data for compression type 0x05. */
+	0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B, 0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88, 0x80, 0x82,
+	0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B, 0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41, 0x37, 0x37,
+	0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21, 0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10, 0x0D, 0x0D,
+	0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04, 0x19, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+
+	/* data for compression type 0x06. */
+	0xC3, 0xCB, 0xF5, 0x41, 0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xBF, 0xCC, 0xF2, 0x40, 0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x7A, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+
+	/* data for compression type 0x07. */
+	0xC3, 0xD9, 0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB, 0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xBD, 0xD9, 0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE, 0xF0, 0x2C, 0xFB, 0x5C, 0xFF, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x70, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+
+	/* data for compression type 0x08. */
+	0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18, 0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10,
+	0xEE, 0xAF, 0xE4, 0x2C, 0xEA, 0x5A, 0xDE, 0x15, 0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18, 0xE7, 0x95, 0xD8, 0x23, 0xDB, 0x49, 0xD0, 0x11,
+	0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15, 0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF, 0x13,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x5F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00
+};
+
+/* this function insert an item to a huffman tree. */
+void libmpq__huffman_insert_item(struct huffman_tree_item_s **p_item, struct huffman_tree_item_s *item, uint32_t where, struct huffman_tree_item_s *item2) {
+
+	/* EDI - next to the first item. */
+	struct huffman_tree_item_s *next = item->next;
+
+	/* ESI - prev to the first item. */
+	struct huffman_tree_item_s *prev = item->prev;
+
+	/* pointer to previous item. */
+	struct huffman_tree_item_s *prev2;
+
+	/* pointer to next item. */
+	long next2;
+
+	/* check the first item already has next one. */
+	if (next != 0) {
+
+		/* check if previous item exist. */
+		if (PTR_INT(prev) < 0) {
+
+			/* return previous item. */
+			prev = PTR_NOT(prev);
+		} else {
+
+			/* add item. */
+			prev += (item - next->prev);
+		}
+
+		/* 150083C1 - remove the item from the tree. */
+		prev->next = next;
+		next->prev = prev;
+
+		/* invalidate prev and next pointer. */
+		item->next = 0;
+		item->prev = 0;
+	}
+
+	/* EDX - check if the second item is not entered. */
+	if (item2 == NULL) {
+
+		/* take the first tree item. */
+		item2 = PTR_PTR(&p_item[1]);
+	}
+
+	/* check if items should be switched or new one inserted. */
+	switch (where) {
+		case SWITCH_ITEMS:
+
+			/* item2->next (pointer to pointer to first). */
+			item->next        = item2->next;
+			item->prev        = item2->next->prev;
+			item2->next->prev = item;
+
+			/* set the first item. */
+			item2->next       = item;
+
+			/* return from function. */
+			return;
+		case INSERT_ITEM:
+
+			/* set next item (or pointer to pointer to first item) - insert as last item. */
+			item->next = item2;
+
+			/* set previous item (or last item in the tree). */
+			item->prev = item2->prev;
+
+			/* usually NULL. */
+			next2      = PTR_INT(p_item[0]);
+
+			/* previous item to the second (or last tree item). */
+			prev2      = item2->prev;
+
+			/* check if previous item is a valid pointer. */
+			if (PTR_INT(prev2) < 0) {
+
+				/* set values. */
+				prev2       = PTR_NOT(prev);
+				prev2->next = item;
+
+				/* next after last item. */
+				item2->prev = item;
+
+				/* return from function. */
+				return;
+			}
+
+			/* check if next item is empty. */
+			if (next2 < 0) {
+
+				/* set next item. */
+				next2 = item2 - item2->next->prev;
+			}
+
+			/* add next item to previous one. */
+			prev2       += next2;
+			prev2->next  = item;
+
+			/* set the next and last item. */
+			item2->prev  = item;
+
+			/* return from function. */
+			return;
+		default:
+
+			/* nothing to do, so return from function. */
+			return;
+	}
+}
+
+/* 1500BC90 - remove item from huffman tree.*/
+void libmpq__huffman_remove_item(struct huffman_tree_item_s *hi) {
+
+	/* EDX - some common variables. */
+	struct huffman_tree_item_s *temp;
+
+	/* check if next item is not empty. */
+	if (hi->next != NULL) {
+
+		/* fetch previous item. */
+		temp = hi->prev;
+
+		/* check if previous item is a pointer. */
+		if (PTR_INT(temp) <= 0) {
+			temp = PTR_NOT(temp);
+		} else {
+			temp += (hi - hi->next->prev);
+		}
+
+		/* reorganize tree. */
+		temp->next     = hi->next;
+		hi->next->prev = hi->prev;
+		hi->next       = hi->prev = NULL;
+	}
+}
+
+/* get previous huffman tree item. */
+struct huffman_tree_item_s *libmpq__huffman_previous_item(struct huffman_tree_item_s *hi, long value) {
+
+	/* check if previous item exist. */
+	if (PTR_INT(hi->prev) < 0) {
+
+		/* return previous item. */
+		return PTR_NOT(hi->prev);
+	}
+
+	/* check if something else should returned. */
+	if (value < 0) {
+
+		/* fetch previous item of next item. */
+		value = hi - hi->next->prev;
+	}
+
+	/* return previous item with value. */
+	return hi->prev + value;
+}
+
+/* get one bit from input stream. */
+uint32_t libmpq__huffman_get_1bit(struct huffman_input_stream_s *is) {
+
+	/* some common variables. */
+	uint32_t bit = (is->bit_buf & 1);
+
+	/* shift bit right by one. */
+	is->bit_buf >>= 1;
+
+	/* check if we should extract bits. */
+	if (--is->bits == 0) {
+		is->bit_buf  = *(uint32_t *)is->in_buf;
+		is->in_buf  += sizeof(int32_t);
+		is->bits     = 32;
+	}
+
+	/* return the bit. */
+	return bit;
+}
+
+/* get 7 bits from the input stream. */
+uint32_t libmpq__huffman_get_7bit(struct huffman_input_stream_s *is) {
+
+	/* check if we should extract bits. */
+	if (is->bits <= 7) {
+		is->bit_buf |= *(uint16_t *)is->in_buf << is->bits;
+		is->in_buf  += sizeof(int16_t);
+		is->bits    += 16;
+	}
+
+	/* get 7 bits from input stream. */
+	return (is->bit_buf & 0x7F);
+}
+
+/* get the whole byte from the input stream. */
+uint32_t libmpq__huffman_get_8bit(struct huffman_input_stream_s *is) {
+
+	/* some common variables. */
+	uint32_t one_byte;
+
+	/* check if we should extract bits. */
+	if (is->bits <= 8) {
+		is->bit_buf |= *(uint16_t *)is->in_buf << is->bits;
+		is->in_buf  += sizeof(int16_t);
+		is->bits    += 16;
+	}
+
+	/* fill values. */
+	one_byte      = (is->bit_buf & 0xFF);
+	is->bit_buf >>= 8;
+	is->bits     -= 8;
+
+	/* return the 8 bits. */
+	return one_byte;
+}
+
+/* return struct for 1500E740. */
+struct huffman_tree_item_s *libmpq__huffman_call_1500E740(struct huffman_tree_s *ht) {
+
+	/* EDX */
+	struct huffman_tree_item_s *p_item1 = ht->item3058;
+
+	/* EAX */
+	struct huffman_tree_item_s *p_item2;
+
+	/* some common variables. */
+	struct huffman_tree_item_s *p_next;
+	struct huffman_tree_item_s *p_prev;
+	struct huffman_tree_item_s **pp_item;
+
+	/* check if item is empty. */
+	if (PTR_INT(p_item1) <= 0 || (p_item2 = p_item1) == NULL) {
+
+		/* check if item is not empty. */
+		if ((p_item2 = &ht->items0008[ht->items++]) != NULL) {
+			p_item1 = p_item2;
+		} else {
+			p_item1 = ht->first;
+		}
+	} else {
+		p_item1 = p_item2;
+	}
+
+	/* set next item. */
+	p_next = p_item1->next;
+
+	/* check if next item is not empty. */
+	if (p_next != NULL) {
+
+		/* set previous item. */
+		p_prev = p_item1->prev;
+
+		/* check if previous item is a valid pointer. */
+		if (PTR_INT(p_prev) <= 0) {
+			p_prev = PTR_NOT(p_prev);
+		} else {
+			p_prev += (p_item1 - p_item1->next->prev);
+		}
+
+		/* fill values. */
+		p_prev->next  = p_next;
+		p_next->prev  = p_prev;
+		p_item1->next = NULL;
+		p_item1->prev = NULL;
+	}
+
+	/* ESI */
+	pp_item       = &ht->first;
+	p_item1->next = (struct huffman_tree_item_s *)pp_item;
+	p_item1->prev = pp_item[1];
+
+	/* EDI = ht->item305C - ECX */
+	p_prev = pp_item[1];
+
+	/* check if previous pointer is valid. */
+	if (p_prev <= 0) {
+
+		/* fill values. */
+		p_prev          = PTR_NOT(p_prev);
+		p_prev->next    = p_item1;
+		p_prev->prev    = p_item2;
+		p_item2->parent = NULL;
+		p_item2->child  = NULL;
+	} else {
+
+		/* check if pointer is valid. */
+		if (PTR_INT(ht->item305C) < 0) {
+			p_prev += (struct huffman_tree_item_s *)pp_item - (*pp_item)->prev;
+		} else {
+			p_prev += PTR_INT(ht->item305C);
+		}
+
+		/* fill values. */
+		p_prev->next    = p_item1;
+		pp_item[1]      = p_item2;
+		p_item2->parent = NULL;
+		p_item2->child  = NULL;
+	}
+
+	/* return item. */
+	return p_item2;
+}
+
+/* return struct for 1500E820. */
+void libmpq__huffman_call_1500E820(struct huffman_tree_s *ht, struct huffman_tree_item_s *p_item) {
+
+	/* EDI */
+	struct huffman_tree_item_s *p_item1;
+
+	/* EAX */
+	struct huffman_tree_item_s *p_item2 = NULL;
+
+	/* EDX */
+	struct huffman_tree_item_s *p_item3;
+
+	/* EBX */
+	struct huffman_tree_item_s *p_prev;
+
+	/* loop through parent items. */
+	for (; p_item != NULL; p_item = p_item->parent) {
+
+		/* increase byte counter. */
+		p_item->byte_value++;
+
+		/* loop through previous items. */
+		for (p_item1 = p_item; ; p_item1 = p_prev) {
+
+			/* set previous item. */
+			p_prev = p_item1->prev;
+
+			/* check if pointer is valid. */
+			if (PTR_INT(p_prev) <= 0) {
+				p_prev = NULL;
+				break;
+			}
+
+			/* check if byte value of previous item is higher than actual item. */
+			if (p_prev->byte_value >= p_item->byte_value) {
+				break;
+			}
+		}
+
+		/* check if previous item is same like actual item. */
+		if (p_item1 == p_item) {
+			continue;
+		}
+
+		/* check if next item is not empty, */
+		if (p_item1->next != NULL) {
+
+			/* fill values. */
+			p_item2             = libmpq__huffman_previous_item(p_item1, -1);
+			p_item2->next       = p_item1->next;
+			p_item1->next->prev = p_item1->prev;
+			p_item1->next       = NULL;
+			p_item1->prev       = NULL;
+		}
+
+		/* fill values. */
+		p_item2       = p_item->next;
+		p_item1->next = p_item2;
+		p_item1->prev = p_item2->prev;
+		p_item2->prev = p_item1;
+		p_item->next  = p_item1;
+
+		/* check if both items are not empty. */
+		if ((p_item2 = p_item1) != NULL) {
+
+			/* fill values. */
+			p_item2            = libmpq__huffman_previous_item(p_item, -1);
+			p_item2->next      = p_item->next;
+			p_item->next->prev = p_item->prev;
+			p_item->next       = NULL;
+			p_item->prev       = NULL;
+		}
+
+		/* check if previous item is empty. */
+		if (p_prev == NULL) {
+			p_prev = PTR_PTR(&ht->first);
+		}
+
+		/* fill values. */
+		p_item2       = p_prev->next;
+		p_item->next  = p_item2;
+		p_item->prev  = p_item2->prev;
+		p_item2->prev = p_item;
+		p_prev->next  = p_item;
+		p_item3       = p_item1->parent->child;
+		p_item2       = p_item->parent;
+
+		/* check if child item and parent item match. */
+		if (p_item2->child == p_item) {
+			p_item2->child = p_item1;
+		}
+
+		/* check if items match. */
+		if (p_item3 == p_item1) {
+			p_item1->parent->child = p_item;
+		}
+
+		/* fill values. */
+		p_item2         = p_item->parent;
+		p_item->parent  = p_item1->parent;
+		p_item1->parent = p_item2;
+
+		/* increase counter. */
+		ht->offs0004++;
+	}
+}
+
+/* this function initialize a huffman tree. */
+void libmpq__huffman_tree_init(struct huffman_tree_s *ht, uint32_t cmp) {
+
+	/* some common variables. */
+	uint32_t count;
+	struct huffman_tree_item_s *hi;
+
+	/* clear links for all the items in the tree. */
+	for (hi = ht->items0008, count = 0x203; count != 0; hi++, count--) {
+		hi->next = hi->prev = NULL;
+	}
+
+	/* fill values. */
+	ht->item3050 = NULL;
+	ht->item3054 = PTR_PTR(&ht->item3054);
+	ht->item3058 = PTR_NOT(ht->item3054);
+	ht->item305C = NULL;
+	ht->first    = PTR_PTR(&ht->first);
+	ht->last     = PTR_NOT(ht->first);
+	ht->offs0004 = 1;
+	ht->items    = 0;
+
+	/* clear all huffman decompress items, do this only if preparing for decompression. */
+	if (cmp == LIBMPQ_HUFF_DECOMPRESS) {
+		for (count = 0; count < sizeof(ht->qd3474) / sizeof(struct huffman_decompress_s); count++) {
+			ht->qd3474[count].offs00 = 0;
+		}
+	}
+}
+
+/* this function build a huffman tree, called with the first 8 bits loaded from input stream. */
+void libmpq__huffman_tree_build(struct huffman_tree_s *ht, uint32_t cmp_type) {
+
+	/* [ESP+10] - the greatest character found in table. */
+	uint32_t max_byte;
+
+	/* [ESP+1C] - pointer to uint8_t in table_1502A630. */
+	const uint8_t *byte_array;
+
+	/* thats needed to replace the goto stuff from original source. :) */
+	uint32_t found;
+
+	/* [ESP+14] - Pointer to Huffman tree item pointer array. */
+	struct huffman_tree_item_s **p_item;
+	struct huffman_tree_item_s *child1;
+
+	/* some common variables. */
+	uint32_t i;
+
+	/* ESI - loop while pointer has a negative value (last entry). */
+	while (PTR_INT(ht->last) > 0) {
+
+		/* EAX */
+		struct huffman_tree_item_s *temp;
+
+		/* ESI->next */
+		if (ht->last->next != NULL) {
+			libmpq__huffman_remove_item(ht->last);
+		}
+
+		/* [EDI+4] */
+		ht->item3058   = PTR_PTR(&ht->item3054);
+
+		/* EAX */
+		ht->last->prev = ht->item3058;
+		temp           = libmpq__huffman_previous_item(PTR_PTR(&ht->item3054), PTR_INT(&ht->item3050));
+		temp->next     = ht->last;
+		ht->item3054   = ht->last;
+	}
+
+	/* clear all pointers in huffman tree item array. */
+	memset(ht->items306C, 0, sizeof(ht->items306C));
+
+	/* greatest character found init to zero. */
+	max_byte    = 0;
+
+	/* pointer to current entry in huffman tree item pointer array. */
+	p_item      = (struct huffman_tree_item_s **)&ht->items306C;
+
+	/* ensure we have low 8 bits only. */
+	cmp_type   &= 0xFF;
+
+	/* EDI also. */
+	byte_array  = table_1502A630 + cmp_type * 258;
+
+	/* loop to build huffman tree. */
+	for (i = 0; i < 0x100; i++, p_item++) {
+
+		/* item to be created. */
+		struct huffman_tree_item_s *item    = ht->item3058;
+		struct huffman_tree_item_s *p_item3 = ht->item3058;
+		uint8_t one_byte                  = byte_array[i];
+
+		/* skip all the bytes which are zero. */
+		if (byte_array[i] == 0) {
+			continue;
+		}
+
+		/* if not valid pointer, take the first available item in the array. */
+		if (PTR_INT(item) <= 0) {
+			item = &ht->items0008[ht->items++];
+		}
+
+		/* insert this item as the top of the tree. */
+		libmpq__huffman_insert_item(&ht->item305C, item, SWITCH_ITEMS, NULL);
+
+		/* invalidate child and parent. */
+		item->parent     = NULL;
+		item->child      = NULL;
+
+		/* store pointer into pointer array. */
+		*p_item          = item;
+
+		/* store counter. */
+		item->dcmp_byte  = i;
+
+		/* store byte value. */
+		item->byte_value = one_byte;
+
+		/* check if byte is to big. */
+		if (one_byte >= max_byte) {
+
+			/* set max byte to highest value. */
+			max_byte = one_byte;
+
+			/* continue loop. */
+			continue;
+		}
+
+		/* find the first item which has byte value greater than current one byte. */
+		found = 0;
+
+		/* EDI - Pointer to the last item. */
+		if (PTR_INT((p_item3 = ht->last)) > 0) {
+
+			/* 15006AF7 */
+			if (p_item3 != NULL) {
+
+				/* 15006AFB */
+				do {
+
+					/* check if we found item. */
+					if (p_item3->byte_value >= one_byte) {
+						found = 1;
+						break;
+					}
+
+					/* switch to previous item. */
+					p_item3 = p_item3->prev;
+				} while (PTR_INT(p_item3) > 0);
+			}
+		}
+
+		/* check if item was not found. */
+		if (found == 0) {
+			p_item3 = NULL;
+		}
+
+		/* 15006B09 */
+		if (item->next != NULL) {
+			libmpq__huffman_remove_item(item);
+		}
+
+		/* 15006B15 */
+		if (p_item3 == NULL) {
+			p_item3 = PTR_PTR(&ht->first);
+		}
+
+		/* 15006B1F */
+		item->next          = p_item3->next;
+		item->prev          = p_item3->next->prev;
+		p_item3->next->prev = item;
+		p_item3->next       = item;
+	}
+
+	/* 15006B4A */
+	for (; i < 0x102; i++) {
+
+		/* EDI */
+		struct huffman_tree_item_s **p_item2 = &ht->items306C[i];
+
+		/* 15006B59 - ESI */
+		struct huffman_tree_item_s *item2 = ht->item3058;
+
+		/* check if item is a valid pointer. */
+		if (PTR_INT(item2) <= 0) {
+			item2 = &ht->items0008[ht->items++];
+		}
+
+		/* insert the item into tree. */
+		libmpq__huffman_insert_item(&ht->item305C, item2, INSERT_ITEM, NULL);
+
+		/* 15006B89 */
+		item2->dcmp_byte  = i;
+		item2->byte_value = 1;
+		item2->parent     = NULL;
+		item2->child      = NULL;
+		*p_item2++        = item2;
+	}
+
+	/* 15006BAA - EDI - last item (first child to item). */
+	if (PTR_INT((child1 = ht->last)) > 0) {
+
+		/* EBP */
+		struct huffman_tree_item_s *child2;
+
+		/* ESI */
+		struct huffman_tree_item_s *item;
+
+		/* 15006BB8 */
+		while (PTR_INT((child2 = child1->prev)) > 0) {
+			if (PTR_INT((item = ht->item3058)) <= 0) {
+				item = &ht->items0008[ht->items++];
+			}
+
+			/* 15006BE3 */
+			libmpq__huffman_insert_item(&ht->item305C, item, SWITCH_ITEMS, NULL);
+
+			/* 15006BF3 */
+			item->parent = NULL;
+			item->child  = NULL;
+
+			/*
+			 * EDX = child2->byte_value + child1->byte_value;
+			 * EAX = child1->byte_value;
+			 * ECX = max_byte; (the greatest character (0xFF usually))
+			 *       item->byte_value (0x02 usually)
+			 */
+			item->byte_value = child1->byte_value + child2->byte_value;
+
+			/* previous item in the tree. */
+			item->child      = child1;
+			child1->parent   = item;
+			child2->parent   = item;
+
+			/* EAX = item->byte_value */
+			if (item->byte_value >= max_byte) {
+				max_byte = item->byte_value;
+			} else {
+
+				/* EDI */
+				struct huffman_tree_item_s *p_item2 = child2->prev;
+				found = 0;
+
+				/* check if item is a valid pointer. */
+				if (PTR_INT(p_item2) > 0) {
+
+					/* 15006C2D */
+					do {
+
+						/* check if we found item. */
+						if (p_item2->byte_value >= item->byte_value) {
+							found = 1;
+							break;
+						}
+
+						/* switch to previous item. */
+						p_item2 = p_item2->prev;
+					} while (PTR_INT(p_item2) > 0);
+				}
+
+				/* check if item was not found. */
+				if (found == 0) {
+					p_item2 = NULL;
+				}
+
+				/* check if next item exist. */
+				if (item->next != 0) {
+
+					/* some common variables. */
+					struct huffman_tree_item_s *temp4 = libmpq__huffman_previous_item(item, -1);
+
+					/* zhe first item changed. */
+					temp4->next                     = item->next;
+
+					/* first->prev changed to negative value. */
+					item->next->prev                = item->prev;
+					item->next                      = NULL;
+					item->prev                      = NULL;
+				}
+
+				/* 15006C62 */
+				if (p_item2 == NULL) {
+					p_item2 = PTR_PTR(&ht->first);
+				}
+
+				/* set item with 0x100 byte value. */
+				item->next          = p_item2->next;
+
+				/* set item with 0x17 byte value. */
+				item->prev          = p_item2->next->prev;
+
+				/* changed prev of item with. */
+				p_item2->next->prev = item;
+				p_item2->next       = item;
+			}
+
+			/* 15006C7B */
+			if (PTR_INT((child1 = child2->prev)) <= 0) {
+				break;
+			}
+		}
+	}
+
+	/* 15006C88 */
+	ht->offs0004 = 1;
+}
+
+/* this function did the real decompression. */
+int32_t libmpq__do_decompress_huffman(struct huffman_tree_s *ht, struct huffman_input_stream_s *is, uint8_t *out_buf, uint32_t out_length) {
+
+	/* some common variables. */
+	uint32_t dcmp_byte = 0;
+	uint8_t *out_pos = out_buf;
+	uint32_t bit_count;
+	struct huffman_decompress_s *qd;
+	struct huffman_tree_item_s *p_item1;
+	struct huffman_tree_item_s *p_item2;
+
+	/* 8 bits loaded from input stream. */
+	uint32_t n8bits;
+
+	/* 7 bits loaded from input stream. */
+	uint32_t n7bits;
+
+	/* thats needed to replace the goto stuff from original source. :) */
+	uint32_t found;
+
+	/* can we use quick decompression */
+	uint32_t has_qd;
+
+	/* test the output length, must not be non zero. */
+	if (out_length == 0) {
+		return 0;
+	}
+
+	/* get the compression type from the input stream. */
+	n8bits = libmpq__huffman_get_8bit(is);
+
+	/* build the Huffman tree. */
+	libmpq__huffman_tree_build(ht, n8bits);
+
+	/* compression 8 bit or not? */
+	ht->cmp0 = (n8bits == 0) ? TRUE : FALSE;
+
+	/* loop until break. */
+	for(;;) {
+
+		/* get 7 bits from input stream. */
+		n7bits = libmpq__huffman_get_7bit(is);
+
+		/* try to use quick decompression, check huffman decompress struct for corresponding item. */
+		qd = &ht->qd3474[n7bits];
+
+		/* if there is a quick-pass possible (ebx). */
+		has_qd = (qd->offs00 >= ht->offs0004) ? TRUE : FALSE;
+
+		/* if we can use quick decompress, use it. */
+		if (has_qd) {
+			found = 0;
+			if (qd->bits > 7) {
+				is->bit_buf >>= 7;
+				is->bits     -= 7;
+				p_item1       = qd->p_item;
+				found         = 1;
+			}
+			if (found == 0) {
+				is->bit_buf >>= qd->bits;
+				is->bits     -= qd->bits;
+				dcmp_byte     = qd->dcmp_byte;
+			}
+		} else {
+			found = 1;
+			p_item1 = ht->first->next->prev;
+			if (PTR_INT(p_item1) <= 0) {
+				p_item1 = NULL;
+			}
+		}
+
+		/* check if item was found. */
+		if (found == 1) {
+			bit_count = 0;
+			p_item2   = NULL;
+
+			/* loop until tree has no deeper level. */
+			do {
+
+				/* move down by one level. */
+				p_item1 = p_item1->child;
+
+				/* check if current bit is set, move to previous. */
+				if (libmpq__huffman_get_1bit(is)) {
+					p_item1 = p_item1->prev;
+				}
+
+				/* check if we are at 7th bit, save current huffman tree item. */
+				if (++bit_count == 7) {
+					p_item2 = p_item1;
+				}
+			} while (p_item1->child != NULL);
+
+			/* no quick decompression. :( */
+			if (has_qd == FALSE) {
+
+				/* check bit counter. */
+				if (bit_count > 7) {
+					qd->offs00 = ht->offs0004;
+					qd->bits   = bit_count;
+					qd->p_item = p_item2;
+				} else {
+					uint32_t index = n7bits & (0xFFFFFFFF >> (32 - bit_count));
+					uint32_t add   = (1 << bit_count);
+
+					/* loop through compression. */
+					for (qd = &ht->qd3474[index]; index <= 0x7F; index += add, qd += add) {
+						qd->offs00    = ht->offs0004;
+						qd->bits      = bit_count;
+						qd->dcmp_byte = p_item1->dcmp_byte;
+					}
+				}
+			}
+
+			/* set compression byte. */
+			dcmp_byte = p_item1->dcmp_byte;
+		}
+
+		/* check if huffman tree needs to be modified. */
+		if (dcmp_byte == 0x101)	{
+
+			/* fill values. */
+			n8bits                            = libmpq__huffman_get_8bit(is);
+			p_item1                           = (ht->last <= 0) ? NULL : ht->last;
+			p_item2                           = libmpq__huffman_call_1500E740(ht);
+			p_item2->parent                   = p_item1;
+			p_item2->dcmp_byte                = p_item1->dcmp_byte;
+			p_item2->byte_value               = p_item1->byte_value;
+			ht->items306C[p_item2->dcmp_byte] = p_item2;
+			p_item2                           = libmpq__huffman_call_1500E740(ht);
+			p_item2->parent                   = p_item1;
+			p_item2->dcmp_byte                = n8bits;
+			p_item2->byte_value               = 0;
+			ht->items306C[p_item2->dcmp_byte] = p_item2;
+			p_item1->child                    = p_item2;
+
+			/* call 1500E820. */
+			libmpq__huffman_call_1500E820(ht, p_item2);
+
+			/* check if compression is not set. */
+			if (ht->cmp0 == 0) {
+				libmpq__huffman_call_1500E820(ht, ht->items306C[n8bits]);
+			}
+
+			/* set compression byte. */
+			dcmp_byte = n8bits;
+		}
+
+		/* check for compression. */
+		if (dcmp_byte == 0x100) {
+			break;
+		}
+
+		/* increase position by compression byte. */
+		*out_pos++ = (uint8_t)dcmp_byte;
+		if (--out_length == 0) {
+			break;
+		}
+
+		/* check if compression is not set. */
+		if (ht->cmp0) {
+			libmpq__huffman_call_1500E820(ht, ht->items306C[dcmp_byte]);
+		}
+	}
+
+	/* return copied bytes. */
+	return (out_pos - out_buf);
+}
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/huffman.h temp-build/maptools/vmap_extractor/libmpq04/huffman.h
--- clean-build/maptools/vmap_extractor/libmpq04/huffman.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/huffman.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,151 @@
+/*
+ *  huffman.h -- structures used for huffman compression.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of huffman.h included
+ *  in stormlib. The C++ version belongs to the following authors:
+ *
+ *  Ladislav Zezula <ladik@zezula.net>
+ *  ShadowFlare <BlakFlare@hotmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _HUFFMAN_H
+#define _HUFFMAN_H
+
+/* define huffman compression and decompression values. */
+#define LIBMPQ_HUFF_DECOMPRESS			0		/* we want to decompress using huffman trees. */
+
+/* define pointer conversions. */
+#define PTR_NOT(ptr)				(struct huffman_tree_item_s *)(~(unsigned long)(ptr))
+#define PTR_PTR(ptr)				((struct huffman_tree_item_s *)(ptr))
+#define PTR_INT(ptr)				(long)(ptr)
+
+/* define item handling. */
+#define INSERT_ITEM				1		/* insert item into huffman tree. */
+#define SWITCH_ITEMS				2		/* switch items isnide huffman tree. */
+
+/* input stream for huffman decompression. */
+struct huffman_input_stream_s {
+	uint8_t		*in_buf;				/* 00 - input data. */
+	uint32_t	bit_buf;				/* 04 - input bit buffer. */
+	uint32_t	bits;					/* 08 - number of bits remaining in byte. */
+};
+
+/* huffman tree item. */
+struct huffman_tree_item_s {
+	struct		huffman_tree_item_s *next;		/* 00 - pointer to next huffman tree item. */
+	struct		huffman_tree_item_s *prev;		/* 04 - pointer to prev huffman tree item (< 0 if none). */
+	uint32_t	dcmp_byte;				/* 08 - index of this item in item pointer array, decompressed byte value. */
+	uint32_t	byte_value;				/* 0C - some byte value. */
+	struct		huffman_tree_item_s *parent;		/* 10 - pointer to parent huffman tree item (NULL if none). */
+	struct		huffman_tree_item_s *child;		/* 14 - pointer to child huffman tree item. */
+};
+
+/* structure used for quick decompression. */
+struct huffman_decompress_s {
+	uint32_t	offs00;					/* 00 - 1 if resolved. */
+	uint32_t	bits;					/* 04 - bit count. */
+	union {
+		uint32_t	dcmp_byte;			/* 08 - byte value for decompress (if bitCount <= 7). */
+		struct		huffman_tree_item_s *p_item;	/* 08 - huffman tree item (if number of bits is greater than 7). */
+	};
+};
+
+/* structure for huffman tree. */
+struct huffman_tree_s {
+	uint32_t	cmp0;					/* 0000 - 1 if compression type 0. */
+	uint32_t	offs0004;				/* 0004 - some flag. */
+	struct		huffman_tree_item_s items0008[0x203];	/* 0008 - huffman tree items. */
+	struct		huffman_tree_item_s *item3050;		/* 3050 - always NULL? */
+	struct		huffman_tree_item_s *item3054;		/* 3054 - pointer to huffman tree item. */
+	struct		huffman_tree_item_s *item3058;		/* 3058 - pointer to huffman tree item (< 0 if invalid). */
+	struct		huffman_tree_item_s *item305C;		/* 305C - usually NULL. */
+	struct		huffman_tree_item_s *first;		/* 3060 - pointer to top (first) huffman tree item. */
+	struct		huffman_tree_item_s *last;		/* 3064 - pointer to bottom (last) huffman tree item (< 0 if invalid). */
+	uint32_t	items;					/* 3068 - number of used huffman tree items. */
+	struct		huffman_tree_item_s *items306C[0x102];	/* 306C - huffman tree item pointer array. */
+	struct		huffman_decompress_s qd3474[0x80];	/* 3474 - array for quick decompression. */
+	uint8_t		table_1502A630[];			/* some table to make struct size flexible. */
+};
+
+/* insert a new item into huffman tree. */
+void libmpq__huffman_insert_item(
+	struct		huffman_tree_item_s **p_item,
+	struct		huffman_tree_item_s *item,
+	uint32_t	where,
+	struct		huffman_tree_item_s *item2
+);
+
+/* remove item from huffman tree. */
+void libmpq__huffman_remove_item(
+	struct		huffman_tree_item_s *hi
+);
+
+/* get previous item from huffman tree. */
+struct huffman_tree_item_s *libmpq__huffman_previous_item(
+	struct		huffman_tree_item_s *hi,
+	long		value
+);
+
+/* get one bit from stream. */
+uint32_t libmpq__huffman_get_1bit(
+	struct		huffman_input_stream_s *is
+);
+
+/* get seven bit from stream. */
+uint32_t libmpq__huffman_get_7bit(
+	struct		huffman_input_stream_s *is
+);
+
+/* get eight bit from stream. */
+uint32_t libmpq__huffman_get_8bit(
+	struct		huffman_input_stream_s *is
+);
+
+/* call 1500E740. */
+struct huffman_tree_item_s *libmpq__huffman_call_1500E740(
+	struct		huffman_tree_s *ht
+);
+
+/* call 1500E820- */
+void libmpq__huffman_call_1500E820(
+	struct		huffman_tree_s *ht,
+	struct		huffman_tree_item_s *p_item
+);
+
+/* initialize the huffman tree. */
+void libmpq__huffman_tree_init(
+	struct		huffman_tree_s *ht,
+	uint32_t	cmp
+);
+
+/* build the huffman tree. */
+void libmpq__huffman_tree_build(
+	struct		huffman_tree_s *ht,
+	uint32_t	cmp_type
+);
+
+/* decompress the stream using huffman compression. */
+int32_t libmpq__do_decompress_huffman(
+	struct		huffman_tree_s *ht,
+	struct		huffman_input_stream_s *is,
+	uint8_t		*out_buf,
+	uint32_t	out_length
+);
+
+#endif						/* _HUFFMAN_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/mpq.c temp-build/maptools/vmap_extractor/libmpq04/mpq.c
--- clean-build/maptools/vmap_extractor/libmpq04/mpq.c	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/mpq.c	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,1029 @@
+/*
+ *  mpq.c -- functions for developers using libmpq.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* mpq-tools configuration includes. */
+#include "config.h"
+
+/* libmpq main includes. */
+#include "mpq.h"
+#include "mpq-internal.h"
+
+/* libmpq generic includes. */
+#include "common.h"
+
+/* generic includes. */
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+/* support for platform specific things */
+#include "platform.h"
+
+/* this function returns the library version information. */
+const char *libmpq__version(void) {
+
+	/* return version information. */
+	return VERSION;
+}
+
+/* this function read a file and verify if it is a valid mpq archive, then it read and decrypt the hash table. */
+int32_t libmpq__archive_open(mpq_archive_s **mpq_archive, const char *mpq_filename, libmpq__off_t archive_offset) {
+
+	/* some common variables. */
+	uint32_t rb             = 0;
+	uint32_t i              = 0;
+	uint32_t count          = 0;
+	int32_t result          = 0;
+	uint32_t header_search	= FALSE;
+
+	if (archive_offset == -1) {
+		archive_offset = 0;
+		header_search = TRUE;
+	}
+
+	if ((*mpq_archive = calloc(1, sizeof(mpq_archive_s))) == NULL) {
+
+		/* archive struct could not be allocated */
+		return LIBMPQ_ERROR_MALLOC;
+	}
+
+	/* check if file exists and is readable */
+	if (((*mpq_archive)->fp = fopen(mpq_filename, "rb")) == NULL) {
+
+		/* file could not be opened. */
+		result = LIBMPQ_ERROR_OPEN;
+		goto error;
+	}
+
+	/* assign some default values. */
+	(*mpq_archive)->mpq_header.mpq_magic = 0;
+	(*mpq_archive)->files                = 0;
+
+	/* loop through file and search for mpq signature. */
+	while (TRUE) {
+
+		/* reset header values. */
+		(*mpq_archive)->mpq_header.mpq_magic = 0;
+
+		/* seek in file. */
+		if (fseeko((*mpq_archive)->fp, archive_offset, SEEK_SET) < 0) {
+
+			/* seek in file failed. */
+			result = LIBMPQ_ERROR_SEEK;
+			goto error;
+		}
+
+		/* read header from file. */
+		if ((rb = fread(&(*mpq_archive)->mpq_header, 1, sizeof(mpq_header_s), (*mpq_archive)->fp)) != sizeof(mpq_header_s)) {
+
+			/* no valid mpq archive. */
+			result = LIBMPQ_ERROR_FORMAT;
+			goto error;
+		}
+
+		/* check if we found a valid mpq header. */
+		if ((*mpq_archive)->mpq_header.mpq_magic == LIBMPQ_HEADER) {
+
+			/* check if we process old mpq archive version. */
+			if ((*mpq_archive)->mpq_header.version == LIBMPQ_ARCHIVE_VERSION_ONE) {
+
+				/* check if the archive is protected. */
+				if ((*mpq_archive)->mpq_header.header_size != sizeof(mpq_header_s)) {
+
+					/* correct header size. */
+					(*mpq_archive)->mpq_header.header_size = sizeof(mpq_header_s);
+				}
+			}
+
+			/* check if we process new mpq archive version. */
+			if ((*mpq_archive)->mpq_header.version == LIBMPQ_ARCHIVE_VERSION_TWO) {
+
+				/* check if the archive is protected. */
+				if ((*mpq_archive)->mpq_header.header_size != sizeof(mpq_header_s) + sizeof(mpq_header_ex_s)) {
+
+					/* correct header size. */
+					(*mpq_archive)->mpq_header.header_size = sizeof(mpq_header_s) + sizeof(mpq_header_ex_s);
+				}
+			}
+
+			/* break the loop, because header was found. */
+			break;
+		}
+
+		/* move to the next possible offset. */
+		if (!header_search) {
+
+			/* no valid mpq archive. */
+			result = LIBMPQ_ERROR_FORMAT;
+			goto error;
+		}
+		archive_offset += 512;
+	}
+
+	/* store block size for later use. */
+	(*mpq_archive)->block_size = 512 << (*mpq_archive)->mpq_header.block_size;
+
+	/* store archive offset and size for later use. */
+	(*mpq_archive)->archive_offset = archive_offset;
+
+	/* check if we process new mpq archive version. */
+	if ((*mpq_archive)->mpq_header.version == LIBMPQ_ARCHIVE_VERSION_TWO) {
+
+		/* seek in file. */
+		if (fseeko((*mpq_archive)->fp, sizeof(mpq_header_s) + archive_offset, SEEK_SET) < 0) {
+
+			/* seek in file failed. */
+			result = LIBMPQ_ERROR_SEEK;
+			goto error;
+		}
+
+		/* read header from file. */
+		if ((rb = fread(&(*mpq_archive)->mpq_header_ex, 1, sizeof(mpq_header_ex_s), (*mpq_archive)->fp)) != sizeof(mpq_header_ex_s)) {
+
+			/* no valid mpq archive. */
+			result = LIBMPQ_ERROR_FORMAT;
+			goto error;
+		}
+	}
+
+	/* allocate memory for the block table, hash table, file and block table to file mapping. */
+	if (((*mpq_archive)->mpq_block    = calloc((*mpq_archive)->mpq_header.block_table_count, sizeof(mpq_block_s))) == NULL ||
+	    ((*mpq_archive)->mpq_block_ex = calloc((*mpq_archive)->mpq_header.block_table_count, sizeof(mpq_block_ex_s))) == NULL ||
+	    ((*mpq_archive)->mpq_hash     = calloc((*mpq_archive)->mpq_header.hash_table_count,  sizeof(mpq_hash_s))) == NULL ||
+	    ((*mpq_archive)->mpq_file     = calloc((*mpq_archive)->mpq_header.block_table_count, sizeof(mpq_file_s))) == NULL ||
+	    ((*mpq_archive)->mpq_map      = calloc((*mpq_archive)->mpq_header.block_table_count, sizeof(mpq_map_s))) == NULL) {
+
+		/* memory allocation problem. */
+		result = LIBMPQ_ERROR_MALLOC;
+		goto error;
+	}
+
+	/* seek in file. */
+	if (fseeko((*mpq_archive)->fp, (*mpq_archive)->mpq_header.hash_table_offset + (((long long)((*mpq_archive)->mpq_header_ex.hash_table_offset_high)) << 32) + (*mpq_archive)->archive_offset, SEEK_SET) < 0) {
+
+		/* seek in file failed. */
+		result = LIBMPQ_ERROR_SEEK;
+		goto error;
+	}
+
+	/* read the hash table into the buffer. */
+	if ((rb = fread((*mpq_archive)->mpq_hash, 1, (*mpq_archive)->mpq_header.hash_table_count * sizeof(mpq_hash_s), (*mpq_archive)->fp)) < 0) {
+
+		/* something on read failed. */
+		result = LIBMPQ_ERROR_READ;
+		goto error;
+	}
+
+	/* decrypt the hashtable. */
+	libmpq__decrypt_block((uint32_t *)((*mpq_archive)->mpq_hash), (*mpq_archive)->mpq_header.hash_table_count * sizeof(mpq_hash_s), libmpq__hash_string("(hash table)", 0x300));
+
+	/* seek in file. */
+	if (fseeko((*mpq_archive)->fp, (*mpq_archive)->mpq_header.block_table_offset + (((long long)((*mpq_archive)->mpq_header_ex.block_table_offset_high)) << 32) + (*mpq_archive)->archive_offset, SEEK_SET) < 0) {
+
+		/* seek in file failed. */
+		result = LIBMPQ_ERROR_SEEK;
+		goto error;
+	}
+
+	/* read the block table into the buffer. */
+	if ((rb = fread((*mpq_archive)->mpq_block, 1, (*mpq_archive)->mpq_header.block_table_count * sizeof(mpq_block_s), (*mpq_archive)->fp)) < 0) {
+
+		/* something on read failed. */
+		result = LIBMPQ_ERROR_READ;
+		goto error;
+	}
+
+	/* decrypt block table. */
+	libmpq__decrypt_block((uint32_t *)((*mpq_archive)->mpq_block), (*mpq_archive)->mpq_header.block_table_count * sizeof(mpq_block_s), libmpq__hash_string("(block table)", 0x300));
+
+	/* check if extended block table is present, regardless of version 2 it is only present in archives > 4GB. */
+	if ((*mpq_archive)->mpq_header_ex.extended_offset > 0) {
+
+		/* seek in file. */
+		if (fseeko((*mpq_archive)->fp, (*mpq_archive)->mpq_header_ex.extended_offset + archive_offset, SEEK_SET) < 0) {
+
+			/* seek in file failed. */
+			result = LIBMPQ_ERROR_SEEK;
+			goto error;
+		}
+
+		/* read header from file. */
+		if ((rb = fread((*mpq_archive)->mpq_block_ex, 1, (*mpq_archive)->mpq_header.block_table_count * sizeof(mpq_block_ex_s), (*mpq_archive)->fp)) < 0) {
+
+			/* no valid mpq archive. */
+			result = LIBMPQ_ERROR_FORMAT;
+			goto error;
+		}
+	}
+
+	/* loop through all files in mpq archive and check if they are valid. */
+	for (i = 0; i < (*mpq_archive)->mpq_header.block_table_count; i++) {
+
+		/* save block difference between valid and invalid blocks. */
+		(*mpq_archive)->mpq_map[i].block_table_diff = i - count;
+
+		/* check if file exists, sizes and offsets are correct. */
+		if (((*mpq_archive)->mpq_block[i].flags & LIBMPQ_FLAG_EXISTS) == 0) {
+
+			/* file does not exist, so nothing to do with that block. */
+			continue;
+		}
+
+		/* create final indices tables. */
+		(*mpq_archive)->mpq_map[count].block_table_indices = i;
+
+		/* increase file counter. */
+		count++;
+	}
+
+	/* save the number of files. */
+	(*mpq_archive)->files = count;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+
+error:
+	if ((*mpq_archive)->fp)
+		fclose((*mpq_archive)->fp);
+
+	free((*mpq_archive)->mpq_map);
+	free((*mpq_archive)->mpq_file);
+	free((*mpq_archive)->mpq_hash);
+	free((*mpq_archive)->mpq_block);
+	free((*mpq_archive)->mpq_block_ex);
+	free(*mpq_archive);
+
+	*mpq_archive = NULL;
+
+	return result;
+}
+
+/* this function close the file descriptor, free the decryption buffer and the file list. */
+int32_t libmpq__archive_close(mpq_archive_s *mpq_archive) {
+
+	/* try to close the file */
+	if ((fclose(mpq_archive->fp)) < 0) {
+
+		/* don't free anything here, so the caller can try calling us
+		 * again.
+		 */
+		return LIBMPQ_ERROR_CLOSE;
+	}
+
+	/* free header, tables and list. */
+	free(mpq_archive->mpq_map);
+	free(mpq_archive->mpq_file);
+	free(mpq_archive->mpq_hash);
+	free(mpq_archive->mpq_block);
+	free(mpq_archive->mpq_block_ex);
+	free(mpq_archive);
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the packed size of all files in the archive. */
+int32_t libmpq__archive_packed_size(mpq_archive_s *mpq_archive, libmpq__off_t *packed_size) {
+
+	/* some common variables. */
+	uint32_t i;
+
+	/* loop through all files in archive and count packed size. */
+	for (i = 0; i < mpq_archive->files; i++) {
+		*packed_size += mpq_archive->mpq_block[mpq_archive->mpq_map[i].block_table_indices].packed_size;
+	}
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the unpacked size of all files in the archive. */
+int32_t libmpq__archive_unpacked_size(mpq_archive_s *mpq_archive, libmpq__off_t *unpacked_size) {
+
+	/* some common variables. */
+	uint32_t i;
+
+	/* loop through all files in archive and count unpacked size. */
+	for (i = 0; i < mpq_archive->files; i++) {
+		*unpacked_size += mpq_archive->mpq_block[mpq_archive->mpq_map[i].block_table_indices].unpacked_size;
+	}
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the archive offset (beginning of archive in file). */
+int32_t libmpq__archive_offset(mpq_archive_s *mpq_archive, libmpq__off_t *offset) {
+
+	/* return archive offset. */
+	*offset = mpq_archive->archive_offset;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the archive offset. */
+int32_t libmpq__archive_version(mpq_archive_s *mpq_archive, uint32_t *version) {
+
+	/* return archive version. */
+	*version = mpq_archive->mpq_header.version + 1;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the number of valid files in archive. */
+int32_t libmpq__archive_files(mpq_archive_s *mpq_archive, uint32_t *files) {
+
+	/* return archive version. */
+	*files = mpq_archive->files;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the packed size of the given files in the archive. */
+int32_t libmpq__file_packed_size(mpq_archive_s *mpq_archive, uint32_t file_number, libmpq__off_t *packed_size) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* get the packed size of file. */
+	*packed_size = mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].packed_size;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the unpacked size of the given file in the archive. */
+int32_t libmpq__file_unpacked_size(mpq_archive_s *mpq_archive, uint32_t file_number, libmpq__off_t *unpacked_size) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* get the unpacked size of file. */
+	*unpacked_size = mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the file offset (beginning of file in archive). */
+int32_t libmpq__file_offset(mpq_archive_s *mpq_archive, uint32_t file_number, libmpq__off_t *offset) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* return file offset relative to archive start. */
+	*offset = mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].offset + (((long long)mpq_archive->mpq_block_ex[mpq_archive->mpq_map[file_number].block_table_indices].offset_high) << 32);
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the number of blocks for the given file in the archive. */
+int32_t libmpq__file_blocks(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t *blocks) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* return the number of blocks for the given file. */
+	*blocks = (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) != 0 ? 1 : (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size + mpq_archive->block_size - 1) / mpq_archive->block_size;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return if the file is encrypted or not. */
+int32_t libmpq__file_encrypted(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t *encrypted) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* return the encryption status of file. */
+	*encrypted = (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_ENCRYPTED) != 0 ? TRUE : FALSE;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return if the file is compressed or not. */
+int32_t libmpq__file_compressed(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t *compressed) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* return the compression status of file. */
+	*compressed = (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_COMPRESS_MULTI) != 0 ? TRUE : FALSE;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return if the file is imploded or not. */
+int32_t libmpq__file_imploded(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t *imploded) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* return the implosion status of file. */
+	*imploded = (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_COMPRESS_PKZIP) != 0 ? TRUE : FALSE;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return filenumber by the given name. */
+int32_t libmpq__file_number(mpq_archive_s *mpq_archive, const char *filename, uint32_t *number) {
+
+	/* some common variables. */
+	uint32_t i, hash1, hash2, hash3, ht_count;
+
+	/* if the list of file names doesn't include this one, we'll have
+	 * to figure out the file number the "hard" way.
+	 */
+	ht_count = mpq_archive->mpq_header.hash_table_count;
+
+	hash1 = libmpq__hash_string (filename, 0x0) & (ht_count - 1);
+	hash2 = libmpq__hash_string (filename, 0x100);
+	hash3 = libmpq__hash_string (filename, 0x200);
+
+	/* loop through all files in mpq archive.
+	 * hash1 gives us a clue about the starting position of this
+	 * search.
+	 */
+	for (i = hash1; mpq_archive->mpq_hash[i].block_table_index != LIBMPQ_HASH_FREE; i = (i + 1) & (ht_count - 1)) {
+
+		/* if the other two hashes match, we found our file number. */
+		if (mpq_archive->mpq_hash[i].hash_a == hash2 &&
+		    mpq_archive->mpq_hash[i].hash_b == hash3) {
+
+			/* return the file number. */
+			*number = mpq_archive->mpq_hash[i].block_table_index - mpq_archive->mpq_map[mpq_archive->mpq_hash[i].block_table_index].block_table_diff;
+
+			/* we found our file, return zero. */
+			return LIBMPQ_SUCCESS;
+		}
+
+		/* check if we have cycled through the whole hash table */
+		if (((i + 1) & (ht_count - 1)) == hash1) {
+			break;
+		}
+	}
+
+	/* if no matching entry found, so return error. */
+	return LIBMPQ_ERROR_EXIST;
+}
+
+/* this function read the given file from archive into a buffer. */
+int32_t libmpq__file_read(mpq_archive_s *mpq_archive, uint32_t file_number, uint8_t *out_buf, libmpq__off_t out_size, libmpq__off_t *transferred) {
+
+	/* some common variables. */
+	uint32_t i;
+	uint32_t blocks         = 0;
+	int32_t result          = 0;
+	libmpq__off_t file_offset       = 0;
+	libmpq__off_t unpacked_size     = 0;
+	libmpq__off_t transferred_block = 0;
+	libmpq__off_t transferred_total = 0;
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* get target size of block. */
+	libmpq__file_unpacked_size(mpq_archive, file_number, &unpacked_size);
+
+	/* check if target buffer is to small. */
+	if (unpacked_size > out_size) {
+
+		/* output buffer size is to small or block size is unknown. */
+		return LIBMPQ_ERROR_SIZE;
+	}
+
+	/* fetch file offset. */
+	libmpq__file_offset(mpq_archive, file_number, &file_offset);
+
+	/* get block count for file. */
+	libmpq__file_blocks(mpq_archive, file_number, &blocks);
+
+	/* open the packed block offset table. */
+	if ((result = libmpq__block_open_offset(mpq_archive, file_number)) < 0) {
+
+		/* something on opening packed block offset table failed. */
+		return result;
+	}
+
+	/* loop through all blocks. */
+	for (i = 0; i < blocks; i++) {
+
+		/* cleanup size variable. */
+		unpacked_size = 0;
+
+		/* get unpacked block size. */
+		libmpq__block_unpacked_size(mpq_archive, file_number, i, &unpacked_size);
+
+		/* read block. */
+		if ((result = libmpq__block_read(mpq_archive, file_number, i, out_buf + transferred_total, unpacked_size, &transferred_block)) < 0) {
+
+			/* close the packed block offset table. */
+			libmpq__block_close_offset(mpq_archive, file_number);
+
+			/* something on reading block failed. */
+			return result;
+		}
+
+		transferred_total += transferred_block;
+
+	}
+
+	/* close the packed block offset table. */
+	libmpq__block_close_offset(mpq_archive, file_number);
+
+	/* check for null pointer. */
+	if (transferred != NULL) {
+
+		/* store transferred bytes. */
+		*transferred = transferred_total;
+	}
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function open a file in the given archive and caches the block offset information. */
+int32_t libmpq__block_open_offset(mpq_archive_s *mpq_archive, uint32_t file_number) {
+
+	/* some common variables. */
+	uint32_t i;
+	uint32_t packed_size;
+	int32_t rb     = 0;
+	int32_t result = 0;
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	if (mpq_archive->mpq_file[file_number]) {
+
+		/* file already opened, so increment counter */
+		mpq_archive->mpq_file[file_number]->open_count++;
+		return LIBMPQ_SUCCESS;
+	}
+
+	/* check if file is not stored in a single sector. */
+	if ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) == 0) {
+
+		/* get packed size based on block size and block count. */
+		packed_size = sizeof(uint32_t) * (((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size + mpq_archive->block_size - 1) / mpq_archive->block_size) + 1);
+	} else {
+
+		/* file is stored in single sector and we need only two entries for the packed block offset table. */
+		packed_size = sizeof(uint32_t) * 2;
+	}
+
+	/* check if data has one extra entry. */
+	if ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_EXTRA) != 0) {
+
+		/* add one uint32_t. */
+		packed_size += sizeof(uint32_t);
+	}
+
+	/* allocate memory for the file. */
+	if ((mpq_archive->mpq_file[file_number] = calloc(1, sizeof(mpq_file_s))) == NULL) {
+
+		/* memory allocation problem. */
+		result = LIBMPQ_ERROR_MALLOC;
+		goto error;
+	}
+
+	/* allocate memory for the packed block offset table. */
+	if ((mpq_archive->mpq_file[file_number]->packed_offset = calloc(1, packed_size)) == NULL) {
+
+		/* memory allocation problem. */
+		result = LIBMPQ_ERROR_MALLOC;
+		goto error;
+	}
+
+	/* initialize counter to one opening */
+	mpq_archive->mpq_file[file_number]->open_count = 1;
+
+	/* check if we need to load the packed block offset table, we will maintain this table for unpacked files too. */
+	if ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_COMPRESSED) != 0 &&
+	    (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) == 0) {
+
+		/* seek to block position. */
+		if (fseeko(mpq_archive->fp, mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].offset + (((long long)mpq_archive->mpq_block_ex[mpq_archive->mpq_map[file_number].block_table_indices].offset_high) << 32) + mpq_archive->archive_offset, SEEK_SET) < 0) {
+
+			/* seek in file failed. */
+			result = LIBMPQ_ERROR_SEEK;
+			goto error;
+		}
+
+		/* read block positions from begin of file. */
+		if ((rb = fread(mpq_archive->mpq_file[file_number]->packed_offset, 1, packed_size, mpq_archive->fp)) < 0) {
+
+			/* something on read from archive failed. */
+			result = LIBMPQ_ERROR_READ;
+			goto error;
+		}
+
+		/* check if the archive is protected some way, sometimes the file appears not to be encrypted, but it is. */
+		if (mpq_archive->mpq_file[file_number]->packed_offset[0] != rb) {
+
+			/* file is encrypted. */
+			mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags |= LIBMPQ_FLAG_ENCRYPTED;
+		}
+
+		/* check if packed offset block is encrypted, we have to decrypt it. */
+		if (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_ENCRYPTED) {
+
+			/* check if we don't know the file seed, try to find it. */
+			if ((mpq_archive->mpq_file[file_number]->seed = libmpq__decrypt_key((uint8_t *)mpq_archive->mpq_file[file_number]->packed_offset, packed_size, mpq_archive->block_size)) < 0) {
+
+				/* sorry without seed, we cannot extract file. */
+				result = LIBMPQ_ERROR_DECRYPT;
+				goto error;
+			}
+
+			/* decrypt block in input buffer. */
+			if (libmpq__decrypt_block(mpq_archive->mpq_file[file_number]->packed_offset, packed_size, mpq_archive->mpq_file[file_number]->seed - 1) < 0 ) {
+
+				/* something on decrypt failed. */
+				result = LIBMPQ_ERROR_DECRYPT;
+				goto error;
+			}
+
+			/* check if the block positions are correctly decrypted. */
+			if (mpq_archive->mpq_file[file_number]->packed_offset[0] != packed_size) {
+
+				/* sorry without seed, we cannot extract file. */
+				result = LIBMPQ_ERROR_DECRYPT;
+				goto error;
+			}
+		}
+	} else {
+
+		/* check if file is not stored in a single sector. */
+		if ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) == 0) {
+
+			/* loop through all blocks and create packed block offset table based on block size. */
+			for (i = 0; i < ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size + mpq_archive->block_size - 1) / mpq_archive->block_size + 1); i++) {
+
+				/* check if we process the last block. */
+				if (i == ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size + mpq_archive->block_size - 1) / mpq_archive->block_size)) {
+
+					/* store size of last block. */
+					mpq_archive->mpq_file[file_number]->packed_offset[i] = mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size;
+				} else {
+
+					/* store default block size. */
+					mpq_archive->mpq_file[file_number]->packed_offset[i] = i * mpq_archive->block_size;
+				}
+			}
+		} else {
+
+			/* store offsets. */
+			mpq_archive->mpq_file[file_number]->packed_offset[0] = 0;
+			mpq_archive->mpq_file[file_number]->packed_offset[1] = mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].packed_size;
+		}
+	}
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+
+error:
+
+	/* free packed block offset table and file pointer. */
+	free(mpq_archive->mpq_file[file_number]->packed_offset);
+	free(mpq_archive->mpq_file[file_number]);
+
+	/* return error constant. */
+	return result;
+}
+
+/* this function free the file pointer to the opened file in archive. */
+int32_t libmpq__block_close_offset(mpq_archive_s *mpq_archive, uint32_t file_number) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	if (mpq_archive->mpq_file[file_number] == NULL) {
+
+		/* packed block offset table is not opened. */
+		return LIBMPQ_ERROR_OPEN;
+	}
+
+	mpq_archive->mpq_file[file_number]->open_count--;
+
+	if (mpq_archive->mpq_file[file_number]->open_count != 0) {
+
+		/* still in use */
+		return LIBMPQ_SUCCESS;
+	}
+
+	/* free packed block offset table and file pointer. */
+	free(mpq_archive->mpq_file[file_number]->packed_offset);
+	free(mpq_archive->mpq_file[file_number]);
+
+	/* mark it as unopened - libmpq__block_open_offset checks for this to decide whether to increment the counter */
+	mpq_archive->mpq_file[file_number] = NULL;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the unpacked size of the given file and block in the archive. */
+int32_t libmpq__block_unpacked_size(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t block_number, libmpq__off_t *unpacked_size) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* check if given block number is not out of range. */
+	if (block_number < 0 || block_number >= ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) != 0 ? 1 : (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size + mpq_archive->block_size - 1) / mpq_archive->block_size)) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* check if packed block offset table is opened. */
+	if (mpq_archive->mpq_file[file_number] == NULL ||
+	    mpq_archive->mpq_file[file_number]->packed_offset == NULL) {
+
+		/* packed block offset table is not opened. */
+		return LIBMPQ_ERROR_OPEN;
+	}
+
+	/* check if block is stored as single sector. */
+	if ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) != 0) {
+
+		/* return the unpacked size of the block in the mpq archive. */
+		*unpacked_size = mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size;
+	}
+
+	/* check if block is not stored as single sector. */
+	if ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) == 0) {
+
+		/* check if we not process the last block. */
+		if (block_number < ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size + mpq_archive->block_size - 1) / mpq_archive->block_size) - 1) {
+
+			/* return the block size as unpacked size. */
+			*unpacked_size = mpq_archive->block_size;
+		} else {
+
+			/* return the unpacked size of the last block in the mpq archive. */
+			*unpacked_size = mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size - mpq_archive->block_size * block_number;
+		}
+	}
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function return the decryption seed for the given file and block. */
+int32_t libmpq__block_seed(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t block_number, uint32_t *seed) {
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* check if given block number is not out of range. */
+	if (block_number < 0 || block_number >= ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) != 0 ? 1 : (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size + mpq_archive->block_size - 1) / mpq_archive->block_size)) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* check if packed block offset table is opened. */
+	if (mpq_archive->mpq_file[file_number] == NULL ||
+	    mpq_archive->mpq_file[file_number]->packed_offset == NULL) {
+
+		/* packed block offset table is not opened. */
+		return LIBMPQ_ERROR_OPEN;
+	}
+
+	/* return the decryption key. */
+	*seed = mpq_archive->mpq_file[file_number]->seed + block_number;
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
+
+/* this function read the given block from archive into a buffer. */
+int32_t libmpq__block_read(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t block_number, uint8_t *out_buf, libmpq__off_t out_size, libmpq__off_t *transferred) {
+
+	/* some common variables. */
+	uint8_t *in_buf;
+	uint32_t seed       = 0;
+	uint32_t encrypted  = 0;
+	uint32_t compressed = 0;
+	uint32_t imploded   = 0;
+	int32_t tb          = 0;
+	libmpq__off_t block_offset  = 0;
+	off_t in_size       = 0;
+	libmpq__off_t unpacked_size = 0;
+
+	/* check if given file number is not out of range. */
+	if (file_number < 0 || file_number > mpq_archive->files - 1) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* check if given block number is not out of range. */
+	if (block_number < 0 || block_number >= ((mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].flags & LIBMPQ_FLAG_SINGLE) != 0 ? 1 : (mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].unpacked_size + mpq_archive->block_size - 1) / mpq_archive->block_size)) {
+
+		/* file number is out of range. */
+		return LIBMPQ_ERROR_EXIST;
+	}
+
+	/* check if packed block offset table is opened. */
+	if (mpq_archive->mpq_file[file_number] == NULL ||
+	    mpq_archive->mpq_file[file_number]->packed_offset == NULL) {
+
+		/* packed block offset table is not opened. */
+		return LIBMPQ_ERROR_OPEN;
+	}
+
+	/* get target size of block. */
+	libmpq__block_unpacked_size(mpq_archive, file_number, block_number, &unpacked_size);
+
+	/* check if target buffer is to small. */
+	if (unpacked_size > out_size) {
+
+		/* output buffer size is to small or block size is unknown. */
+		return LIBMPQ_ERROR_SIZE;
+	}
+
+	/* fetch some required values like input buffer size and block offset. */
+	block_offset = mpq_archive->mpq_block[mpq_archive->mpq_map[file_number].block_table_indices].offset + (((long long)mpq_archive->mpq_block_ex[mpq_archive->mpq_map[file_number].block_table_indices].offset_high) << 32) + mpq_archive->mpq_file[file_number]->packed_offset[block_number];
+	in_size = mpq_archive->mpq_file[file_number]->packed_offset[block_number + 1] - mpq_archive->mpq_file[file_number]->packed_offset[block_number];
+
+	/* seek in file. */
+	if (fseeko(mpq_archive->fp, block_offset + mpq_archive->archive_offset, SEEK_SET) < 0) {
+
+		/* something with seek in file failed. */
+		return LIBMPQ_ERROR_SEEK;
+	}
+
+	/* allocate memory for the read buffer. */
+	if ((in_buf = calloc(1, in_size)) == NULL) {
+
+		/* memory allocation problem. */
+		return LIBMPQ_ERROR_MALLOC;
+	}
+
+	/* read block from file. */
+	if (fread(in_buf, 1, in_size, mpq_archive->fp) < 0) {
+
+		/* free buffers. */
+		free(in_buf);
+
+		/* something on reading block failed. */
+		return LIBMPQ_ERROR_READ;
+	}
+
+	/* get encryption status. */
+	libmpq__file_encrypted(mpq_archive, file_number, &encrypted);
+
+	/* check if file is encrypted. */
+	if (encrypted == 1) {
+
+		/* get decryption key. */
+		libmpq__block_seed(mpq_archive, file_number, block_number, &seed);
+
+		/* decrypt block. */
+		if (libmpq__decrypt_block((uint32_t *)in_buf, in_size, seed) < 0) {
+
+			/* free buffers. */
+			free(in_buf);
+
+			/* something on decrypting block failed. */
+			return LIBMPQ_ERROR_DECRYPT;
+		}
+	}
+
+	/* get compression status. */
+	libmpq__file_compressed(mpq_archive, file_number, &compressed);
+
+	/* check if file is compressed. */
+	if (compressed == 1) {
+
+		/* decompress block. */
+		if ((tb = libmpq__decompress_block(in_buf, in_size, out_buf, out_size, LIBMPQ_FLAG_COMPRESS_MULTI)) < 0) {
+
+			/* free temporary buffer. */
+			free(in_buf);
+
+			/* something on decompressing block failed. */
+			return LIBMPQ_ERROR_UNPACK;
+		}
+	}
+
+	/* get implosion status. */
+	libmpq__file_imploded(mpq_archive, file_number, &imploded);
+
+	/* check if file is imploded. */
+	if (imploded == 1) {
+
+		/* explode block. */
+		if ((tb = libmpq__decompress_block(in_buf, in_size, out_buf, out_size, LIBMPQ_FLAG_COMPRESS_PKZIP)) < 0) {
+
+			/* free temporary buffer. */
+			free(in_buf);
+
+			/* something on decompressing block failed. */
+			return LIBMPQ_ERROR_UNPACK;
+		}
+	}
+
+	/* check if file is neither compressed nor imploded. */
+	if (compressed == 0 && imploded == 0) {
+
+		/* copy block. */
+		if ((tb = libmpq__decompress_block(in_buf, in_size, out_buf, out_size, LIBMPQ_FLAG_COMPRESS_NONE)) < 0) {
+
+			/* free temporary buffer. */
+			free(in_buf);
+
+			/* something on decompressing block failed. */
+			return LIBMPQ_ERROR_UNPACK;
+		}
+	}
+
+	/* free read buffer. */
+	free(in_buf);
+
+	/* check for null pointer. */
+	if (transferred != NULL) {
+
+		/* store transferred bytes. */
+		*transferred = tb;
+	}
+
+	/* if no error was found, return zero. */
+	return LIBMPQ_SUCCESS;
+}
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/mpq.h temp-build/maptools/vmap_extractor/libmpq04/mpq.h
--- clean-build/maptools/vmap_extractor/libmpq04/mpq.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/mpq.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,98 @@
+/*
+ *  mpq.h -- some default types and defines.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  Some parts (the encryption and decryption stuff) were adapted from
+ *  the C++ version of StormLib.h and StormPort.h included in stormlib.
+ *  The C++ version belongs to the following authors:
+ *
+ *  Ladislav Zezula <ladik@zezula.net>
+ *  Marko Friedemann <marko.friedemann@bmx-chemnitz.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MPQ_H
+#define _MPQ_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* generic includes. */
+#include <stdint.h>
+#include <sys/types.h>
+
+#if defined(__GNUC__) && (__GNUC__ >= 4)
+# define LIBMPQ_API __attribute__((visibility("default")))
+#else
+# define LIBMPQ_API
+#endif
+
+/* define errors. */
+#define LIBMPQ_ERROR_OPEN			-1		/* open error on file. */
+#define LIBMPQ_ERROR_CLOSE			-2		/* close error on file. */
+#define LIBMPQ_ERROR_SEEK			-3		/* lseek error on file. */
+#define LIBMPQ_ERROR_READ			-4		/* read error on file. */
+#define LIBMPQ_ERROR_WRITE			-5		/* write error on file. */
+#define LIBMPQ_ERROR_MALLOC			-6		/* memory allocation error. */
+#define LIBMPQ_ERROR_FORMAT			-7		/* format errror. */
+#define LIBMPQ_ERROR_NOT_INITIALIZED		-8		/* libmpq__init() wasn't called. */
+#define LIBMPQ_ERROR_SIZE			-9		/* buffer size is to small. */
+#define LIBMPQ_ERROR_EXIST			-10		/* file or block does not exist in archive. */
+#define LIBMPQ_ERROR_DECRYPT			-11		/* we don't know the decryption seed. */
+#define LIBMPQ_ERROR_UNPACK			-12		/* error on unpacking file. */
+
+/* internal data structure. */
+typedef struct mpq_archive mpq_archive_s;
+
+/* file offset data type for API*/
+typedef int64_t libmpq__off_t;
+
+/* generic information about library. */
+extern LIBMPQ_API const char *libmpq__version(void);
+
+/* generic mpq archive information. */
+extern LIBMPQ_API int32_t libmpq__archive_open(mpq_archive_s **mpq_archive, const char *mpq_filename, libmpq__off_t archive_offset);
+extern LIBMPQ_API int32_t libmpq__archive_close(mpq_archive_s *mpq_archive);
+extern LIBMPQ_API int32_t libmpq__archive_packed_size(mpq_archive_s *mpq_archive, libmpq__off_t *packed_size);
+extern LIBMPQ_API int32_t libmpq__archive_unpacked_size(mpq_archive_s *mpq_archive, libmpq__off_t *unpacked_size);
+extern LIBMPQ_API int32_t libmpq__archive_offset(mpq_archive_s *mpq_archive, libmpq__off_t *offset);
+extern LIBMPQ_API int32_t libmpq__archive_version(mpq_archive_s *mpq_archive, uint32_t *version);
+extern LIBMPQ_API int32_t libmpq__archive_files(mpq_archive_s *mpq_archive, uint32_t *files);
+
+/* generic file processing functions. */
+extern LIBMPQ_API int32_t libmpq__file_packed_size(mpq_archive_s *mpq_archive, uint32_t file_number, libmpq__off_t *packed_size);
+extern LIBMPQ_API int32_t libmpq__file_unpacked_size(mpq_archive_s *mpq_archive, uint32_t file_number, libmpq__off_t *unpacked_size);
+extern LIBMPQ_API int32_t libmpq__file_offset(mpq_archive_s *mpq_archive, uint32_t file_number, libmpq__off_t *offset);
+extern LIBMPQ_API int32_t libmpq__file_blocks(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t *blocks);
+extern LIBMPQ_API int32_t libmpq__file_encrypted(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t *encrypted);
+extern LIBMPQ_API int32_t libmpq__file_compressed(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t *compressed);
+extern LIBMPQ_API int32_t libmpq__file_imploded(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t *imploded);
+extern LIBMPQ_API int32_t libmpq__file_number(mpq_archive_s *mpq_archive, const char *filename, uint32_t *number);
+extern LIBMPQ_API int32_t libmpq__file_read(mpq_archive_s *mpq_archive, uint32_t file_number, uint8_t *out_buf, libmpq__off_t out_size, libmpq__off_t *transferred);
+
+/* generic block processing functions. */
+extern LIBMPQ_API int32_t libmpq__block_open_offset(mpq_archive_s *mpq_archive, uint32_t file_number);
+extern LIBMPQ_API int32_t libmpq__block_close_offset(mpq_archive_s *mpq_archive, uint32_t file_number);
+extern LIBMPQ_API int32_t libmpq__block_unpacked_size(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t block_number, libmpq__off_t *unpacked_size);
+extern LIBMPQ_API int32_t libmpq__block_read(mpq_archive_s *mpq_archive, uint32_t file_number, uint32_t block_number, uint8_t *out_buf, libmpq__off_t out_size, libmpq__off_t *transferred);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif						/* _MPQ_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/mpq-internal.h temp-build/maptools/vmap_extractor/libmpq04/mpq-internal.h
--- clean-build/maptools/vmap_extractor/libmpq04/mpq-internal.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/mpq-internal.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,145 @@
+/*
+ *  mpq-internal.h -- some default types and defines, but only required for
+ *                    compilation of the library.
+ *
+ *  Copyright (c) 2003-2008 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MPQ_INTERNAL_H
+#define _MPQ_INTERNAL_H
+
+/* generic includes. */
+#include <stdint.h>
+#include <stdio.h>
+
+/* define return value if nothing failed. */
+#define LIBMPQ_SUCCESS				0		/* return value for all functions which success. */
+
+/* define generic mpq archive information. */
+#define LIBMPQ_HEADER				0x1A51504D	/* mpq archive header ('MPQ\x1A') */
+
+/* define the known archive versions. */
+#define LIBMPQ_ARCHIVE_VERSION_ONE		0		/* version one used until world of warcraft. */
+#define LIBMPQ_ARCHIVE_VERSION_TWO		1		/* version two used from world of warcraft - the burning crusade. */
+
+/* define values used by blizzard as flags. */
+#define LIBMPQ_FLAG_EXISTS			0x80000000	/* set if file exists, reset when the file was deleted. */
+#define LIBMPQ_FLAG_ENCRYPTED			0x00010000	/* indicates whether file is encrypted. */
+#define LIBMPQ_FLAG_COMPRESSED			0x0000FF00	/* file is compressed. */
+#define LIBMPQ_FLAG_COMPRESS_PKZIP		0x00000100	/* compression made by pkware data compression library. */
+#define LIBMPQ_FLAG_COMPRESS_MULTI		0x00000200	/* multiple compressions. */
+#define LIBMPQ_FLAG_COMPRESS_NONE		0x00000300	/* no compression (no blizzard flag used by myself). */
+#define LIBMPQ_FLAG_SINGLE			0x01000000	/* file is stored in one single sector, first seen in world of warcraft. */
+#define LIBMPQ_FLAG_EXTRA			0x04000000	/* compressed block offset table has one extra entry. */
+
+/* define generic hash values. */
+#define LIBMPQ_HASH_FREE			0xFFFFFFFF	/* hash table entry is empty and has always been empty. */
+
+/* define special files. */
+#define LIBMPQ_LISTFILE_NAME			"(listfile)"	/* internal listfile. */
+#define LIBMPQ_SIGNATURE_NAME			"(signature)"	/* internal signature file. */
+#define LIBMPQ_ATTRIBUTES_NAME			"(attributes)"	/* internal attributes file. */
+
+/* define true and false, because not all systems have them. */
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#include "pack_begin.h"
+/* mpq archive header. */
+typedef struct {
+	uint32_t	mpq_magic;		/* the 0x1A51504D ('MPQ\x1A') signature. */
+	uint32_t	header_size;		/* mpq archive header size. */
+	uint32_t	archive_size;		/* size of mpq archive. */
+	uint16_t	version;		/* 0000 for starcraft and broodwar. */
+	uint16_t	block_size;		/* size of file block is (512 * 2 ^ block size). */
+	uint32_t	hash_table_offset;	/* file position of mpq_hash. */
+	uint32_t	block_table_offset;	/* file position of mpq_block, each entry has 16 bytes. */
+	uint32_t	hash_table_count;	/* number of entries in hash table. */
+	uint32_t	block_table_count;	/* number of entries in the block table. */
+} PACK_STRUCT mpq_header_s;
+
+/* mpq extended archive header, used since world of warcraft - the burning crusade. */
+typedef struct {
+	uint64_t	extended_offset;	/* offset to the beginning of the extended block table, relative to the beginning of the archive. */
+	uint16_t	hash_table_offset_high;	/* upper 16 bits of the hash table offset for large archives. */
+	uint16_t	block_table_offset_high;/* upper 16 bits of the block table offset for large archives.*/
+} PACK_STRUCT mpq_header_ex_s;
+
+/* hash entry, all files in the archive are searched by their hashes. */
+typedef struct {
+	uint32_t	hash_a;			/* the first two uint32_ts are the encrypted file. */
+	uint32_t	hash_b;			/* the first two uint32_ts are the encrypted file. */
+	uint16_t	locale;			/* locale information. */
+	uint16_t	platform;		/* platform information and zero is default. */
+	uint32_t	block_table_index;	/* index to file description block. */
+} PACK_STRUCT mpq_hash_s;
+
+/* file description block contains informations about the file. */
+typedef struct {
+	uint32_t	offset;			/* block file starting position in the archive. */
+	uint32_t	packed_size;		/* packed file size. */
+	uint32_t	unpacked_size;		/* unpacked file size. */
+	uint32_t	flags;			/* flags. */
+} PACK_STRUCT mpq_block_s;
+
+/* extended file description block contains information about the offset beyond 2^32 (4GB). */
+typedef struct {
+	uint16_t	offset_high;		/* upper 16 bit of the file offset in archive. */
+} PACK_STRUCT mpq_block_ex_s;
+
+/* file structure used since diablo 1.00 (0x38 bytes). */
+typedef struct {
+	uint32_t	seed;			/* seed used for file decrypt. */
+	uint32_t	*packed_offset;		/* position of each file block (only for packed files). */
+	uint32_t	open_count;		/* number of times it has been opened - used for freeing */
+} PACK_STRUCT mpq_file_s;
+
+/* map structure for valid blocks and hashes (first seen in warcraft 3 archives). */
+typedef struct {
+	uint32_t	block_table_indices;	/* real mapping for file number to block entry. */
+	uint32_t	block_table_diff;	/* block table difference between valid blocks and invalid blocks before. */
+} PACK_STRUCT mpq_map_s;
+#include "pack_end.h"
+
+/* archive structure used since diablo 1.00 by blizzard. */
+struct mpq_archive {
+
+	/* generic file information. */
+	FILE		*fp;			/* file handle. */
+
+	/* generic size information. */
+	uint32_t	block_size;		/* size of the mpq block. */
+	off_t		archive_offset;		/* absolute start position of archive. */
+
+	/* archive related buffers and tables. */
+	mpq_header_s	mpq_header;		/* mpq file header. */
+	mpq_header_ex_s	mpq_header_ex;		/* mpq extended file header. */
+	mpq_hash_s	*mpq_hash;		/* hash table. */
+	mpq_block_s	*mpq_block;		/* block table. */
+	mpq_block_ex_s	*mpq_block_ex;		/* extended block table. */
+	mpq_file_s	**mpq_file;		/* pointer to the file pointers which are opened. */
+
+	/* non archive structure related members. */
+	mpq_map_s	*mpq_map;		/* map table between valid blocks and hashes. */
+	uint32_t	files;			/* number of files in archive, which could be extracted. */
+};
+
+#endif						/* _MPQ_INTERNAL_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/pack_begin.h temp-build/maptools/vmap_extractor/libmpq04/pack_begin.h
--- clean-build/maptools/vmap_extractor/libmpq04/pack_begin.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/pack_begin.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,34 @@
+/*
+ *  pack_begin.h -- header file for struct packing used by libmpq.
+ *
+ *  Copyright (c) 2010 Georg Lukas <georg@op-co.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _PACK_BEGIN
+#define _PACK_BEGIN
+#else
+#error "pack_begin.h may not be included twice!"
+#endif
+
+#ifdef _MSC_VER
+  #pragma pack(push,1)
+  #define PACK_STRUCT
+#else
+  /* we assume GNU here */
+  #define PACK_STRUCT __attribute__((packed))
+#endif
+
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/pack_end.h temp-build/maptools/vmap_extractor/libmpq04/pack_end.h
--- clean-build/maptools/vmap_extractor/libmpq04/pack_end.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/pack_end.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,31 @@
+/*
+ *  pack_end.h -- header file for struct packing used by libmpq.
+ *
+ *  Copyright (c) 2010 Georg Lukas <georg@op-co.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef _PACK_BEGIN
+#undef _PACK_BEGIN
+#else
+#error "pack_begin.h must be includede before pack_end.h"
+#endif
+
+#ifdef _MSC_VER
+  #pragma pack(pop)
+#endif
+
+#undef PACK_STRUCT
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/platform.h temp-build/maptools/vmap_extractor/libmpq04/platform.h
--- clean-build/maptools/vmap_extractor/libmpq04/platform.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/platform.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,28 @@
+/*
+ *  platform.h -- header file for platform specific parts.
+ *
+ *  Copyright (c) 2010 Georg Lukas <georg@op-co.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _PLATFORM_H
+#define _PLATFORM_H
+
+#ifdef _MSC_VER
+  #define fseeko _fseeki64
+#endif
+
+#endif								/* _PLATFORM_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/wave.c temp-build/maptools/vmap_extractor/libmpq04/wave.c
--- clean-build/maptools/vmap_extractor/libmpq04/wave.c	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/wave.c	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,250 @@
+/*
+ *  wave.c -- this file contains decompression methods used by mpq-tools
+ *            to decompress wave files.
+ *
+ *  Copyright (c) 2003-2007 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of wave.cpp included
+ *  in stormlib. The C++ version belongs to the following authors:
+ *
+ *  Ladislav Zezula <ladik@zezula.net>
+ *  Tom Amigo <tomamigo@apexmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* generic includes. */
+#include <stdint.h>
+
+/* libmpq generic includes. */
+#include "wave.h"
+
+/* table necessary dor decompression. */
+static const uint32_t wave_table_1503f120[] = {
+	0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000004, 0xFFFFFFFF, 0x00000002, 0xFFFFFFFF, 0x00000006,
+	0xFFFFFFFF, 0x00000001, 0xFFFFFFFF, 0x00000005, 0xFFFFFFFF, 0x00000003, 0xFFFFFFFF, 0x00000007,
+	0xFFFFFFFF, 0x00000001, 0xFFFFFFFF, 0x00000005, 0xFFFFFFFF, 0x00000003, 0xFFFFFFFF, 0x00000007,  
+	0xFFFFFFFF, 0x00000002, 0xFFFFFFFF, 0x00000004, 0xFFFFFFFF, 0x00000006, 0xFFFFFFFF, 0x00000008  
+};
+
+/* table necessary dor decompression. */
+static const uint32_t wave_table_1503f1a0[] = {
+	0x00000007, 0x00000008, 0x00000009, 0x0000000A, 0x0000000B, 0x0000000C, 0x0000000D, 0x0000000E,
+	0x00000010, 0x00000011, 0x00000013, 0x00000015, 0x00000017, 0x00000019, 0x0000001C, 0x0000001F,
+	0x00000022, 0x00000025, 0x00000029, 0x0000002D, 0x00000032, 0x00000037, 0x0000003C, 0x00000042,
+	0x00000049, 0x00000050, 0x00000058, 0x00000061, 0x0000006B, 0x00000076, 0x00000082, 0x0000008F,
+	0x0000009D, 0x000000AD, 0x000000BE, 0x000000D1, 0x000000E6, 0x000000FD, 0x00000117, 0x00000133,
+	0x00000151, 0x00000173, 0x00000198, 0x000001C1, 0x000001EE, 0x00000220, 0x00000256, 0x00000292,
+	0x000002D4, 0x0000031C, 0x0000036C, 0x000003C3, 0x00000424, 0x0000048E, 0x00000502, 0x00000583,
+	0x00000610, 0x000006AB, 0x00000756, 0x00000812, 0x000008E0, 0x000009C3, 0x00000ABD, 0x00000BD0,
+	0x00000CFF, 0x00000E4C, 0x00000FBA, 0x0000114C, 0x00001307, 0x000014EE, 0x00001706, 0x00001954,
+	0x00001BDC, 0x00001EA5, 0x000021B6, 0x00002515, 0x000028CA, 0x00002CDF, 0x0000315B, 0x0000364B,
+	0x00003BB9, 0x000041B2, 0x00004844, 0x00004F7E, 0x00005771, 0x0000602F, 0x000069CE, 0x00007462,
+	0x00007FFF
+};
+
+/* this function decompress a wave file, mono or stereo, 1500F230 offset. */
+int32_t libmpq__do_decompress_wave(uint8_t *out_buf, int32_t out_length, uint8_t *in_buf, int32_t in_length, int32_t channels) {
+
+	/* some common variables. */
+	byte_and_int16_t out;
+	byte_and_int16_t in;
+	uint32_t index;
+	int32_t nr_array1[2];
+	int32_t nr_array2[2];
+	uint32_t count = 0;
+
+	/* end on input buffer. */
+	uint8_t *in_end = in_buf + in_length;
+
+	/* assign default values. */
+	out.pb       = out_buf;
+	in.pb        = in_buf;
+	nr_array1[0] = 0x2C;
+	nr_array1[1] = 0x2C;
+
+	/* increase. */
+	in.pw++;
+
+	/* 15007AD7 */
+	for (count = 0; count < channels; count++) {
+
+		/* some common variables. */
+		int32_t temp;
+
+		/* save pointer. */
+		temp = *(int16_t *)in.pw++;
+		nr_array2[count] = temp;
+
+		/* check if should break. */
+		if (out_length < 2) {
+			return out.pb - out_buf;
+		}
+
+		/* return values. */
+		*out.pw++   = (uint16_t)temp;
+		out_length -= 2;
+	}
+
+	/* decrease channels. */
+	index = channels - 1;
+
+	/* loop through input buffer until end reached. */
+	while (in.pb < in_end) {
+
+		/* save the byte. */
+		uint8_t one_byte = *in.pb++;
+
+		/* check how many channels and set index. */
+		if (channels == 2) {
+			index = (index == 0) ? 1 : 0;
+		}
+
+		/* 15007B25 - get one byte from input buffer. */
+		if (one_byte & 0x80) {
+
+			/* 15007B32 */
+			switch (one_byte & 0x7F) {
+				case 0:
+
+					/* 15007B8E */
+					if (nr_array1[index] != 0) {
+						nr_array1[index]--;
+					}
+
+					/* check if should break. */
+					if (out_length < 2) {
+						break;
+					}
+
+					/* return values. */
+					*out.pw++ = (uint16_t)nr_array2[index];
+					out_length -= 2;
+
+					/* continue loop. */
+					continue;
+				case 1:
+					/* 15007B72 and EBX. */
+					nr_array1[index] += 8;
+
+					/* check index. */
+					if (nr_array1[index] > 0x58) {
+						nr_array1[index] = 0x58;
+					}
+
+					/* check how many channels and set index. */
+					if (channels == 2) {
+						index = (index == 0) ? 1 : 0;
+					}
+
+					/* continue loop. */
+					continue;
+				case 2:
+
+					/* nothing todo, so continue. */
+					continue;
+				default:
+
+					/* decrease index. */
+					nr_array1[index] -= 8;
+
+					/* check index. */
+					if (nr_array1[index] < 0) {
+						nr_array1[index] = 0;
+					}
+
+					/* check if two channels left. */
+					if (channels != 2) {
+						continue;
+					}
+					index = (index == 0) ? 1 : 0;
+
+					/* continue loop. */
+					continue;
+			}
+		} else {
+
+			/* EDI */
+			uint32_t temp1 = wave_table_1503f1a0[nr_array1[index]];
+
+			/* ESI */
+			uint32_t temp2 = temp1 >> in_buf[1];
+
+			/* ECX */
+			int32_t temp3 = nr_array2[index];
+
+			/* EBX = one byte. */
+			if (one_byte & 0x01) {
+				temp2 += (temp1 >> 0);
+			}
+			if (one_byte & 0x02) {
+				temp2 += (temp1 >> 1);
+			}
+			if (one_byte & 0x04) {
+				temp2 += (temp1 >> 2);
+			}
+			if (one_byte & 0x08) {
+				temp2 += (temp1 >> 3);
+			}
+			if (one_byte & 0x10) {
+				temp2 += (temp1 >> 4);
+			}
+			if (one_byte & 0x20) {
+				temp2 += (temp1 >> 5);
+			}
+			if (one_byte & 0x40) {
+				temp3 -= temp2;
+				if (temp3 <= (int32_t)0xFFFF8000) {
+					temp3 = (int32_t)0xFFFF8000;
+				}
+			} else {
+				temp3 += temp2;
+				if (temp3 >= 0x7FFF) {
+					temp3 = 0x7FFF;
+				}
+			}
+
+			/* restore index. */
+			nr_array2[index] = temp3;
+
+			/* check if should break. */
+			if (out_length < 2) {
+				break;
+			}
+
+			/* assign values. */
+			temp2             = nr_array1[index];
+			one_byte         &= 0x1F;
+			*out.pw++         = (uint16_t)temp3;
+			out_length       -= 2;
+			temp2            += wave_table_1503f120[one_byte];
+			nr_array1[index]  = temp2;
+
+			/* check index. */
+			if (nr_array1[index] < 0) {
+				nr_array1[index] = 0;
+			} else {
+
+				/* check index. */
+				if (nr_array1[index] > 0x58) {
+					nr_array1[index] = 0x58;
+				}
+			}
+		}
+	}
+
+	/* return copied bytes. */
+	return (out.pb - out_buf);
+}
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/wave.h temp-build/maptools/vmap_extractor/libmpq04/wave.h
--- clean-build/maptools/vmap_extractor/libmpq04/wave.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/wave.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,45 @@
+/*
+ *  wave.h -- header file for wav unplode functions used by mpq-tools.
+ *
+ *  Copyright (c) 2003-2007 Maik Broemme <mbroemme@plusserver.de>
+ *
+ *  This source was adepted from the C++ version of wave.h included
+ *  in stormlib. The C++ version belongs to the following authors:
+ *
+ *  Ladislav Zezula <ladik.zezula.net>
+ *  Tom Amigo <tomamigo@apexmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */       
+
+#ifndef _WAVE_H
+#define _WAVE_H
+
+/* buffer. */
+typedef union {
+	uint16_t	*pw;
+	uint8_t		*pb;
+} byte_and_int16_t;
+
+/* decompress a wave file, mono or stereo, 1500F230 offset. */
+int32_t libmpq__do_decompress_wave(
+	uint8_t		*out_buf,
+	int32_t		out_length,
+	uint8_t		*in_buf,
+	int32_t		in_length,
+	int32_t		channels
+);
+
+#endif						/* _WAVE_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/zconf.h temp-build/maptools/vmap_extractor/libmpq04/zconf.h
--- clean-build/maptools/vmap_extractor/libmpq04/zconf.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/zconf.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,316 @@
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_  z_deflateInit_
+#  define deflate       z_deflate
+#  define deflateEnd    z_deflateEnd
+#  define inflateInit_  z_inflateInit_
+#  define inflate       z_inflate
+#  define inflateEnd    z_inflateEnd
+#  define deflateInit2_ z_deflateInit2_
+#  define deflateSetDictionary z_deflateSetDictionary
+#  define deflateCopy   z_deflateCopy
+#  define deflateReset  z_deflateReset
+#  define deflatePrime  z_deflatePrime
+#  define deflateParams z_deflateParams
+#  define deflateBound  z_deflateBound
+#  define inflateInit2_ z_inflateInit2_
+#  define inflateSetDictionary z_inflateSetDictionary
+#  define inflateSync   z_inflateSync
+#  define inflateSyncPoint z_inflateSyncPoint
+#  define inflateCopy   z_inflateCopy
+#  define inflateReset  z_inflateReset
+#  define compress      z_compress
+#  define compress2     z_compress2
+#  define compressBound z_compressBound
+#  define uncompress    z_uncompress
+#  define adler32       z_adler32
+#  define crc32         z_crc32
+#  define get_crc_table z_get_crc_table
+
+#  define Byte          z_Byte
+#  define uInt          z_uInt
+#  define uLong         z_uLong
+#  define Bytef         z_Bytef
+#  define charf         z_charf
+#  define intf          z_intf
+#  define uIntf         z_uIntf
+#  define uLongf        z_uLongf
+#  define voidpf        z_voidpf
+#  define voidp         z_voidp
+#endif
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
+#  define WIN32
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
+#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ >= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+/* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+/* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+/* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+/* If building or using zlib as a DLL, define ZLIB_DLL.
+ * This is not mandatory, but it offers a little performance increase.
+ */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+/* If building or using zlib with the WINAPI/WINAPIV calling convention,
+ * define ZLIB_WINAPI.
+ * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+ */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+/* No need for _export, use ZLIB.DEF instead. */
+/* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+/* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+typedef void const* voidpc;
+typedef void FAR*   voidpf;
+typedef void*       voidp;
+#else
+typedef Byte const* voidpc;
+typedef Byte FAR*   voidpf;
+typedef Byte*       voidp;
+#endif
+
+#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
+#  include <sys/types.h> /* for off_t */
+#  include <unistd.h>    /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include <unixio.h>   /* for off_t */
+#  endif
+#  define z_off_t  off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define  z_off_t long
+#endif
+
+#if defined(__OS400__)
+#define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(deflateBound,"DEBND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(compressBound,"CMBND")
+#   pragma map(inflate_table,"INTABL")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_copyright,"INCOPY")
+#endif
+
+#endif /* ZCONF_H */
diff -Nuar clean-build/maptools/vmap_extractor/libmpq04/zlib.h temp-build/maptools/vmap_extractor/libmpq04/zlib.h
--- clean-build/maptools/vmap_extractor/libmpq04/zlib.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/libmpq04/zlib.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,1171 @@
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.2.1"
+#define ZLIB_VERNUM 0x1210
+
+    /*
+         The 'zlib' compression library provides in-memory compression and
+      decompression functions, including integrity checks of the uncompressed
+      data.  This version of the library supports only one compression method
+      (deflation) but other algorithms will be added later and will have the same
+      stream interface.
+
+         Compression can be done in a single step if the buffers are large
+      enough (for example if an input file is mmap'ed), or can be done by
+      repeated calls of the compression function.  In the latter case, the
+      application must provide more input and/or consume the output
+      (providing more output space) before each call.
+
+         The compressed data format used by the in-memory functions is the zlib
+      format, which is a zlib wrapper documented in RFC 1950, wrapped around a
+      deflate stream, which is itself documented in RFC 1951.
+
+         The library also supports reading and writing files in gzip (.gz) format
+      with an interface similar to that of stdio using the functions that start
+      with "gz".  The gzip format is different from the zlib format.  gzip is a
+      gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+         The zlib format was designed to be compact and fast for use in memory
+      and on communications channels.  The gzip format was designed for single-
+      file compression on file systems, has a larger header than zlib to maintain
+      directory information, and uses a different, slower check method than zlib.
+
+         This library does not provide any functions to write gzip files in memory.
+      However such functions could be easily written using zlib's deflate function,
+      the documentation in the gzip RFC, and the examples in gzio.c.
+
+         The library does not install any signal handler. The decoder checks
+      the consistency of the compressed data, so the library should never
+      crash even in case of corrupted input.
+    */
+
+    typedef voidpf(*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+    typedef void (*free_func)  OF((voidpf opaque, voidpf address));
+
+    struct internal_state;
+
+    typedef struct z_stream_s
+    {
+        Bytef*    next_in;  /* next input byte */
+        uInt     avail_in;  /* number of bytes available at next_in */
+        uLong    total_in;  /* total nb of input bytes read so far */
+
+        Bytef*    next_out; /* next output byte should be put there */
+        uInt     avail_out; /* remaining free space at next_out */
+        uLong    total_out; /* total nb of bytes output so far */
+
+        char*     msg;      /* last error message, NULL if no error */
+        struct internal_state FAR* state; /* not visible by applications */
+
+        alloc_func zalloc;  /* used to allocate the internal state */
+        free_func  zfree;   /* used to free the internal state */
+        voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+        int     data_type;  /* best guess about the data type: ascii or binary */
+        uLong   adler;      /* adler32 value of the uncompressed data */
+        uLong   reserved;   /* reserved for future use */
+    } z_stream;
+
+    typedef z_stream FAR* z_streamp;
+
+    /*
+       The application must update next_in and avail_in when avail_in has
+       dropped to zero. It must update next_out and avail_out when avail_out
+       has dropped to zero. The application must initialize zalloc, zfree and
+       opaque before calling the init function. All other fields are set by the
+       compression library and must not be updated by the application.
+
+       The opaque value provided by the application will be passed as the first
+       parameter for calls of zalloc and zfree. This can be useful for custom
+       memory management. The compression library attaches no meaning to the
+       opaque value.
+
+       zalloc must return Z_NULL if there is not enough memory for the object.
+       If zlib is used in a multi-threaded application, zalloc and zfree must be
+       thread safe.
+
+       On 16-bit systems, the functions zalloc and zfree must be able to allocate
+       exactly 65536 bytes, but will not be required to allocate more than this
+       if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+       pointers returned by zalloc for objects of exactly 65536 bytes *must*
+       have their offset normalized to zero. The default allocation function
+       provided by this library ensures this (see zutil.c). To reduce memory
+       requirements and avoid any allocation of 64K objects, at the expense of
+       compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+       The fields total_in and total_out can be used for statistics or
+       progress reports. After compression, total_in holds the total size of
+       the uncompressed data and may be saved for use in the decompressor
+       (particularly if the decompressor wants to decompress everything in
+       a single step).
+    */
+
+    /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+    /* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+    /* Return codes for the compression/decompression functions. Negative
+     * values are errors, positive values are used for special but normal events.
+     */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+    /* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_DEFAULT_STRATEGY    0
+    /* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+    /* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+    /* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+    /* for compatibility with versions < 1.0.2 */
+
+    /* basic functions */
+
+    ZEXTERN const char* ZEXPORT zlibVersion OF((void));
+    /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+       If the first character differs, the library code actually used is
+       not compatible with the zlib.h header file used by the application.
+       This check is automatically made by deflateInit and inflateInit.
+     */
+
+    /*
+    ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+         Initializes the internal stream state for compression. The fields
+       zalloc, zfree and opaque must be initialized before by the caller.
+       If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+       use default allocation functions.
+
+         The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+       1 gives best speed, 9 gives best compression, 0 gives no compression at
+       all (the input data is simply copied a block at a time).
+       Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+       compression (currently equivalent to level 6).
+
+         deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+       Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+       with the version assumed by the caller (ZLIB_VERSION).
+       msg is set to null if there is no error message.  deflateInit does not
+       perform any compression: this will be done by deflate().
+    */
+
+
+    ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+    /*
+        deflate compresses as much data as possible, and stops when the input
+      buffer becomes empty or the output buffer becomes full. It may introduce some
+      output latency (reading input without producing any output) except when
+      forced to flush.
+
+        The detailed semantics are as follows. deflate performs one or both of the
+      following actions:
+
+      - Compress more input starting at next_in and update next_in and avail_in
+        accordingly. If not all input can be processed (because there is not
+        enough room in the output buffer), next_in and avail_in are updated and
+        processing will resume at this point for the next call of deflate().
+
+      - Provide more output starting at next_out and update next_out and avail_out
+        accordingly. This action is forced if the parameter flush is non zero.
+        Forcing flush frequently degrades the compression ratio, so this parameter
+        should be set only when necessary (in interactive applications).
+        Some output may be provided even if flush is not set.
+
+      Before the call of deflate(), the application should ensure that at least
+      one of the actions is possible, by providing more input and/or consuming
+      more output, and updating avail_in or avail_out accordingly; avail_out
+      should never be zero before the call. The application can consume the
+      compressed output when it wants, for example when the output buffer is full
+      (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+      and with zero avail_out, it must be called again after making room in the
+      output buffer because there might be more output pending.
+
+        If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+      flushed to the output buffer and the output is aligned on a byte boundary, so
+      that the decompressor can get all input data available so far. (In particular
+      avail_in is zero after the call if enough output space has been provided
+      before the call.)  Flushing may degrade compression for some compression
+      algorithms and so it should be used only when necessary.
+
+        If flush is set to Z_FULL_FLUSH, all output is flushed as with
+      Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+      restart from this point if previous compressed data has been damaged or if
+      random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+      the compression.
+
+        If deflate returns with avail_out == 0, this function must be called again
+      with the same value of the flush parameter and more output space (updated
+      avail_out), until the flush is complete (deflate returns with non-zero
+      avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+      avail_out is greater than six to avoid repeated flush markers due to
+      avail_out == 0 on return.
+
+        If the parameter flush is set to Z_FINISH, pending input is processed,
+      pending output is flushed and deflate returns with Z_STREAM_END if there
+      was enough output space; if deflate returns with Z_OK, this function must be
+      called again with Z_FINISH and more output space (updated avail_out) but no
+      more input data, until it returns with Z_STREAM_END or an error. After
+      deflate has returned Z_STREAM_END, the only possible operations on the
+      stream are deflateReset or deflateEnd.
+
+        Z_FINISH can be used immediately after deflateInit if all the compression
+      is to be done in a single step. In this case, avail_out must be at least
+      the value returned by deflateBound (see below). If deflate does not return
+      Z_STREAM_END, then it must be called again as described above.
+
+        deflate() sets strm->adler to the adler32 checksum of all input read
+      so far (that is, total_in bytes).
+
+        deflate() may update data_type if it can make a good guess about
+      the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+      binary. This field is only for information purposes and does not affect
+      the compression algorithm in any manner.
+
+        deflate() returns Z_OK if some progress has been made (more input
+      processed or more output produced), Z_STREAM_END if all input has been
+      consumed and all output has been produced (only when flush is set to
+      Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+      if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+      (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+      fatal, and deflate() can be called again with more input and more output
+      space to continue compressing.
+    */
+
+
+    ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+    /*
+         All dynamically allocated data structures for this stream are freed.
+       This function discards any unprocessed input and does not flush any
+       pending output.
+
+         deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+       stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+       prematurely (some input or output was discarded). In the error case,
+       msg may be set but then points to a static string (which must not be
+       deallocated).
+    */
+
+
+    /*
+    ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+         Initializes the internal stream state for decompression. The fields
+       next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+       the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+       value depends on the compression method), inflateInit determines the
+       compression method from the zlib header and allocates all data structures
+       accordingly; otherwise the allocation will be deferred to the first call of
+       inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+       use default allocation functions.
+
+         inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+       memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+       version assumed by the caller.  msg is set to null if there is no error
+       message. inflateInit does not perform any decompression apart from reading
+       the zlib header if present: this will be done by inflate().  (So next_in and
+       avail_in may be modified, but next_out and avail_out are unchanged.)
+    */
+
+
+    ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+    /*
+        inflate decompresses as much data as possible, and stops when the input
+      buffer becomes empty or the output buffer becomes full. It may introduce
+      some output latency (reading input without producing any output) except when
+      forced to flush.
+
+      The detailed semantics are as follows. inflate performs one or both of the
+      following actions:
+
+      - Decompress more input starting at next_in and update next_in and avail_in
+        accordingly. If not all input can be processed (because there is not
+        enough room in the output buffer), next_in is updated and processing
+        will resume at this point for the next call of inflate().
+
+      - Provide more output starting at next_out and update next_out and avail_out
+        accordingly.  inflate() provides as much output as possible, until there
+        is no more input data or no more space in the output buffer (see below
+        about the flush parameter).
+
+      Before the call of inflate(), the application should ensure that at least
+      one of the actions is possible, by providing more input and/or consuming
+      more output, and updating the next_* and avail_* values accordingly.
+      The application can consume the uncompressed output when it wants, for
+      example when the output buffer is full (avail_out == 0), or after each
+      call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+      must be called again after making room in the output buffer because there
+      might be more output pending.
+
+        The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+      Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+      output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+      if and when it get to the next deflate block boundary. When decoding the zlib
+      or gzip format, this will cause inflate() to return immediately after the
+      header and before the first block. When doing a raw inflate, inflate() will
+      go ahead and process the first block, and will return when it gets to the end
+      of that block, or when it runs out of data.
+
+        The Z_BLOCK option assists in appending to or combining deflate streams.
+      Also to assist in this, on return inflate() will set strm->data_type to the
+      number of unused bits in the last byte taken from strm->next_in, plus 64
+      if inflate() is currently decoding the last block in the deflate stream,
+      plus 128 if inflate() returned immediately after decoding an end-of-block
+      code or decoding the complete header up to just before the first byte of the
+      deflate stream. The end-of-block will not be indicated until all of the
+      uncompressed data from that block has been written to strm->next_out.  The
+      number of unused bits may in general be greater than seven, except when
+      bit 7 of data_type is set, in which case the number of unused bits will be
+      less than eight.
+
+        inflate() should normally be called until it returns Z_STREAM_END or an
+      error. However if all decompression is to be performed in a single step
+      (a single call of inflate), the parameter flush should be set to
+      Z_FINISH. In this case all pending input is processed and all pending
+      output is flushed; avail_out must be large enough to hold all the
+      uncompressed data. (The size of the uncompressed data may have been saved
+      by the compressor for this purpose.) The next operation on this stream must
+      be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+      is never required, but can be used to inform inflate that a faster approach
+      may be used for the single inflate() call.
+
+         In this implementation, inflate() always flushes as much output as
+      possible to the output buffer, and always uses the faster approach on the
+      first call. So the only effect of the flush parameter in this implementation
+      is on the return value of inflate(), as noted below, or when it returns early
+      because Z_BLOCK is used.
+
+         If a preset dictionary is needed after this call (see inflateSetDictionary
+      below), inflate sets strm-adler to the adler32 checksum of the dictionary
+      chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+      strm->adler to the adler32 checksum of all output produced so far (that is,
+      total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+      below. At the end of the stream, inflate() checks that its computed adler32
+      checksum is equal to that saved by the compressor and returns Z_STREAM_END
+      only if the checksum is correct.
+
+        inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+      deflate data.  The header type is detected automatically.  Any information
+      contained in the gzip header is not retained, so applications that need that
+      information should instead use raw inflate, see inflateInit2() below, or
+      inflateBack() and perform their own processing of the gzip header and
+      trailer.
+
+        inflate() returns Z_OK if some progress has been made (more input processed
+      or more output produced), Z_STREAM_END if the end of the compressed data has
+      been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+      preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+      corrupted (input stream not conforming to the zlib format or incorrect check
+      value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+      if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+      Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+      output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+      inflate() can be called again with more input and more output space to
+      continue decompressing. If Z_DATA_ERROR is returned, the application may then
+      call inflateSync() to look for a good compression block if a partial recovery
+      of the data is desired.
+    */
+
+
+    ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+    /*
+         All dynamically allocated data structures for this stream are freed.
+       This function discards any unprocessed input and does not flush any
+       pending output.
+
+         inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+       was inconsistent. In the error case, msg may be set but then points to a
+       static string (which must not be deallocated).
+    */
+
+    /* Advanced functions */
+
+    /*
+        The following functions are needed only in some special applications.
+    */
+
+    /*
+    ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                         int  level,
+                                         int  method,
+                                         int  windowBits,
+                                         int  memLevel,
+                                         int  strategy));
+
+         This is another version of deflateInit with more compression options. The
+       fields next_in, zalloc, zfree and opaque must be initialized before by
+       the caller.
+
+         The method parameter is the compression method. It must be Z_DEFLATED in
+       this version of the library.
+
+         The windowBits parameter is the base two logarithm of the window size
+       (the size of the history buffer). It should be in the range 8..15 for this
+       version of the library. Larger values of this parameter result in better
+       compression at the expense of memory usage. The default value is 15 if
+       deflateInit is used instead.
+
+         windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
+       determines the window size. deflate() will then generate raw deflate data
+       with no zlib header or trailer, and will not compute an adler32 check value.
+
+         windowBits can also be greater than 15 for optional gzip encoding. Add
+       16 to windowBits to write a simple gzip header and trailer around the
+       compressed data instead of a zlib wrapper. The gzip header will have no
+       file name, no extra data, no comment, no modification time (set to zero),
+       no header crc, and the operating system will be set to 255 (unknown).
+
+         The memLevel parameter specifies how much memory should be allocated
+       for the internal compression state. memLevel=1 uses minimum memory but
+       is slow and reduces compression ratio; memLevel=9 uses maximum memory
+       for optimal speed. The default value is 8. See zconf.h for total memory
+       usage as a function of windowBits and memLevel.
+
+         The strategy parameter is used to tune the compression algorithm. Use the
+       value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+       filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+       string match), or Z_RLE to limit match distances to one (run-length
+       encoding). Filtered data consists mostly of small values with a somewhat
+       random distribution. In this case, the compression algorithm is tuned to
+       compress them better. The effect of Z_FILTERED is to force more Huffman
+       coding and less string matching; it is somewhat intermediate between
+       Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
+       Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
+       parameter only affects the compression ratio but not the correctness of the
+       compressed output even if it is not set appropriately.
+
+          deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+       memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+       method). msg is set to null if there is no error message.  deflateInit2 does
+       not perform any compression: this will be done by deflate().
+    */
+
+    ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+            const Bytef* dictionary,
+            uInt  dictLength));
+    /*
+         Initializes the compression dictionary from the given byte sequence
+       without producing any compressed output. This function must be called
+       immediately after deflateInit, deflateInit2 or deflateReset, before any
+       call of deflate. The compressor and decompressor must use exactly the same
+       dictionary (see inflateSetDictionary).
+
+         The dictionary should consist of strings (byte sequences) that are likely
+       to be encountered later in the data to be compressed, with the most commonly
+       used strings preferably put towards the end of the dictionary. Using a
+       dictionary is most useful when the data to be compressed is short and can be
+       predicted with good accuracy; the data can then be compressed better than
+       with the default empty dictionary.
+
+         Depending on the size of the compression data structures selected by
+       deflateInit or deflateInit2, a part of the dictionary may in effect be
+       discarded, for example if the dictionary is larger than the window size in
+       deflate or deflate2. Thus the strings most likely to be useful should be
+       put at the end of the dictionary, not at the front.
+
+         Upon return of this function, strm->adler is set to the adler32 value
+       of the dictionary; the decompressor may later use this value to determine
+       which dictionary has been used by the compressor. (The adler32 value
+       applies to the whole dictionary even if only a subset of the dictionary is
+       actually used by the compressor.) If a raw deflate was requested, then the
+       adler32 value is not computed and strm->adler is not set.
+
+         deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+       parameter is invalid (such as NULL dictionary) or the stream state is
+       inconsistent (for example if deflate has already been called for this stream
+       or if the compression method is bsort). deflateSetDictionary does not
+       perform any compression: this will be done by deflate().
+    */
+
+    ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                        z_streamp source));
+    /*
+         Sets the destination stream as a complete copy of the source stream.
+
+         This function can be useful when several compression strategies will be
+       tried, for example when there are several ways of pre-processing the input
+       data with a filter. The streams that will be discarded should then be freed
+       by calling deflateEnd.  Note that deflateCopy duplicates the internal
+       compression state which can be quite large, so this strategy is slow and
+       can consume lots of memory.
+
+         deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+       (such as zalloc being NULL). msg is left unchanged in both source and
+       destination.
+    */
+
+    ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+    /*
+         This function is equivalent to deflateEnd followed by deflateInit,
+       but does not free and reallocate all the internal compression state.
+       The stream will keep the same compression level and any other attributes
+       that may have been set by deflateInit2.
+
+          deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+       stream state was inconsistent (such as zalloc or state being NULL).
+    */
+
+    ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                          int level,
+                                          int strategy));
+    /*
+         Dynamically update the compression level and compression strategy.  The
+       interpretation of level and strategy is as in deflateInit2.  This can be
+       used to switch between compression and straight copy of the input data, or
+       to switch to a different kind of input data requiring a different
+       strategy. If the compression level is changed, the input available so far
+       is compressed with the old level (and may be flushed); the new level will
+       take effect only at the next call of deflate().
+
+         Before the call of deflateParams, the stream state must be set as for
+       a call of deflate(), since the currently available input may have to
+       be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+         deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+       stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+       if strm->avail_out was zero.
+    */
+
+    ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                           uLong sourceLen));
+    /*
+         deflateBound() returns an upper bound on the compressed size after
+       deflation of sourceLen bytes.  It must be called after deflateInit()
+       or deflateInit2().  This would be used to allocate an output buffer
+       for deflation in a single pass, and so would be called before deflate().
+    */
+
+    ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                         int bits,
+                                         int value));
+    /*
+         deflatePrime() inserts bits in the deflate output stream.  The intent
+      is that this function is used to start off the deflate output with the
+      bits leftover from a previous deflate stream when appending to it.  As such,
+      this function can only be used for raw deflate, and must be used before the
+      first deflate() call after a deflateInit2() or deflateReset().  bits must be
+      less than or equal to 16, and that many of the least significant bits of
+      value will be inserted in the output.
+
+          deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+       stream state was inconsistent.
+    */
+
+    /*
+    ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                         int  windowBits));
+
+         This is another version of inflateInit with an extra parameter. The
+       fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+       before by the caller.
+
+         The windowBits parameter is the base two logarithm of the maximum window
+       size (the size of the history buffer).  It should be in the range 8..15 for
+       this version of the library. The default value is 15 if inflateInit is used
+       instead. windowBits must be greater than or equal to the windowBits value
+       provided to deflateInit2() while compressing, or it must be equal to 15 if
+       deflateInit2() was not used. If a compressed stream with a larger window
+       size is given as input, inflate() will return with the error code
+       Z_DATA_ERROR instead of trying to allocate a larger window.
+
+         windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
+       determines the window size. inflate() will then process raw deflate data,
+       not looking for a zlib or gzip header, not generating a check value, and not
+       looking for any check values for comparison at the end of the stream. This
+       is for use with other formats that use the deflate compressed data format
+       such as zip.  Those formats provide their own check values. If a custom
+       format is developed using the raw deflate format for compressed data, it is
+       recommended that a check value such as an adler32 or a crc32 be applied to
+       the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+       most applications, the zlib format should be used as is. Note that comments
+       above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+         windowBits can also be greater than 15 for optional gzip decoding. Add
+       32 to windowBits to enable zlib and gzip decoding with automatic header
+       detection, or add 16 to decode only the gzip format (the zlib format will
+       return a Z_DATA_ERROR).
+
+         inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+       memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
+       memLevel). msg is set to null if there is no error message.  inflateInit2
+       does not perform any decompression apart from reading the zlib header if
+       present: this will be done by inflate(). (So next_in and avail_in may be
+       modified, but next_out and avail_out are unchanged.)
+    */
+
+    ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+            const Bytef* dictionary,
+            uInt  dictLength));
+    /*
+         Initializes the decompression dictionary from the given uncompressed byte
+       sequence. This function must be called immediately after a call of inflate
+       if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
+       can be determined from the adler32 value returned by this call of
+       inflate. The compressor and decompressor must use exactly the same
+       dictionary (see deflateSetDictionary).
+
+         inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+       parameter is invalid (such as NULL dictionary) or the stream state is
+       inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+       expected one (incorrect adler32 value). inflateSetDictionary does not
+       perform any decompression: this will be done by subsequent calls of
+       inflate().
+    */
+
+    ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+    /*
+        Skips invalid compressed data until a full flush point (see above the
+      description of deflate with Z_FULL_FLUSH) can be found, or until all
+      available input is skipped. No output is provided.
+
+        inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+      if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+      or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+      case, the application may save the current current value of total_in which
+      indicates where valid compressed data was found. In the error case, the
+      application may repeatedly call inflateSync, providing more input each time,
+      until success or end of the input data.
+    */
+
+    ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                        z_streamp source));
+    /*
+         Sets the destination stream as a complete copy of the source stream.
+
+         This function can be useful when randomly accessing a large stream.  The
+       first pass through the stream can periodically record the inflate state,
+       allowing restarting inflate at those points when randomly accessing the
+       stream.
+
+         inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+       (such as zalloc being NULL). msg is left unchanged in both source and
+       destination.
+    */
+
+    ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+    /*
+         This function is equivalent to inflateEnd followed by inflateInit,
+       but does not free and reallocate all the internal decompression state.
+       The stream will keep attributes that may have been set by inflateInit2.
+
+          inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+       stream state was inconsistent (such as zalloc or state being NULL).
+    */
+
+    /*
+    ZEXTERN int ZEXPORT inflateBackInit OF((z_stream FAR *strm, int windowBits,
+                                            unsigned char FAR *window));
+
+         Initialize the internal stream state for decompression using inflateBack()
+       calls.  The fields zalloc, zfree and opaque in strm must be initialized
+       before the call.  If zalloc and zfree are Z_NULL, then the default library-
+       derived memory allocation routines are used.  windowBits is the base two
+       logarithm of the window size, in the range 8..15.  window is a caller
+       supplied buffer of that size.  Except for special applications where it is
+       assured that deflate was used with small window sizes, windowBits must be 15
+       and a 32K byte window must be supplied to be able to decompress general
+       deflate streams.
+
+         See inflateBack() for the usage of these routines.
+
+         inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+       the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+       be allocated, or Z_VERSION_ERROR if the version of the library does not
+       match the version of the header file.
+    */
+
+    typedef unsigned(*in_func) OF((void FAR*, unsigned char FAR* FAR*));
+    typedef int (*out_func) OF((void FAR*, unsigned char FAR*, unsigned));
+
+    ZEXTERN int ZEXPORT inflateBack OF((z_stream FAR* strm,
+                                        in_func in, void FAR* in_desc,
+                                        out_func out, void FAR* out_desc));
+    /*
+         inflateBack() does a raw inflate with a single call using a call-back
+       interface for input and output.  This is more efficient than inflate() for
+       file i/o applications in that it avoids copying between the output and the
+       sliding window by simply making the window itself the output buffer.  This
+       function trusts the application to not change the output buffer passed by
+       the output function, at least until inflateBack() returns.
+
+         inflateBackInit() must be called first to allocate the internal state
+       and to initialize the state with the user-provided window buffer.
+       inflateBack() may then be used multiple times to inflate a complete, raw
+       deflate stream with each call.  inflateBackEnd() is then called to free
+       the allocated state.
+
+         A raw deflate stream is one with no zlib or gzip header or trailer.
+       This routine would normally be used in a utility that reads zip or gzip
+       files and writes out uncompressed files.  The utility would decode the
+       header and process the trailer on its own, hence this routine expects
+       only the raw deflate stream to decompress.  This is different from the
+       normal behavior of inflate(), which expects either a zlib or gzip header and
+       trailer around the deflate stream.
+
+         inflateBack() uses two subroutines supplied by the caller that are then
+       called by inflateBack() for input and output.  inflateBack() calls those
+       routines until it reads a complete deflate stream and writes out all of the
+       uncompressed data, or until it encounters an error.  The function's
+       parameters and return types are defined above in the in_func and out_func
+       typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
+       number of bytes of provided input, and a pointer to that input in buf.  If
+       there is no input available, in() must return zero--buf is ignored in that
+       case--and inflateBack() will return a buffer error.  inflateBack() will call
+       out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+       should return zero on success, or non-zero on failure.  If out() returns
+       non-zero, inflateBack() will return with an error.  Neither in() nor out()
+       are permitted to change the contents of the window provided to
+       inflateBackInit(), which is also the buffer that out() uses to write from.
+       The length written by out() will be at most the window size.  Any non-zero
+       amount of input may be provided by in().
+
+         For convenience, inflateBack() can be provided input on the first call by
+       setting strm->next_in and strm->avail_in.  If that input is exhausted, then
+       in() will be called.  Therefore strm->next_in must be initialized before
+       calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
+       immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
+       must also be initialized, and then if strm->avail_in is not zero, input will
+       initially be taken from strm->next_in[0 .. strm->avail_in - 1].
+
+         The in_desc and out_desc parameters of inflateBack() is passed as the
+       first parameter of in() and out() respectively when they are called.  These
+       descriptors can be optionally used to pass any information that the caller-
+       supplied in() and out() functions need to do their job.
+
+         On return, inflateBack() will set strm->next_in and strm->avail_in to
+       pass back any unused input that was provided by the last in() call.  The
+       return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+       if in() or out() returned an error, Z_DATA_ERROR if there was a format
+       error in the deflate stream (in which case strm->msg is set to indicate the
+       nature of the error), or Z_STREAM_ERROR if the stream was not properly
+       initialized.  In the case of Z_BUF_ERROR, an input or output error can be
+       distinguished using strm->next_in which will be Z_NULL only if in() returned
+       an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
+       out() returning non-zero.  (in() will always be called before out(), so
+       strm->next_in is assured to be defined if out() returns non-zero.)  Note
+       that inflateBack() cannot return Z_OK.
+    */
+
+    ZEXTERN int ZEXPORT inflateBackEnd OF((z_stream FAR* strm));
+    /*
+         All memory allocated by inflateBackInit() is freed.
+
+         inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+       state was inconsistent.
+    */
+
+    ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+    /* Return flags indicating compile-time options.
+
+        Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+         1.0: size of uInt
+         3.2: size of uLong
+         5.4: size of voidpf (pointer)
+         7.6: size of z_off_t
+
+        Compiler, assembler, and debug options:
+         8: DEBUG
+         9: ASMV or ASMINF -- use ASM code
+         10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+         11: 0 (reserved)
+
+        One-time table building (smaller code, but not thread-safe if true):
+         12: BUILDFIXED -- build static block decoding tables when needed
+         13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+         14,15: 0 (reserved)
+
+        Library content (indicates missing functionality):
+         16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                              deflate code when not needed)
+         17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                        and decode gzip streams (to avoid linking crc code)
+         18-19: 0 (reserved)
+
+        Operation variations (changes in library functionality):
+         20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+         21: FASTEST -- deflate algorithm with only one, lowest compression level
+         22,23: 0 (reserved)
+
+        The sprintf variant used by gzprintf (zero is best):
+         24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+         25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+         26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+        Remainder:
+         27-31: 0 (reserved)
+     */
+
+
+    /* utility functions */
+
+    /*
+         The following utility functions are implemented on top of the
+       basic stream-oriented functions. To simplify the interface, some
+       default options are assumed (compression level and memory usage,
+       standard memory allocation functions). The source code of these
+       utility functions can easily be modified if you need special options.
+    */
+
+    ZEXTERN int ZEXPORT compress OF((Bytef* dest,   uLongf* destLen,
+                                     const Bytef* source, uLong sourceLen));
+    /*
+         Compresses the source buffer into the destination buffer.  sourceLen is
+       the byte length of the source buffer. Upon entry, destLen is the total
+       size of the destination buffer, which must be at least the value returned
+       by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+       compressed buffer.
+         This function can be used to compress a whole file at once if the
+       input file is mmap'ed.
+         compress returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_BUF_ERROR if there was not enough room in the output
+       buffer.
+    */
+
+    ZEXTERN int ZEXPORT compress2 OF((Bytef* dest,   uLongf* destLen,
+                                      const Bytef* source, uLong sourceLen,
+                                      int level));
+    /*
+         Compresses the source buffer into the destination buffer. The level
+       parameter has the same meaning as in deflateInit.  sourceLen is the byte
+       length of the source buffer. Upon entry, destLen is the total size of the
+       destination buffer, which must be at least the value returned by
+       compressBound(sourceLen). Upon exit, destLen is the actual size of the
+       compressed buffer.
+
+         compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+       memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+       Z_STREAM_ERROR if the level parameter is invalid.
+    */
+
+    ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+    /*
+         compressBound() returns an upper bound on the compressed size after
+       compress() or compress2() on sourceLen bytes.  It would be used before
+       a compress() or compress2() call to allocate the destination buffer.
+    */
+
+    ZEXTERN int ZEXPORT uncompress OF((Bytef* dest,   uLongf* destLen,
+                                       const Bytef* source, uLong sourceLen));
+    /*
+         Decompresses the source buffer into the destination buffer.  sourceLen is
+       the byte length of the source buffer. Upon entry, destLen is the total
+       size of the destination buffer, which must be large enough to hold the
+       entire uncompressed data. (The size of the uncompressed data must have
+       been saved previously by the compressor and transmitted to the decompressor
+       by some mechanism outside the scope of this compression library.)
+       Upon exit, destLen is the actual size of the compressed buffer.
+         This function can be used to decompress a whole file at once if the
+       input file is mmap'ed.
+
+         uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+       enough memory, Z_BUF_ERROR if there was not enough room in the output
+       buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+    */
+
+
+    typedef voidp gzFile;
+
+    ZEXTERN gzFile ZEXPORT gzopen  OF((const char* path, const char* mode));
+    /*
+         Opens a gzip (.gz) file for reading or writing. The mode parameter
+       is as in fopen ("rb" or "wb") but can also include a compression level
+       ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
+       Huffman only compression as in "wb1h", or 'R' for run-length encoding
+       as in "wb1R". (See the description of deflateInit2 for more information
+       about the strategy parameter.)
+
+         gzopen can be used to read a file which is not in gzip format; in this
+       case gzread will directly read from the file without decompression.
+
+         gzopen returns NULL if the file could not be opened or if there was
+       insufficient memory to allocate the (de)compression state; errno
+       can be checked to distinguish the two cases (if errno is zero, the
+       zlib error is Z_MEM_ERROR).  */
+
+    ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char* mode));
+    /*
+         gzdopen() associates a gzFile with the file descriptor fd.  File
+       descriptors are obtained from calls like open, dup, creat, pipe or
+       fileno (in the file has been previously opened with fopen).
+       The mode parameter is as in gzopen.
+         The next call of gzclose on the returned gzFile will also close the
+       file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+       descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+         gzdopen returns NULL if there was insufficient memory to allocate
+       the (de)compression state.
+    */
+
+    ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+    /*
+         Dynamically update the compression level or strategy. See the description
+       of deflateInit2 for the meaning of these parameters.
+         gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+       opened for writing.
+    */
+
+    ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+    /*
+         Reads the given number of uncompressed bytes from the compressed file.
+       If the input file was not in gzip format, gzread copies the given number
+       of bytes into the buffer.
+         gzread returns the number of uncompressed bytes actually read (0 for
+       end of file, -1 for error). */
+
+    ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
+                                       voidpc buf, unsigned len));
+    /*
+         Writes the given number of uncompressed bytes into the compressed file.
+       gzwrite returns the number of uncompressed bytes actually written
+       (0 in case of error).
+    */
+
+    ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char* format, ...));
+    /*
+         Converts, formats, and writes the args to the compressed file under
+       control of the format string, as in fprintf. gzprintf returns the number of
+       uncompressed bytes actually written (0 in case of error).  The number of
+       uncompressed bytes written is limited to 4095. The caller should assure that
+       this limit is not exceeded. If it is exceeded, then gzprintf() will return
+       return an error (0) with nothing written. In this case, there may also be a
+       buffer overflow with unpredictable consequences, which is possible only if
+       zlib was compiled with the insecure functions sprintf() or vsprintf()
+       because the secure snprintf() or vsnprintf() functions were not available.
+    */
+
+    ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char* s));
+    /*
+          Writes the given null-terminated string to the compressed file, excluding
+       the terminating null character.
+          gzputs returns the number of characters written, or -1 in case of error.
+    */
+
+    ZEXTERN char* ZEXPORT gzgets OF((gzFile file, char* buf, int len));
+    /*
+          Reads bytes from the compressed file until len-1 characters are read, or
+       a newline character is read and transferred to buf, or an end-of-file
+       condition is encountered.  The string is then terminated with a null
+       character.
+          gzgets returns buf, or Z_NULL in case of error.
+    */
+
+    ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+    /*
+          Writes c, converted to an unsigned char, into the compressed file.
+       gzputc returns the value that was written, or -1 in case of error.
+    */
+
+    ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+    /*
+          Reads one byte from the compressed file. gzgetc returns this byte
+       or -1 in case of end of file or error.
+    */
+
+    ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+    /*
+          Push one character back onto the stream to be read again later.
+       Only one character of push-back is allowed.  gzungetc() returns the
+       character pushed, or -1 on failure.  gzungetc() will fail if a
+       character has been pushed but not read yet, or if c is -1. The pushed
+       character will be discarded if the stream is repositioned with gzseek()
+       or gzrewind().
+    */
+
+    ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+    /*
+         Flushes all pending output into the compressed file. The parameter
+       flush is as in the deflate() function. The return value is the zlib
+       error number (see function gzerror below). gzflush returns Z_OK if
+       the flush parameter is Z_FINISH and all output could be flushed.
+         gzflush should be called only when strictly necessary because it can
+       degrade compression.
+    */
+
+    ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+                                          z_off_t offset, int whence));
+    /*
+          Sets the starting position for the next gzread or gzwrite on the
+       given compressed file. The offset represents a number of bytes in the
+       uncompressed data stream. The whence parameter is defined as in lseek(2);
+       the value SEEK_END is not supported.
+         If the file is opened for reading, this function is emulated but can be
+       extremely slow. If the file is opened for writing, only forward seeks are
+       supported; gzseek then compresses a sequence of zeroes up to the new
+       starting position.
+
+          gzseek returns the resulting offset location as measured in bytes from
+       the beginning of the uncompressed stream, or -1 in case of error, in
+       particular if the file is opened for writing and the new starting position
+       would be before the current position.
+    */
+
+    ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+    /*
+         Rewinds the given file. This function is supported only for reading.
+
+       gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+    */
+
+    ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+    /*
+         Returns the starting position for the next gzread or gzwrite on the
+       given compressed file. This position represents a number of bytes in the
+       uncompressed data stream.
+
+       gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+    */
+
+    ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+    /*
+         Returns 1 when EOF has previously been detected reading the given
+       input stream, otherwise zero.
+    */
+
+    ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+    /*
+         Flushes all pending output if necessary, closes the compressed file
+       and deallocates all the (de)compression state. The return value is the zlib
+       error number (see function gzerror below).
+    */
+
+    ZEXTERN const char* ZEXPORT gzerror OF((gzFile file, int* errnum));
+    /*
+         Returns the error message for the last error which occurred on the
+       given compressed file. errnum is set to zlib error number. If an
+       error occurred in the file system and not in the compression library,
+       errnum is set to Z_ERRNO and the application may consult errno
+       to get the exact error code.
+    */
+
+    ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+    /*
+         Clears the error and end-of-file flags for file. This is analogous to the
+       clearerr() function in stdio. This is useful for continuing to read a gzip
+       file that is being written concurrently.
+    */
+
+    /* checksum functions */
+
+    /*
+         These functions are not related to compression but are exported
+       anyway because they might be useful in applications using the
+       compression library.
+    */
+
+    ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef* buf, uInt len));
+
+    /*
+         Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+       return the updated checksum. If buf is NULL, this function returns
+       the required initial value for the checksum.
+       An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+       much faster. Usage example:
+
+         uLong adler = adler32(0L, Z_NULL, 0);
+
+         while (read_buffer(buffer, length) != EOF) {
+           adler = adler32(adler, buffer, length);
+         }
+         if (adler != original_adler) error();
+    */
+
+    ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef* buf, uInt len));
+    /*
+         Update a running crc with the bytes buf[0..len-1] and return the updated
+       crc. If buf is NULL, this function returns the required initial value
+       for the crc. Pre- and post-conditioning (one's complement) is performed
+       within this function so it shouldn't be done by the application.
+       Usage example:
+
+         uLong crc = crc32(0L, Z_NULL, 0);
+
+         while (read_buffer(buffer, length) != EOF) {
+           crc = crc32(crc, buffer, length);
+         }
+         if (crc != original_crc) error();
+    */
+
+
+    /* various hacks, don't look :) */
+
+    /* deflateInit and inflateInit are macros to allow checking the zlib version
+     * and the compiler's view of z_stream:
+     */
+    ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                         const char* version, int stream_size));
+    ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                         const char* version, int stream_size));
+    ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                          int windowBits, int memLevel,
+                                          int strategy, const char* version,
+                                          int stream_size));
+    ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                          const char* version, int stream_size));
+    ZEXTERN int ZEXPORT inflateBackInit_ OF((z_stream FAR* strm, int windowBits,
+                                            unsigned char FAR* window,
+                                            const char* version,
+                                            int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+        ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+    ZEXTERN const char*    ZEXPORT zError           OF((int err));
+    ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+    ZEXTERN const uLongf* ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */
diff -Nuar clean-build/maptools/vmap_extractor/loadlib.h temp-build/maptools/vmap_extractor/loadlib.h
--- clean-build/maptools/vmap_extractor/loadlib.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/loadlib.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,52 @@
+#ifndef LOAD_LIB_H
+#define LOAD_LIB_H
+
+#include <stdint.h>
+
+#ifndef uint64_t
+#  ifdef __linux__
+#    include <linux/types.h>
+#  endif
+#endif
+
+typedef int64_t            int64;
+typedef int32_t            int32;
+typedef int16_t            int16;
+typedef int8_t             int8;
+typedef uint64_t           uint64;
+typedef uint32_t           uint32;
+typedef uint16_t           uint16;
+typedef uint8_t            uint8;
+
+#define FILE_FORMAT_VERSION    18
+
+//
+// File version chunk
+//
+struct file_MVER
+{
+    union
+    {
+        uint32 fcc;
+        char   fcc_txt[4];
+    };
+    uint32 size;
+    uint32 ver;
+};
+
+class FileLoader
+{
+        uint8*  data;
+        uint32  data_size;
+    public:
+        virtual bool prepareLoadedData();
+        uint8* GetData()     {return data;}
+        uint32 GetDataSize() {return data_size;}
+
+        file_MVER* version;
+        FileLoader();
+        ~FileLoader();
+        bool loadFile(char* filename, bool log = true);
+        virtual void free();
+};
+#endif
diff -Nuar clean-build/maptools/vmap_extractor/model.cpp temp-build/maptools/vmap_extractor/model.cpp
--- clean-build/maptools/vmap_extractor/model.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/model.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,181 @@
+#include "vmapexport.h"
+#include "model.h"
+#include "wmo.h"
+#include "mpq_libmpq04.h"
+#include <cassert>
+#include <algorithm>
+#include <cstdio>
+
+Model::Model(std::string& filename) : filename(filename), vertices(0), indices(0)
+{
+}
+
+bool Model::open(StringSet& failedPaths)
+{
+    MPQFile f(filename.c_str());
+
+    ok = !f.isEof();
+
+    if (!ok)
+    {
+        f.close();
+        failedPaths.insert(filename);
+        return false;
+    }
+
+    _unload();
+
+    memcpy(&header, f.getBuffer(), sizeof(ModelHeader));
+    if (header.nBoundingTriangles > 0)
+    {
+        f.seek(0);
+        f.seekRelative(header.ofsBoundingVertices);
+        vertices = new Vec3D[header.nBoundingVertices];
+        f.read(vertices, header.nBoundingVertices * 12);
+        for (uint32 i = 0; i < header.nBoundingVertices; i++)
+        {
+            vertices[i] = fixCoordSystem(vertices[i]);
+        }
+        f.seek(0);
+        f.seekRelative(header.ofsBoundingTriangles);
+        indices = new uint16[header.nBoundingTriangles];
+        f.read(indices, header.nBoundingTriangles * 2);
+        f.close();
+    }
+    else
+    {
+        //printf("not included %s\n", filename.c_str());
+        f.close();
+        return false;
+    }
+    return true;
+}
+
+bool Model::ConvertToVMAPModel(const char* outfilename)
+{
+    int N[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    FILE* output = fopen(outfilename, "wb");
+    if (!output)
+    {
+        printf("Can't create the output file '%s'\n", outfilename);
+        return false;
+    }
+    fwrite(szRawVMAPMagic, 8, 1, output);
+    uint32 nVertices = 0;
+    nVertices = header.nBoundingVertices;
+    fwrite(&nVertices, sizeof(int), 1, output);
+    uint32 nofgroups = 1;
+    fwrite(&nofgroups, sizeof(uint32), 1, output);
+    fwrite(N, 4 * 3, 1, output); // rootwmoid, flags, groupid
+    fwrite(N, sizeof(float), 3 * 2, output); //bbox, only needed for WMO currently
+    fwrite(N, 4, 1, output); // liquidflags
+    fwrite("GRP ", 4, 1, output);
+    uint32 branches = 1;
+    int wsize;
+    wsize = sizeof(branches) + sizeof(uint32) * branches;
+    fwrite(&wsize, sizeof(int), 1, output);
+    fwrite(&branches, sizeof(branches), 1, output);
+    uint32 nIndexes = 0;
+    nIndexes = header.nBoundingTriangles;
+    fwrite(&nIndexes, sizeof(uint32), 1, output);
+    fwrite("INDX", 4, 1, output);
+    wsize = sizeof(uint32) + sizeof(unsigned short) * nIndexes;
+    fwrite(&wsize, sizeof(int), 1, output);
+    fwrite(&nIndexes, sizeof(uint32), 1, output);
+    if (nIndexes > 0)
+    {
+        fwrite(indices, sizeof(unsigned short), nIndexes, output);
+    }
+    fwrite("VERT", 4, 1, output);
+    wsize = sizeof(int) + sizeof(float) * 3 * nVertices;
+    fwrite(&wsize, sizeof(int), 1, output);
+    fwrite(&nVertices, sizeof(int), 1, output);
+    if (nVertices > 0)
+    {
+        for (uint32 vpos = 0; vpos < nVertices; ++vpos)
+        {
+            std::swap(vertices[vpos].y, vertices[vpos].z);
+        }
+        fwrite(vertices, sizeof(float) * 3, nVertices, output);
+    }
+
+    fclose(output);
+
+    return true;
+}
+
+
+Vec3D fixCoordSystem(Vec3D v)
+{
+    return Vec3D(v.x, v.z, -v.y);
+}
+
+Vec3D fixCoordSystem2(Vec3D v)
+{
+    return Vec3D(v.x, v.z, v.y);
+}
+
+ModelInstance::ModelInstance(MPQFile& f, const char* ModelInstName, uint32 mapID, uint32 tileX, uint32 tileY, FILE* pDirfile)
+{
+    float ff[3];
+    f.read(&id, 4);
+    f.read(ff, 12);
+    pos = fixCoords(Vec3D(ff[0], ff[1], ff[2]));
+    f.read(ff, 12);
+    rot = Vec3D(ff[0], ff[1], ff[2]);
+    f.read(&scale, 4);
+    // scale factor - divide by 1024. blizzard devs must be on crack, why not just use a float?
+    sc = scale / 1024.0f;
+
+    char tempname[512];
+    sprintf(tempname, "%s/%s", szWorkDirWmo, ModelInstName);
+    FILE* input;
+    input = fopen(tempname, "r+b");
+
+    if (!input)
+    {
+        //printf("ModelInstance::ModelInstance couldn't open %s\n", tempname);
+        return;
+    }
+
+    fseek(input, 8, SEEK_SET); // get the correct no of vertices
+    int nVertices;
+    fread(&nVertices, sizeof(int), 1, input);
+    fclose(input);
+
+    if (nVertices == 0)
+        return;
+
+    uint16 adtId = 0;// not used for models
+    uint32 flags = MOD_M2;
+    if (tileX == 65 && tileY == 65) flags |= MOD_WORLDSPAWN;
+    //write mapID, tileX, tileY, Flags, ID, Pos, Rot, Scale, name
+    fwrite(&mapID, sizeof(uint32), 1, pDirfile);
+    fwrite(&tileX, sizeof(uint32), 1, pDirfile);
+    fwrite(&tileY, sizeof(uint32), 1, pDirfile);
+    fwrite(&flags, sizeof(uint32), 1, pDirfile);
+    fwrite(&adtId, sizeof(uint16), 1, pDirfile);
+    fwrite(&id, sizeof(uint32), 1, pDirfile);
+    fwrite(&pos, sizeof(float), 3, pDirfile);
+    fwrite(&rot, sizeof(float), 3, pDirfile);
+    fwrite(&sc, sizeof(float), 1, pDirfile);
+    uint32 nlen = strlen(ModelInstName);
+    fwrite(&nlen, sizeof(uint32), 1, pDirfile);
+    fwrite(ModelInstName, sizeof(char), nlen, pDirfile);
+
+    /* int realx1 = (int) ((float) pos.x / 533.333333f);
+    int realy1 = (int) ((float) pos.z / 533.333333f);
+    int realx2 = (int) ((float) pos.x / 533.333333f);
+    int realy2 = (int) ((float) pos.z / 533.333333f);
+
+    fprintf(pDirfile,"%s/%s %f,%f,%f_%f,%f,%f %f %d %d %d,%d %d\n",
+        MapName,
+        ModelInstName,
+        (float) pos.x, (float) pos.y, (float) pos.z,
+        (float) rot.x, (float) rot.y, (float) rot.z,
+        sc,
+        nVertices,
+        realx1, realy1,
+        realx2, realy2
+        ); */
+}
diff -Nuar clean-build/maptools/vmap_extractor/model.h temp-build/maptools/vmap_extractor/model.h
--- clean-build/maptools/vmap_extractor/model.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/model.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,59 @@
+#ifndef MODEL_H
+#define MODEL_H
+
+#include "loadlib.h"
+#include "vec3d.h"
+//#include "mpq.h"
+#include "modelheaders.h"
+#include <vector>
+#include "vmapexport.h"
+
+class WMOInstance;
+class MPQFile;
+
+Vec3D fixCoordSystem(Vec3D v);
+
+class Model
+{
+    public:
+        ModelHeader header;
+        uint32 offsBB_vertices, offsBB_indices;
+        Vec3D* BB_vertices, *vertices;
+        uint16* BB_indices, *indices;
+        size_t nIndices;
+
+        bool open(StringSet& failedPaths);
+        bool ConvertToVMAPModel(const char* outfilename);
+
+        bool ok;
+
+        Model(std::string& filename);
+        ~Model() {_unload();}
+
+    private:
+        void _unload()
+        {
+            delete[] vertices;
+            delete[] indices;
+            vertices = NULL;
+            indices = NULL;
+        }
+        std::string filename;
+        char outfilename;
+};
+
+class ModelInstance
+{
+    public:
+        Model* model;
+
+        uint32 id;
+        Vec3D pos, rot;
+        unsigned int d1, scale;
+        float w, sc;
+
+        ModelInstance() {}
+        ModelInstance(MPQFile& f, const char* ModelInstName, uint32 mapID, uint32 tileX, uint32 tileY, FILE* pDirfile);
+};
+
+#endif
diff -Nuar clean-build/maptools/vmap_extractor/modelheaders.h temp-build/maptools/vmap_extractor/modelheaders.h
--- clean-build/maptools/vmap_extractor/modelheaders.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/modelheaders.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,81 @@
+#ifndef MODELHEADERS_H
+#define MODELHEADERS_H
+
+/* typedef unsigned char uint8;
+typedef char int8;
+typedef unsigned short uint16;
+typedef short int16;
+typedef unsigned int uint32;
+typedef int int32; */
+
+#pragma pack(push,1)
+
+struct ModelHeader
+{
+    char id[4];
+    uint8 version[4];
+    uint32 nameLength;
+    uint32 nameOfs;
+    uint32 type;
+    uint32 nGlobalSequences;
+    uint32 ofsGlobalSequences;
+    uint32 nAnimations;
+    uint32 ofsAnimations;
+    uint32 nAnimationLookup;
+    uint32 ofsAnimationLookup;
+    uint32 nBones;
+    uint32 ofsBones;
+    uint32 nKeyBoneLookup;
+    uint32 ofsKeyBoneLookup;
+    uint32 nVertices;
+    uint32 ofsVertices;
+    uint32 nViews;
+    uint32 nColors;
+    uint32 ofsColors;
+    uint32 nTextures;
+    uint32 ofsTextures;
+    uint32 nTransparency;
+    uint32 ofsTransparency;
+    uint32 nTextureanimations;
+    uint32 ofsTextureanimations;
+    uint32 nTexReplace;
+    uint32 ofsTexReplace;
+    uint32 nRenderFlags;
+    uint32 ofsRenderFlags;
+    uint32 nBoneLookupTable;
+    uint32 ofsBoneLookupTable;
+    uint32 nTexLookup;
+    uint32 ofsTexLookup;
+    uint32 nTexUnits;
+    uint32 ofsTexUnits;
+    uint32 nTransLookup;
+    uint32 ofsTransLookup;
+    uint32 nTexAnimLookup;
+    uint32 ofsTexAnimLookup;
+    float floats[14];
+    uint32 nBoundingTriangles;
+    uint32 ofsBoundingTriangles;
+    uint32 nBoundingVertices;
+    uint32 ofsBoundingVertices;
+    uint32 nBoundingNormals;
+    uint32 ofsBoundingNormals;
+    uint32 nAttachments;
+    uint32 ofsAttachments;
+    uint32 nAttachLookup;
+    uint32 ofsAttachLookup;
+    uint32 nAttachments_2;
+    uint32 ofsAttachments_2;
+    uint32 nLights;
+    uint32 ofsLights;
+    uint32 nCameras;
+    uint32 ofsCameras;
+    uint32 nCameraLookup;
+    uint32 ofsCameraLookup;
+    uint32 nRibbonEmitters;
+    uint32 ofsRibbonEmitters;
+    uint32 nParticleEmitters;
+    uint32 ofsParticleEmitters;
+};
+
+#pragma pack(pop)
+#endif
diff -Nuar clean-build/maptools/vmap_extractor/mpq_libmpq04.h temp-build/maptools/vmap_extractor/mpq_libmpq04.h
--- clean-build/maptools/vmap_extractor/mpq_libmpq04.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/mpq_libmpq04.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,93 @@
+#define _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_WARNINGS
+
+#ifndef MPQ_H
+#define MPQ_H
+
+#include "loadlib.h"
+#include "libmpq04/mpq.h"
+#include <string.h>
+#include <ctype.h>
+#include <vector>
+#include <iostream>
+#include <deque>
+
+using namespace std;
+
+class MPQArchive
+{
+
+    public:
+        mpq_archive_s* mpq_a;
+
+        MPQArchive(const char* filename);
+        void close();
+
+        void GetFileListTo(vector<string>& filelist)
+        {
+            uint32 filenum;
+            if (libmpq__file_number(mpq_a, "(listfile)", &filenum)) return;
+            libmpq__off_t size, transferred;
+            libmpq__file_unpacked_size(mpq_a, filenum, &size);
+
+            char* buffer = new char[size];
+
+            libmpq__file_read(mpq_a, filenum, (unsigned char*)buffer, size, &transferred);
+
+            char seps[] = "\n";
+            char* token;
+
+            token = strtok(buffer, seps);
+            uint32 counter = 0;
+            while ((token != NULL) && (counter < size))
+            {
+                //cout << token << endl;
+                token[strlen(token) - 1] = 0;
+                string s = token;
+                filelist.push_back(s);
+                counter += strlen(token) + 2;
+                token = strtok(NULL, seps);
+            }
+
+            delete[] buffer;
+        }
+};
+typedef std::deque<MPQArchive*> ArchiveSet;
+
+class MPQFile
+{
+        //MPQHANDLE handle;
+        bool eof;
+        char* buffer;
+        libmpq__off_t pointer, size;
+
+        // disable copying
+        MPQFile(const MPQFile& f) {}
+        void operator=(const MPQFile& f) {}
+
+    public:
+        MPQFile(const char* filename);    // filenames are not case sensitive
+        ~MPQFile() { close(); }
+        size_t read(void* dest, size_t bytes);
+        size_t getSize() { return size; }
+        size_t getPos() { return pointer; }
+        char* getBuffer() { return buffer; }
+        char* getPointer() { return buffer + pointer; }
+        bool isEof() { return eof; }
+        void seek(int offset);
+        void seekRelative(int offset);
+        void close();
+};
+
+inline void flipcc(char* fcc)
+{
+    char t;
+    t = fcc[0];
+    fcc[0] = fcc[3];
+    fcc[3] = t;
+    t = fcc[1];
+    fcc[1] = fcc[2];
+    fcc[2] = t;
+}
+
+#endif
diff -Nuar clean-build/maptools/vmap_extractor/mpq_libmpq.cpp temp-build/maptools/vmap_extractor/mpq_libmpq.cpp
--- clean-build/maptools/vmap_extractor/mpq_libmpq.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/mpq_libmpq.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,114 @@
+#include "mpq_libmpq04.h"
+#include <deque>
+#include <cstdio>
+
+ArchiveSet gOpenArchives;
+
+MPQArchive::MPQArchive(const char* filename)
+{
+    int result = libmpq__archive_open(&mpq_a, filename, -1);
+    printf("Opening %s\n", filename);
+    if (result)
+    {
+        switch (result)
+        {
+            case LIBMPQ_ERROR_OPEN :
+                printf("Error opening archive '%s': Does file really exist?\n", filename);
+                break;
+            case LIBMPQ_ERROR_FORMAT :            /* bad file format */
+                printf("Error opening archive '%s': Bad file format\n", filename);
+                break;
+            case LIBMPQ_ERROR_SEEK :         /* seeking in file failed */
+                printf("Error opening archive '%s': Seeking in file failed\n", filename);
+                break;
+            case LIBMPQ_ERROR_READ :              /* Read error in archive */
+                printf("Error opening archive '%s': Read error in archive\n", filename);
+                break;
+            case LIBMPQ_ERROR_MALLOC :               /* maybe not enough memory? :) */
+                printf("Error opening archive '%s': Maybe not enough memory\n", filename);
+                break;
+            default:
+                printf("Error opening archive '%s': Unknown error\n", filename);
+                break;
+        }
+        return;
+    }
+    gOpenArchives.push_front(this);
+}
+
+void MPQArchive::close()
+{
+    //gOpenArchives.erase(erase(&mpq_a);
+    libmpq__archive_close(mpq_a);
+}
+
+MPQFile::MPQFile(const char* filename):
+    eof(false),
+    buffer(0),
+    pointer(0),
+    size(0)
+{
+    for (ArchiveSet::iterator i = gOpenArchives.begin(); i != gOpenArchives.end(); ++i)
+    {
+        mpq_archive* mpq_a = (*i)->mpq_a;
+
+        uint32 filenum;
+        if (libmpq__file_number(mpq_a, filename, &filenum)) continue;
+        libmpq__off_t transferred;
+        libmpq__file_unpacked_size(mpq_a, filenum, &size);
+
+        // HACK: in patch.mpq some files don't want to open and give 1 for filesize
+        if (size <= 1)
+        {
+            // printf("info: file %s has size %d; considered dummy file.\n", filename, size);
+            eof = true;
+            buffer = 0;
+            return;
+        }
+        buffer = new char[size];
+
+        //libmpq_file_getdata
+        libmpq__file_read(mpq_a, filenum, (unsigned char*)buffer, size, &transferred);
+        /*libmpq_file_getdata(&mpq_a, hash, fileno, (unsigned char*)buffer);*/
+        return;
+    }
+    eof = true;
+    buffer = 0;
+}
+
+size_t MPQFile::read(void* dest, size_t bytes)
+{
+    if (eof) return 0;
+
+    size_t rpos = pointer + bytes;
+    if (rpos > size)
+    {
+        bytes = size - pointer;
+        eof = true;
+    }
+
+    memcpy(dest, &(buffer[pointer]), bytes);
+
+    pointer = rpos;
+
+    return bytes;
+}
+
+void MPQFile::seek(int offset)
+{
+    pointer = offset;
+    eof = (pointer >= size);
+}
+
+void MPQFile::seekRelative(int offset)
+{
+    pointer += offset;
+    eof = (pointer >= size);
+}
+
+void MPQFile::close()
+{
+    if (buffer) delete[] buffer;
+    buffer = 0;
+    eof = true;
+}
diff -Nuar clean-build/maptools/vmap_extractor/README temp-build/maptools/vmap_extractor/README
--- clean-build/maptools/vmap_extractor/README	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/README	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,42 @@
+Linux:
+
+1. Building
+
+	Because vmap_extractor depends on libmpq for reading mpq files, you will have
+	to build libmpq prior to vmap_extractor. Therefore cd to dep/libmpq and execute:
+
+	$ ./autogen.sh
+	$ ./configure
+	$ make
+
+	After that, cd to contrib/vmap_extractor/ and execute:
+
+	$ cmake .
+	$ make
+
+	You should now have an executable file at vmapextract/vmapextractor
+
+2. Extracting
+
+	Use the created executable to extract model information. Change the data path if
+	needed.
+
+	$ vmapextract/vmapextractor -d /mnt/windows/games/wow/Data/
+
+	Resulting files will be in ./Buildings
+
+###########################
+Windows:
+
+1. Building
+
+	Just build the solution in contrib\vmap_extractor\win
+	Resulting binaries will be in contrib\vmap_extractor\bin\$(PlatformName)_$(ConfigurationName)
+
+2. Extracting
+
+	Use the created executable (from command prompt) to extract model information.
+	It should find the data path for your client installation through the windows registry,
+	but the data path can be specified with the -d option.
+
+	Resulting files will be in .\Buildings
diff -Nuar clean-build/maptools/vmap_extractor/vec3d.h temp-build/maptools/vmap_extractor/vec3d.h
--- clean-build/maptools/vmap_extractor/vec3d.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/vec3d.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,232 @@
+#ifndef VEC3D_H
+#define VEC3D_H
+
+#include <iostream>
+#include <cmath>
+
+class Vec3D
+{
+    public:
+        float x, y, z;
+
+        Vec3D(float x0 = 0.0f, float y0 = 0.0f, float z0 = 0.0f) : x(x0), y(y0), z(z0) {}
+
+        Vec3D(const Vec3D& v) : x(v.x), y(v.y), z(v.z) {}
+
+        Vec3D& operator= (const Vec3D& v)
+        {
+            x = v.x;
+            y = v.y;
+            z = v.z;
+            return *this;
+        }
+
+        Vec3D operator+ (const Vec3D& v) const
+        {
+            Vec3D r(x + v.x, y + v.y, z + v.z);
+            return r;
+        }
+
+        Vec3D operator- (const Vec3D& v) const
+        {
+            Vec3D r(x - v.x, y - v.y, z - v.z);
+            return r;
+        }
+
+        float operator* (const Vec3D& v) const
+        {
+            return x * v.x + y * v.y + z * v.z;
+        }
+
+        Vec3D operator* (float d) const
+        {
+            Vec3D r(x * d, y * d, z * d);
+            return r;
+        }
+
+        friend Vec3D operator* (float d, const Vec3D& v)
+        {
+            return v * d;
+        }
+
+        Vec3D operator% (const Vec3D& v) const
+        {
+            Vec3D r(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);
+            return r;
+        }
+
+        Vec3D& operator+= (const Vec3D& v)
+        {
+            x += v.x;
+            y += v.y;
+            z += v.z;
+            return *this;
+        }
+
+        Vec3D& operator-= (const Vec3D& v)
+        {
+            x -= v.x;
+            y -= v.y;
+            z -= v.z;
+            return *this;
+        }
+
+        Vec3D& operator*= (float d)
+        {
+            x *= d;
+            y *= d;
+            z *= d;
+            return *this;
+        }
+
+        float lengthSquared() const
+        {
+            return x * x + y * y + z * z;
+        }
+
+        float length() const
+        {
+            return sqrt(x * x + y * y + z * z);
+        }
+
+        Vec3D& normalize()
+        {
+            this->operator*= (1.0f / length());
+            return *this;
+        }
+
+        Vec3D operator~() const
+        {
+            Vec3D r(*this);
+            r.normalize();
+            return r;
+        }
+
+        friend std::istream& operator>>(std::istream& in, Vec3D& v)
+        {
+            in >> v.x >> v.y >> v.z;
+            return in;
+        }
+
+        friend std::ostream& operator<<(std::ostream& out, const Vec3D& v)
+        {
+            out << v.x << " " << v.y << " " << v.z;
+            return out;
+        }
+
+        operator float* ()
+        {
+            return (float*)this;
+        }
+};
+
+
+class Vec2D
+{
+    public:
+        float x, y;
+
+        Vec2D(float x0 = 0.0f, float y0 = 0.0f) : x(x0), y(y0) {}
+
+        Vec2D(const Vec2D& v) : x(v.x), y(v.y) {}
+
+        Vec2D& operator= (const Vec2D& v)
+        {
+            x = v.x;
+            y = v.y;
+            return *this;
+        }
+
+        Vec2D operator+ (const Vec2D& v) const
+        {
+            Vec2D r(x + v.x, y + v.y);
+            return r;
+        }
+
+        Vec2D operator- (const Vec2D& v) const
+        {
+            Vec2D r(x - v.x, y - v.y);
+            return r;
+        }
+
+        float operator* (const Vec2D& v) const
+        {
+            return x * v.x + y * v.y;
+        }
+
+        Vec2D operator* (float d) const
+        {
+            Vec2D r(x * d, y * d);
+            return r;
+        }
+
+        friend Vec2D operator* (float d, const Vec2D& v)
+        {
+            return v * d;
+        }
+
+        Vec2D& operator+= (const Vec2D& v)
+        {
+            x += v.x;
+            y += v.y;
+            return *this;
+        }
+
+        Vec2D& operator-= (const Vec2D& v)
+        {
+            x -= v.x;
+            y -= v.y;
+            return *this;
+        }
+
+        Vec2D& operator*= (float d)
+        {
+            x *= d;
+            y *= d;
+            return *this;
+        }
+
+        float lengthSquared() const
+        {
+            return x * x + y * y;
+        }
+
+        float length() const
+        {
+            return sqrt(x * x + y * y);
+        }
+
+        Vec2D& normalize()
+        {
+            this->operator*= (1.0f / length());
+            return *this;
+        }
+
+        Vec2D operator~() const
+        {
+            Vec2D r(*this);
+            r.normalize();
+            return r;
+        }
+
+
+        friend std::istream& operator>>(std::istream& in, Vec2D& v)
+        {
+            in >> v.x >> v.y;
+            return in;
+        }
+
+        operator float* ()
+        {
+            return (float*)this;
+        }
+};
+
+inline void rotate(float x0, float y0, float* x, float* y, float angle)
+{
+    float xa = *x - x0, ya = *y - y0;
+    *x = xa * cosf(angle) - ya * sinf(angle) + x0;
+    *y = xa * sinf(angle) + ya * cosf(angle) + y0;
+}
+
+#endif
diff -Nuar clean-build/maptools/vmap_extractor/vmapexport.cpp temp-build/maptools/vmap_extractor/vmapexport.cpp
--- clean-build/maptools/vmap_extractor/vmapexport.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/vmapexport.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,518 @@
+#define _CRT_SECURE_NO_DEPRECATE
+#include <cstdio>
+#include <iostream>
+#include <vector>
+#include <list>
+#include <errno.h>
+#include <sys/stat.h>
+
+#undef min
+#undef max
+
+//#pragma warning(disable : 4505)
+//#pragma comment(lib, "Winmm.lib")
+
+#include <map>
+
+//From Extractor
+#include "adtfile.h"
+#include "wdtfile.h"
+#include "dbcfile.h"
+#include "wmo.h"
+#include "mpq_libmpq04.h"
+
+#include "vmapexport.h"
+
+//------------------------------------------------------------------------------
+// Defines
+
+#define MPQ_BLOCK_SIZE 0x1000
+
+//-----------------------------------------------------------------------------
+
+extern ArchiveSet gOpenArchives;
+
+typedef struct
+{
+    char name[64];
+    unsigned int id;
+} map_id;
+
+map_id* map_ids;
+uint16* LiqType = 0;
+uint32 map_count;
+char output_path[128] = ".";
+char input_path[1024] = ".";
+bool hasInputPathParam = false;
+bool preciseVectorData = false;
+
+// Constants
+
+//static const char * szWorkDirMaps = ".\\Maps";
+const char* szWorkDirWmo = "./Buildings";
+const char* szRawVMAPMagic = "VMAP004";
+
+// Local testing functions
+
+bool FileExists(const char* file)
+{
+    if (FILE* n = fopen(file, "rb"))
+    {
+        fclose(n);
+        return true;
+    }
+    return false;
+}
+
+void strToLower(char* str)
+{
+    while (*str)
+    {
+        *str = tolower(*str);
+        ++str;
+    }
+}
+
+// copied from contrib/extractor/System.cpp
+void ReadLiquidTypeTableDBC()
+{
+    printf("Read LiquidType.dbc file...");
+    DBCFile dbc("DBFilesClient\\LiquidType.dbc");
+    if (!dbc.open())
+    {
+        printf("Fatal error: Invalid LiquidType.dbc file format!\n");
+        exit(1);
+    }
+
+    size_t LiqType_count = dbc.getRecordCount();
+    size_t LiqType_maxid = dbc.getRecord(LiqType_count - 1).getUInt(0);
+    LiqType = new uint16[LiqType_maxid + 1];
+    memset(LiqType, 0xff, (LiqType_maxid + 1) * sizeof(uint16));
+
+    for (uint32 x = 0; x < LiqType_count; ++x)
+        LiqType[dbc.getRecord(x).getUInt(0)] = dbc.getRecord(x).getUInt(3);
+
+    printf("Done! (%u LiqTypes loaded)\n", (unsigned int)LiqType_count);
+}
+
+bool ExtractWmo()
+{
+    bool success = true;
+
+    //const char* ParsArchiveNames[] = {"patch-2.MPQ", "patch.MPQ", "common.MPQ", "expansion.MPQ"};
+
+    for (ArchiveSet::const_iterator ar_itr = gOpenArchives.begin(); ar_itr != gOpenArchives.end() && success; ++ar_itr)
+    {
+        vector<string> filelist;
+
+        (*ar_itr)->GetFileListTo(filelist);
+        for (vector<string>::iterator fname = filelist.begin(); fname != filelist.end() && success; ++fname)
+        {
+            if (fname->find(".wmo") != string::npos)
+                success = ExtractSingleWmo(*fname);
+        }
+    }
+
+    if (success)
+        printf("\nExtract wmo complete (No (fatal) errors)\n");
+
+    return success;
+}
+
+bool ExtractSingleWmo(std::string& fname)
+{
+    // Copy files from archive
+
+    char szLocalFile[1024];
+    const char* plain_name = GetPlainName(fname.c_str());
+    sprintf(szLocalFile, "%s/%s", szWorkDirWmo, plain_name);
+    fixnamen(szLocalFile, strlen(szLocalFile));
+
+    if (FileExists(szLocalFile))
+        return true;
+
+    int p = 0;
+    //Select root wmo files
+    const char* rchr = strrchr(plain_name, '_');
+    if (rchr != NULL)
+    {
+        char cpy[4];
+        strncpy((char*)cpy, rchr, 4);
+        for (int i = 0; i < 4; ++i)
+        {
+            int m = cpy[i];
+            if (isdigit(m))
+                p++;
+        }
+    }
+
+    if (p == 3)
+        return true;
+
+    bool file_ok = true;
+    std::cout << "Extracting " << fname << std::endl;
+    WMORoot froot(fname);
+    if (!froot.open())
+    {
+        printf("Couldn't open RootWmo!!!\n");
+        return true;
+    }
+    FILE* output = fopen(szLocalFile, "wb");
+    if (!output)
+    {
+        printf("couldn't open %s for writing!\n", szLocalFile);
+        return false;
+    }
+    froot.ConvertToVMAPRootWmo(output);
+    int Wmo_nVertices = 0;
+    //printf("root has %d groups\n", froot->nGroups);
+    if (froot.nGroups != 0)
+    {
+        for (uint32 i = 0; i < froot.nGroups; ++i)
+        {
+            char temp[1024];
+            strcpy(temp, fname.c_str());
+            temp[fname.length() - 4] = 0;
+            char groupFileName[1024];
+            sprintf(groupFileName, "%s_%03d.wmo", temp, i);
+            //printf("Trying to open groupfile %s\n",groupFileName);
+
+            string s = groupFileName;
+            WMOGroup fgroup(s);
+            if (!fgroup.open())
+            {
+                printf("Could not open all Group file for: %s\n", plain_name);
+                file_ok = false;
+                break;
+            }
+
+            Wmo_nVertices += fgroup.ConvertToVMAPGroupWmo(output, &froot, preciseVectorData);
+        }
+    }
+
+    fseek(output, 8, SEEK_SET); // store the correct no of vertices
+    fwrite(&Wmo_nVertices, sizeof(int), 1, output);
+    fclose(output);
+
+    // Delete the extracted file in the case of an error
+    if (!file_ok)
+        remove(szLocalFile);
+    return true;
+}
+
+void ParsMapFiles()
+{
+    char fn[512];
+    //char id_filename[64];
+    char id[10];
+    StringSet failedPaths;
+    for (unsigned int i = 0; i < map_count; ++i)
+    {
+        sprintf(id, "%03u", map_ids[i].id);
+        sprintf(fn, "World\\Maps\\%s\\%s.wdt", map_ids[i].name, map_ids[i].name);
+        WDTFile WDT(fn, map_ids[i].name);
+        if (WDT.init(id, map_ids[i].id))
+        {
+            printf("Processing Map %u\n[", map_ids[i].id);
+            for (int x = 0; x < 64; ++x)
+            {
+                for (int y = 0; y < 64; ++y)
+                {
+                    if (ADTFile* ADT = WDT.GetMap(x, y))
+                    {
+                        //sprintf(id_filename,"%02u %02u %03u",x,y,map_ids[i].id);//!!!!!!!!!
+                        ADT->init(map_ids[i].id, x, y, failedPaths);
+                        delete ADT;
+                    }
+                }
+                printf("#");
+                fflush(stdout);
+            }
+            printf("]\n");
+        }
+    }
+
+    if (!failedPaths.empty())
+    {
+        printf("Warning: Some models could not be extracted, see below\n");
+        for (StringSet::const_iterator itr = failedPaths.begin(); itr != failedPaths.end(); ++itr)
+            printf("Could not find file of model %s\n", itr->c_str());
+        printf("A few not found models can be expected and are not alarming.\n");
+    }
+}
+
+void getGamePath()
+{
+    strcpy(input_path, "Data/");
+}
+
+bool scan_patches(char* scanmatch, std::vector<std::string>& pArchiveNames)
+{
+    int i;
+    char path[512];
+
+    for (i = 1; i <= 99; i++)
+    {
+        if (i != 1)
+        {
+            sprintf(path, "%s-%d.MPQ", scanmatch, i);
+        }
+        else
+        {
+            sprintf(path, "%s.MPQ", scanmatch);
+        }
+#ifdef __linux__
+        if (FILE* h = fopen64(path, "rb"))
+#else
+        if (FILE* h = fopen(path, "rb"))
+#endif
+        {
+            fclose(h);
+            //matches.push_back(path);
+            pArchiveNames.push_back(path);
+        }
+    }
+
+    return(true);
+}
+
+bool fillArchiveNameVector(std::vector<std::string>& pArchiveNames)
+{
+    if (!hasInputPathParam)
+        getGamePath();
+
+    printf("\nGame path: %s\n", input_path);
+
+    char path[512];
+    string in_path(input_path);
+    std::vector<std::string> locales, searchLocales;
+
+    searchLocales.push_back("enGB");
+    searchLocales.push_back("enUS");
+    searchLocales.push_back("deDE");
+    searchLocales.push_back("esES");
+    searchLocales.push_back("frFR");
+    searchLocales.push_back("koKR");
+    searchLocales.push_back("zhCN");
+    searchLocales.push_back("zhTW");
+    searchLocales.push_back("enCN");
+    searchLocales.push_back("enTW");
+    searchLocales.push_back("esMX");
+    searchLocales.push_back("ruRU");
+
+    for (std::vector<std::string>::iterator i = searchLocales.begin(); i != searchLocales.end(); ++i)
+    {
+        std::string localePath = in_path + *i;
+        // check if locale exists:
+        struct stat status;
+        if (stat(localePath.c_str(), &status))
+            continue;
+        if ((status.st_mode & S_IFDIR) == 0)
+            continue;
+        printf("Found locale '%s'\n", i->c_str());
+        locales.push_back(*i);
+    }
+    printf("\n");
+
+    // open locale expansion and common files
+    printf("Adding data files from locale directories.\n");
+    for (std::vector<std::string>::iterator i = locales.begin(); i != locales.end(); ++i)
+    {
+        pArchiveNames.push_back(in_path + *i + "/locale-" + *i + ".MPQ");
+        pArchiveNames.push_back(in_path + *i + "/expansion-locale-" + *i + ".MPQ");
+        pArchiveNames.push_back(in_path + *i + "/lichking-locale-" + *i + ".MPQ");
+    }
+
+    // open expansion and common files
+    pArchiveNames.push_back(input_path + string("common.MPQ"));
+    pArchiveNames.push_back(input_path + string("common-2.MPQ"));
+    pArchiveNames.push_back(input_path + string("expansion.MPQ"));
+    pArchiveNames.push_back(input_path + string("lichking.MPQ"));
+
+    // now, scan for the patch levels in the core dir
+    printf("Scanning patch levels from data directory.\n");
+    sprintf(path, "%spatch", input_path);
+    if (!scan_patches(path, pArchiveNames))
+        return(false);
+
+    // now, scan for the patch levels in locale dirs
+    printf("Scanning patch levels from locale directories.\n");
+    bool foundOne = false;
+    for (std::vector<std::string>::iterator i = locales.begin(); i != locales.end(); ++i)
+    {
+        printf("Locale: %s\n", i->c_str());
+        sprintf(path, "%s%s/patch-%s", input_path, i->c_str(), i->c_str());
+        if (scan_patches(path, pArchiveNames))
+            foundOne = true;
+    }
+
+    printf("\n");
+
+    if (!foundOne)
+    {
+        printf("no locale found\n");
+        return false;
+    }
+
+    return true;
+}
+
+bool processArgv(int argc, char** argv)
+{
+    bool result = true;
+    hasInputPathParam = false;
+    bool preciseVectorData = false;
+
+    for (int i = 1; i < argc; ++i)
+    {
+        if (strcmp("-s", argv[i]) == 0)
+        {
+            preciseVectorData = false;
+        }
+        else if (strcmp("-d", argv[i]) == 0)
+        {
+            if ((i + 1) < argc)
+            {
+                hasInputPathParam = true;
+                strcpy(input_path, argv[i + 1]);
+                if (input_path[strlen(input_path) - 1] != '\\' || input_path[strlen(input_path) - 1] != '/')
+                    strcat(input_path, "/");
+                ++i;
+            }
+            else
+            {
+                result = false;
+            }
+        }
+        else if (strcmp("-?", argv[1]) == 0)
+        {
+            result = false;
+        }
+        else if (strcmp("-l", argv[i]) == 0)
+        {
+            preciseVectorData = true;
+        }
+        else
+        {
+            result = false;
+            break;
+        }
+    }
+    if (!result)
+    {
+        printf("Extract for %s.\n", szRawVMAPMagic);
+        printf("%s [-?][-s][-l][-d <path>]\n", argv[0]);
+        printf("   -s : (default) small size (data size optimization), ~500MB less vmap data.\n");
+        printf("   -l : large size, ~500MB more vmap data. (might contain more details)\n");
+        printf("   -d <path>: Path to the vector data source folder.\n");
+        printf("   -? : This message.\n");
+    }
+    return result;
+}
+
+
+//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+// Main
+//
+// The program must be run with two command line arguments
+//
+// Arg1 - The source MPQ name (for testing reading and file find)
+// Arg2 - Listfile name
+//
+
+int main(int argc, char** argv)
+{
+    bool success = true;
+
+    // Use command line arguments, when some
+    if (!processArgv(argc, argv))
+        return 1;
+
+    // some simple check if working dir is dirty
+    else
+    {
+        std::string sdir = std::string(szWorkDirWmo) + "/dir";
+        std::string sdir_bin = std::string(szWorkDirWmo) + "/dir_bin";
+        struct stat status;
+        if (!stat(sdir.c_str(), &status) || !stat(sdir_bin.c_str(), &status))
+        {
+            printf("Your output directory seems to be polluted, please use an empty directory!\n");
+            printf("<press return to exit>");
+            char garbage[2];
+            scanf("%c", garbage);
+            return 1;
+        }
+    }
+
+    printf("Extract for %s. Beginning work ....\n", szRawVMAPMagic);
+    //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+    // Create the working directory
+    if (mkdir(szWorkDirWmo
+#ifdef __linux__
+              , 0711
+#endif
+             ))
+        success = (errno == EEXIST);
+
+    // prepare archive name list
+    std::vector<std::string> archiveNames;
+    fillArchiveNameVector(archiveNames);
+    for (size_t i = 0; i < archiveNames.size(); ++i)
+    {
+        MPQArchive* archive = new MPQArchive(archiveNames[i].c_str());
+        if (!gOpenArchives.size() || gOpenArchives.front() != archive)
+            delete archive;
+    }
+
+    if (gOpenArchives.empty())
+    {
+        printf("FATAL ERROR: None MPQ archive found by path '%s'. Use -d option with proper path.\n", input_path);
+        return 1;
+    }
+    ReadLiquidTypeTableDBC();
+
+    // extract data
+    if (success)
+        success = ExtractWmo();
+
+    //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+    //map.dbc
+    if (success)
+    {
+        DBCFile* dbc = new DBCFile("DBFilesClient\\Map.dbc");
+        if (!dbc->open())
+        {
+            delete dbc;
+            printf("FATAL ERROR: Map.dbc not found in data file.\n");
+            return 1;
+        }
+        map_count = dbc->getRecordCount();
+        map_ids = new map_id[map_count];
+        for (unsigned int x = 0; x < map_count; ++x)
+        {
+            map_ids[x].id = dbc->getRecord(x).getUInt(0);
+            strcpy(map_ids[x].name, dbc->getRecord(x).getString(1));
+            printf("Map - %s\n", map_ids[x].name);
+        }
+
+
+        delete dbc;
+        ParsMapFiles();
+        delete [] map_ids;
+        //nError = ERROR_SUCCESS;
+        // Extract models, listed in DameObjectDisplayInfo.dbc
+        ExtractGameobjectModels();
+    }
+
+    printf("\n");
+    if (!success)
+    {
+        printf("ERROR: Extract for %s. Work NOT complete.\n   Precise vector data=%d.\nPress any key.\n", szRawVMAPMagic, preciseVectorData);
+        getchar();
+    }
+
+    printf("Extract for %s. Work complete. No errors.\n", szRawVMAPMagic);
+    delete [] LiqType;
+    return 0;
+}
+
diff -Nuar clean-build/maptools/vmap_extractor/vmapexport.h temp-build/maptools/vmap_extractor/vmapexport.h
--- clean-build/maptools/vmap_extractor/vmapexport.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/vmapexport.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,32 @@
+#ifndef VMAPEXPORT_H
+#define VMAPEXPORT_H
+
+#include <string>
+#include <set>
+
+typedef std::set<std::string> StringSet;
+
+enum ModelFlags
+{
+    MOD_M2 = 1,
+    MOD_WORLDSPAWN = 1 << 1,
+    MOD_HAS_BOUND = 1 << 2
+};
+
+extern const char* szWorkDirWmo;
+extern const char* szRawVMAPMagic;                          // vmap magic string for extracted raw vmap data
+
+bool FileExists(const char* file);
+void strToLower(char* str);
+
+bool ExtractSingleWmo(std::string& fname);
+
+/* @param origPath = original path of the model, cleaned with fixnamen and fixname2
+ * @param fixedName = will store the translated name (if changed)
+ * @param failedPaths = Set to collect errors
+ */
+bool ExtractSingleModel(std::string& origPath, std::string& fixedName, StringSet& failedPaths);
+
+void ExtractGameobjectModels();
+
+#endif
diff -Nuar clean-build/maptools/vmap_extractor/wdtfile.cpp temp-build/maptools/vmap_extractor/wdtfile.cpp
--- clean-build/maptools/vmap_extractor/wdtfile.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/wdtfile.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,116 @@
+#include "vmapexport.h"
+#include "wdtfile.h"
+#include "adtfile.h"
+#include <cstdio>
+
+char* wdtGetPlainName(char* FileName)
+{
+    char* szTemp;
+
+    if ((szTemp = strrchr(FileName, '\\')) != NULL)
+        FileName = szTemp + 1;
+    return FileName;
+}
+
+WDTFile::WDTFile(char* file_name, char* file_name1): WDT(file_name)
+{
+    filename.append(file_name1, strlen(file_name1));
+}
+
+bool WDTFile::init(char* map_id, unsigned int mapID)
+{
+    if (WDT.isEof())
+    {
+        //printf("Can't find WDT file.\n");
+        return false;
+    }
+
+    char fourcc[5];
+    uint32 size;
+
+    std::string dirname = std::string(szWorkDirWmo) + "/dir_bin";
+    FILE* dirfile;
+    dirfile = fopen(dirname.c_str(), "ab");
+    if (!dirfile)
+    {
+        printf("Can't open dirfile!'%s'\n", dirname.c_str());
+        return false;
+    }
+
+    while (!WDT.isEof())
+    {
+        WDT.read(fourcc, 4);
+        WDT.read(&size, 4);
+
+        flipcc(fourcc);
+        fourcc[4] = 0;
+
+        size_t nextpos = WDT.getPos() + size;
+
+        if (!strcmp(fourcc, "MAIN"))
+        {
+        }
+        if (!strcmp(fourcc, "MWMO"))
+        {
+            // global map objects
+            if (size)
+            {
+                char* buf = new char[size];
+                WDT.read(buf, size);
+                char* p = buf;
+                int q = 0;
+                gWmoInstansName = new string[size];
+                while (p < buf + size)
+                {
+                    string path(p);
+                    char* s = wdtGetPlainName(p);
+                    fixnamen(s, strlen(s));
+                    p = p + strlen(p) + 1;
+                    gWmoInstansName[q++] = s;
+                }
+                delete[] buf;
+            }
+        }
+        else if (!strcmp(fourcc, "MODF"))
+        {
+            // global wmo instance data
+            if (size)
+            {
+                gnWMO = (int)size / 64;
+                string gWMO_mapname;
+                string fake_mapname;
+                fake_mapname = "65 65 ";
+                //gWMO_mapname = fake_mapname + filename;
+                gWMO_mapname = fake_mapname + std::string(map_id);
+                for (int i = 0; i < gnWMO; ++i)
+                {
+                    int id;
+                    WDT.read(&id, 4);
+                    WMOInstance inst(WDT, gWmoInstansName[id].c_str(), mapID, 65, 65, dirfile);
+                }
+                delete[] gWmoInstansName;
+            }
+        }
+        WDT.seek((int)nextpos);
+    }
+
+    WDT.close();
+    fclose(dirfile);
+    return true;
+}
+
+WDTFile::~WDTFile(void)
+{
+    WDT.close();
+}
+
+ADTFile* WDTFile::GetMap(int x, int z)
+{
+    if (!(x >= 0 && z >= 0 && x < 64 && z < 64))
+        return NULL;
+
+    char name[512];
+
+    sprintf(name, "World\\Maps\\%s\\%s_%d_%d.adt", filename.c_str(), filename.c_str(), x, z);
+    return new ADTFile(name);
+}
diff -Nuar clean-build/maptools/vmap_extractor/wdtfile.h temp-build/maptools/vmap_extractor/wdtfile.h
--- clean-build/maptools/vmap_extractor/wdtfile.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/wdtfile.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,30 @@
+#ifndef WDTFILE_H
+#define WDTFILE_H
+
+#include "mpq_libmpq04.h"
+#include "wmo.h"
+#include <string>
+#include "stdlib.h"
+
+class ADTFile;
+
+class WDTFile
+{
+    public:
+        WDTFile(char* file_name, char* file_name1);
+        ~WDTFile(void);
+        bool init(char* map_id, unsigned int mapID);
+
+        string* gWmoInstansName;
+        int gnWMO, nMaps;
+
+        ADTFile* GetMap(int x, int z);
+
+    private:
+        MPQFile WDT;
+        bool maps[64][64];
+        string filename;
+};
+
+#endif
+
diff -Nuar clean-build/maptools/vmap_extractor/wmo.cpp temp-build/maptools/vmap_extractor/wmo.cpp
--- clean-build/maptools/vmap_extractor/wmo.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/wmo.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,547 @@
+#include "vmapexport.h"
+#include "wmo.h"
+#include "vec3d.h"
+#include <cstdio>
+#include <cstdlib>
+#include <cassert>
+#include <map>
+#include <fstream>
+#undef min
+#undef max
+#include "mpq_libmpq04.h"
+
+using namespace std;
+extern uint16* LiqType;
+
+WMORoot::WMORoot(std::string& filename) : filename(filename)
+{
+}
+
+bool WMORoot::open()
+{
+    MPQFile f(filename.c_str());
+    if (f.isEof())
+    {
+        printf("No such file %s.\n", filename.c_str());
+        return false;
+    }
+
+    uint32 size;
+    char fourcc[5];
+
+    while (!f.isEof())
+    {
+        f.read(fourcc, 4);
+        f.read(&size, 4);
+
+        flipcc(fourcc);
+        fourcc[4] = 0;
+
+        size_t nextpos = f.getPos() + size;
+
+        if (!strcmp(fourcc, "MOHD")) //header
+        {
+            f.read(&nTextures, 4);
+            f.read(&nGroups, 4);
+            f.read(&nP, 4);
+            f.read(&nLights, 4);
+            f.read(&nModels, 4);
+            f.read(&nDoodads, 4);
+            f.read(&nDoodadSets, 4);
+            f.read(&col, 4);
+            f.read(&RootWMOID, 4);
+            f.read(bbcorn1, 12);
+            f.read(bbcorn2, 12);
+            f.read(&liquidType, 4);
+            break;
+        }
+        /*
+        else if (!strcmp(fourcc,"MOTX"))
+        {
+        }
+        else if (!strcmp(fourcc,"MOMT"))
+        {
+        }
+        else if (!strcmp(fourcc,"MOGN"))
+        {
+        }
+        else if (!strcmp(fourcc,"MOGI"))
+        {
+        }
+        else if (!strcmp(fourcc,"MOLT"))
+        {
+        }
+        else if (!strcmp(fourcc,"MODN"))
+        {
+        }
+        else if (!strcmp(fourcc,"MODS"))
+        {
+        }
+        else if (!strcmp(fourcc,"MODD"))
+        {
+        }
+        else if (!strcmp(fourcc,"MOSB"))
+        {
+        }
+        else if (!strcmp(fourcc,"MOPV"))
+        {
+        }
+        else if (!strcmp(fourcc,"MOPT"))
+        {
+        }
+        else if (!strcmp(fourcc,"MOPR"))
+        {
+        }
+        else if (!strcmp(fourcc,"MFOG"))
+        {
+        }
+        */
+        f.seek((int)nextpos);
+    }
+    f.close();
+    return true;
+}
+
+bool WMORoot::ConvertToVMAPRootWmo(FILE* pOutfile)
+{
+    //printf("Convert RootWmo...\n");
+
+    fwrite(szRawVMAPMagic, 1, 8, pOutfile);
+    unsigned int nVectors = 0;
+    fwrite(&nVectors, sizeof(nVectors), 1, pOutfile); // will be filled later
+    fwrite(&nGroups, 4, 1, pOutfile);
+    fwrite(&RootWMOID, 4, 1, pOutfile);
+    return true;
+}
+
+WMORoot::~WMORoot()
+{
+}
+
+WMOGroup::WMOGroup(std::string& filename) : filename(filename),
+    MOPY(0), MOVI(0), MoviEx(0), MOVT(0), MOBA(0), MobaEx(0), hlq(0), LiquEx(0), LiquBytes(0)
+{
+}
+
+bool WMOGroup::open()
+{
+    MPQFile f(filename.c_str());
+    if (f.isEof())
+    {
+        printf("No such file.\n");
+        return false;
+    }
+    uint32 size;
+    char fourcc[5];
+    while (!f.isEof())
+    {
+        f.read(fourcc, 4);
+        f.read(&size, 4);
+        flipcc(fourcc);
+        if (!strcmp(fourcc, "MOGP")) //Fix sizeoff = Data size.
+        {
+            size = 68;
+        }
+        fourcc[4] = 0;
+        size_t nextpos = f.getPos() + size;
+        LiquEx_size = 0;
+        liquflags = 0;
+
+        if (!strcmp(fourcc, "MOGP")) //header
+        {
+            f.read(&groupName, 4);
+            f.read(&descGroupName, 4);
+            f.read(&mogpFlags, 4);
+            f.read(bbcorn1, 12);
+            f.read(bbcorn2, 12);
+            f.read(&moprIdx, 2);
+            f.read(&moprNItems, 2);
+            f.read(&nBatchA, 2);
+            f.read(&nBatchB, 2);
+            f.read(&nBatchC, 4);
+            f.read(&fogIdx, 4);
+            f.read(&liquidType, 4);
+            f.read(&groupWMOID, 4);
+        }
+        else if (!strcmp(fourcc, "MOPY"))
+        {
+            MOPY = new char[size];
+            mopy_size = size;
+            nTriangles = (int)size / 2;
+            f.read(MOPY, size);
+        }
+        else if (!strcmp(fourcc, "MOVI"))
+        {
+            MOVI = new uint16[size / 2];
+            f.read(MOVI, size);
+        }
+        else if (!strcmp(fourcc, "MOVT"))
+        {
+            MOVT = new float[size / 4];
+            f.read(MOVT, size);
+            nVertices = (int)size / 12;
+        }
+        else if (!strcmp(fourcc, "MONR"))
+        {
+        }
+        else if (!strcmp(fourcc, "MOTV"))
+        {
+        }
+        else if (!strcmp(fourcc, "MOBA"))
+        {
+            MOBA = new uint16[size / 2];
+            moba_size = size / 2;
+            f.read(MOBA, size);
+        }
+        else if (!strcmp(fourcc, "MLIQ"))
+        {
+            liquflags |= 1;
+            hlq = new WMOLiquidHeader;
+            f.read(hlq, 0x1E);
+            LiquEx_size = sizeof(WMOLiquidVert) * hlq->xverts * hlq->yverts;
+            LiquEx = new WMOLiquidVert[hlq->xverts * hlq->yverts];
+            f.read(LiquEx, LiquEx_size);
+            int nLiquBytes = hlq->xtiles * hlq->ytiles;
+            LiquBytes = new char[nLiquBytes];
+            f.read(LiquBytes, nLiquBytes);
+
+            /* std::ofstream llog("Buildings/liquid.log", ios_base::out | ios_base::app);
+            llog << filename;
+            llog << "\nbbox: " << bbcorn1[0] << ", " << bbcorn1[1] << ", " << bbcorn1[2] << " | " << bbcorn2[0] << ", " << bbcorn2[1] << ", " << bbcorn2[2];
+            llog << "\nlpos: " << hlq->pos_x << ", " << hlq->pos_y << ", " << hlq->pos_z;
+            llog << "\nx-/yvert: " << hlq->xverts << "/" << hlq->yverts << " size: " << size << " expected size: " << 30 + hlq->xverts*hlq->yverts*8 + hlq->xtiles*hlq->ytiles << std::endl;
+            llog.close(); */
+        }
+        f.seek((int)nextpos);
+    }
+    f.close();
+    return true;
+}
+
+int WMOGroup::ConvertToVMAPGroupWmo(FILE* output, WMORoot* rootWMO, bool pPreciseVectorData)
+{
+    fwrite(&mogpFlags, sizeof(uint32), 1, output);
+    fwrite(&groupWMOID, sizeof(uint32), 1, output);
+    // group bound
+    fwrite(bbcorn1, sizeof(float), 3, output);
+    fwrite(bbcorn2, sizeof(float), 3, output);
+    fwrite(&liquflags, sizeof(uint32), 1, output);
+    int nColTriangles = 0;
+    if (pPreciseVectorData)
+    {
+        char GRP[] = "GRP ";
+        fwrite(GRP, 1, 4, output);
+
+        int k = 0;
+        int moba_batch = moba_size / 12;
+        MobaEx = new int[moba_batch * 4];
+        for (int i = 8; i < moba_size; i += 12)
+        {
+            MobaEx[k++] = MOBA[i];
+        }
+        int moba_size_grp = moba_batch * 4 + 4;
+        fwrite(&moba_size_grp, 4, 1, output);
+        fwrite(&moba_batch, 4, 1, output);
+        fwrite(MobaEx, 4, k, output);
+        delete [] MobaEx;
+
+        uint32 nIdexes = nTriangles * 3;
+
+        if (fwrite("INDX", 4, 1, output) != 1)
+        {
+            printf("Error while writing file nbraches ID");
+            exit(0);
+        }
+        int wsize = sizeof(uint32) + sizeof(unsigned short) * nIdexes;
+        if (fwrite(&wsize, sizeof(int), 1, output) != 1)
+        {
+            printf("Error while writing file wsize");
+            // no need to exit?
+        }
+        if (fwrite(&nIdexes, sizeof(uint32), 1, output) != 1)
+        {
+            printf("Error while writing file nIndexes");
+            exit(0);
+        }
+        if (nIdexes > 0)
+        {
+            if (fwrite(MOVI, sizeof(unsigned short), nIdexes, output) != nIdexes)
+            {
+                printf("Error while writing file indexarray");
+                exit(0);
+            }
+        }
+
+        if (fwrite("VERT", 4, 1, output) != 1)
+        {
+            printf("Error while writing file nbraches ID");
+            exit(0);
+        }
+        wsize = sizeof(int) + sizeof(float) * 3 * nVertices;
+        if (fwrite(&wsize, sizeof(int), 1, output) != 1)
+        {
+            printf("Error while writing file wsize");
+            // no need to exit?
+        }
+        if (fwrite(&nVertices, sizeof(int), 1, output) != 1)
+        {
+            printf("Error while writing file nVertices");
+            exit(0);
+        }
+        if (nVertices > 0)
+        {
+            if (fwrite(MOVT, sizeof(float) * 3, nVertices, output) != nVertices)
+            {
+                printf("Error while writing file vectors");
+                exit(0);
+            }
+        }
+
+        nColTriangles = nTriangles;
+    }
+    else
+    {
+        char GRP[] = "GRP ";
+        fwrite(GRP, 1, 4, output);
+        int k = 0;
+        int moba_batch = moba_size / 12;
+        MobaEx = new int[moba_batch * 4];
+        for (int i = 8; i < moba_size; i += 12)
+        {
+            MobaEx[k++] = MOBA[i];
+        }
+
+        int moba_size_grp = moba_batch * 4 + 4;
+        fwrite(&moba_size_grp, 4, 1, output);
+        fwrite(&moba_batch, 4, 1, output);
+        fwrite(MobaEx, 4, k, output);
+        delete [] MobaEx;
+
+        //-------INDX------------------------------------
+        //-------MOPY--------
+        MoviEx = new uint16[nTriangles * 3]; // "worst case" size...
+        int* IndexRenum = new int[nVertices];
+        memset(IndexRenum, 0xFF, nVertices * sizeof(int));
+        for (int i = 0; i < nTriangles; ++i)
+        {
+            // Skip no collision triangles
+            if (MOPY[2 * i]&WMO_MATERIAL_NO_COLLISION ||
+                    !(MOPY[2 * i] & (WMO_MATERIAL_HINT | WMO_MATERIAL_COLLIDE_HIT)))
+                continue;
+            // Use this triangle
+            for (int j = 0; j < 3; ++j)
+            {
+                IndexRenum[MOVI[3 * i + j]] = 1;
+                MoviEx[3 * nColTriangles + j] = MOVI[3 * i + j];
+            }
+            ++nColTriangles;
+        }
+
+        // assign new vertex index numbers
+        int nColVertices = 0;
+        for (uint32 i = 0; i < nVertices; ++i)
+        {
+            if (IndexRenum[i] == 1)
+            {
+                IndexRenum[i] = nColVertices;
+                ++nColVertices;
+            }
+        }
+
+        // translate triangle indices to new numbers
+        for (int i = 0; i < 3 * nColTriangles; ++i)
+        {
+            assert(MoviEx[i] < nVertices);
+            MoviEx[i] = IndexRenum[MoviEx[i]];
+        }
+
+        // write triangle indices
+        int INDX[] = {0x58444E49, nColTriangles * 6 + 4, nColTriangles * 3};
+        fwrite(INDX, 4, 3, output);
+        fwrite(MoviEx, 2, nColTriangles * 3, output);
+
+        // write vertices
+        int VERT[] = {0x54524556, nColVertices * 3 * sizeof(float) + 4, nColVertices}; // "VERT"
+        int check = 3 * nColVertices;
+        fwrite(VERT, 4, 3, output);
+        for (uint32 i = 0; i < nVertices; ++i)
+            if (IndexRenum[i] >= 0)
+                check -= fwrite(MOVT + 3 * i, sizeof(float), 3, output);
+
+        assert(check == 0);
+
+        delete [] MoviEx;
+        delete [] IndexRenum;
+    }
+
+    //------LIQU------------------------
+    if (LiquEx_size != 0)
+    {
+        int LIQU_h[] = {0x5551494C, sizeof(WMOLiquidHeader) + LiquEx_size + hlq->xtiles* hlq->ytiles}; // "LIQU"
+        fwrite(LIQU_h, 4, 2, output);
+
+        // according to WoW.Dev Wiki:
+        uint32 liquidEntry;
+        if (rootWMO->liquidType & 4)
+            liquidEntry = liquidType;
+        else if (liquidType == 15)
+            liquidEntry = 0;
+        else
+            liquidEntry = liquidType + 1;
+
+        if (!liquidEntry)
+        {
+            int v1; // edx@1
+            int v2; // eax@1
+
+            v1 = hlq->xtiles * hlq->ytiles;
+            v2 = 0;
+            if (v1 > 0)
+            {
+                while ((LiquBytes[v2] & 0xF) == 15)
+                {
+                    ++v2;
+                    if (v2 >= v1)
+                        break;
+                }
+
+                if (v2 < v1 && (LiquBytes[v2] & 0xF) != 15)
+                    liquidEntry = (LiquBytes[v2] & 0xF) + 1;
+            }
+        }
+
+        if (liquidEntry && liquidEntry < 21)
+        {
+            switch (((uint8)liquidEntry - 1) & 3)
+            {
+                case 0:
+                    liquidEntry = ((mogpFlags & 0x80000) != 0) + 13;
+                    break;
+                case 1:
+                    liquidEntry = 14;
+                    break;
+                case 2:
+                    liquidEntry = 19;
+                    break;
+                case 3:
+                    liquidEntry = 20;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        hlq->type = liquidEntry;
+
+        /* std::ofstream llog("Buildings/liquid.log", ios_base::out | ios_base::app);
+        llog << filename;
+        llog << ":\nliquidEntry: " << liquidEntry << " type: " << hlq->type << " (root:" << rootWMO->liquidType << " group:" << liquidType << ")\n";
+        llog.close(); */
+
+        fwrite(hlq, sizeof(WMOLiquidHeader), 1, output);
+        // only need height values, the other values are unknown anyway
+        for (uint32 i = 0; i < LiquEx_size / sizeof(WMOLiquidVert); ++i)
+            fwrite(&LiquEx[i].height, sizeof(float), 1, output);
+        // todo: compress to bit field
+        fwrite(LiquBytes, 1, hlq->xtiles * hlq->ytiles, output);
+    }
+
+    return nColTriangles;
+}
+
+WMOGroup::~WMOGroup()
+{
+    delete [] MOPY;
+    delete [] MOVI;
+    delete [] MOVT;
+    delete [] MOBA;
+    delete hlq;
+    delete [] LiquEx;
+    delete [] LiquBytes;
+}
+
+WMOInstance::WMOInstance(MPQFile& f, const char* WmoInstName, uint32 mapID, uint32 tileX, uint32 tileY, FILE* pDirfile)
+{
+    pos = Vec3D(0, 0, 0);
+
+    float ff[3];
+    f.read(&id, 4);
+    f.read(ff, 12);
+    pos = Vec3D(ff[0], ff[1], ff[2]);
+    f.read(ff, 12);
+    rot = Vec3D(ff[0], ff[1], ff[2]);
+    f.read(ff, 12);
+    pos2 = Vec3D(ff[0], ff[1], ff[2]);
+    f.read(ff, 12);
+    pos3 = Vec3D(ff[0], ff[1], ff[2]);
+    f.read(&d2, 4);
+
+    uint16 trash, adtId;
+    f.read(&adtId, 2);
+    f.read(&trash, 2);
+
+    //-----------add_in _dir_file----------------
+
+    char tempname[512];
+    sprintf(tempname, "%s/%s", szWorkDirWmo, WmoInstName);
+    FILE* input;
+    input = fopen(tempname, "r+b");
+
+    if (!input)
+    {
+        printf("WMOInstance::WMOInstance: couldn't open %s\n", tempname);
+        return;
+    }
+
+    fseek(input, 8, SEEK_SET); // get the correct no of vertices
+    int nVertices;
+    fread(&nVertices, sizeof(int), 1, input);
+    fclose(input);
+
+    if (nVertices == 0)
+        return;
+
+    float x, z;
+    x = pos.x;
+    z = pos.z;
+    if (x == 0 && z == 0)
+    {
+        pos.x = 533.33333f * 32;
+        pos.z = 533.33333f * 32;
+    }
+    pos = fixCoords(pos);
+    pos2 = fixCoords(pos2);
+    pos3 = fixCoords(pos3);
+
+    float scale = 1.0f;
+    uint32 flags = MOD_HAS_BOUND;
+    if (tileX == 65 && tileY == 65) flags |= MOD_WORLDSPAWN;
+    //write mapID, tileX, tileY, Flags, ID, Pos, Rot, Scale, Bound_lo, Bound_hi, name
+    fwrite(&mapID, sizeof(uint32), 1, pDirfile);
+    fwrite(&tileX, sizeof(uint32), 1, pDirfile);
+    fwrite(&tileY, sizeof(uint32), 1, pDirfile);
+    fwrite(&flags, sizeof(uint32), 1, pDirfile);
+    fwrite(&adtId, sizeof(uint16), 1, pDirfile);
+    fwrite(&id, sizeof(uint32), 1, pDirfile);
+    fwrite(&pos, sizeof(float), 3, pDirfile);
+    fwrite(&rot, sizeof(float), 3, pDirfile);
+    fwrite(&scale, sizeof(float), 1, pDirfile);
+    fwrite(&pos2, sizeof(float), 3, pDirfile);
+    fwrite(&pos3, sizeof(float), 3, pDirfile);
+    uint32 nlen = strlen(WmoInstName);
+    fwrite(&nlen, sizeof(uint32), 1, pDirfile);
+    fwrite(WmoInstName, sizeof(char), nlen, pDirfile);
+
+    /* fprintf(pDirfile,"%s/%s %f,%f,%f_%f,%f,%f 1.0 %d %d %d,%d %d\n",
+        MapName,
+        WmoInstName,
+        (float) x, (float) pos.y, (float) z,
+        (float) rot.x, (float) rot.y, (float) rot.z,
+        nVertices,
+        realx1, realy1,
+        realx2, realy2
+        ); */
+
+    // fclose(dirfile);
+}
+
diff -Nuar clean-build/maptools/vmap_extractor/wmo.h temp-build/maptools/vmap_extractor/wmo.h
--- clean-build/maptools/vmap_extractor/wmo.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/maptools/vmap_extractor/wmo.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,118 @@
+#ifndef WMO_H
+#define WMO_H
+#define TILESIZE (533.33333f)
+#define CHUNKSIZE ((TILESIZE) / 16.0f)
+
+#include <string>
+#include <set>
+#include "vec3d.h"
+#include "loadlib.h"
+
+// MOPY flags
+#define WMO_MATERIAL_NOCAMCOLLIDE    0x01
+#define WMO_MATERIAL_DETAIL          0x02
+#define WMO_MATERIAL_NO_COLLISION    0x04
+#define WMO_MATERIAL_HINT            0x08
+#define WMO_MATERIAL_RENDER          0x10
+#define WMO_MATERIAL_COLLIDE_HIT     0x20
+#define WMO_MATERIAL_WALL_SURFACE    0x40
+
+class WMOInstance;
+class WMOManager;
+class MPQFile;
+
+/* for whatever reason a certain company just can't stick to one coordinate system... */
+static inline Vec3D fixCoords(const Vec3D& v) { return Vec3D(v.z, v.x, v.y); }
+
+class WMORoot
+{
+    public:
+        uint32 nTextures, nGroups, nP, nLights, nModels, nDoodads, nDoodadSets, RootWMOID, liquidType;
+        unsigned int col;
+        float bbcorn1[3];
+        float bbcorn2[3];
+
+        WMORoot(std::string& filename);
+        ~WMORoot();
+
+        bool open();
+        bool ConvertToVMAPRootWmo(FILE* output);
+    private:
+        std::string filename;
+        char outfilename;
+};
+
+struct WMOLiquidHeader
+{
+    int xverts, yverts, xtiles, ytiles;
+    float pos_x;
+    float pos_y;
+    float pos_z;
+    short type;
+};
+
+struct WMOLiquidVert
+{
+    uint16 unk1;
+    uint16 unk2;
+    float height;
+};
+
+class WMOGroup
+{
+    public:
+        // MOGP
+        int groupName, descGroupName, mogpFlags;
+        float bbcorn1[3];
+        float bbcorn2[3];
+        uint16 moprIdx;
+        uint16 moprNItems;
+        uint16 nBatchA;
+        uint16 nBatchB;
+        uint32 nBatchC, fogIdx, liquidType, groupWMOID;
+
+        int mopy_size, moba_size;
+        int LiquEx_size;
+        unsigned int nVertices; // number when loaded
+        int nTriangles; // number when loaded
+        char* MOPY;
+        uint16* MOVI;
+        uint16* MoviEx;
+        float* MOVT;
+        uint16* MOBA;
+        int* MobaEx;
+        WMOLiquidHeader* hlq;
+        WMOLiquidVert* LiquEx;
+        char* LiquBytes;
+        uint32 liquflags;
+
+        WMOGroup(std::string& filename);
+        ~WMOGroup();
+
+        bool open();
+        int ConvertToVMAPGroupWmo(FILE* output, WMORoot* rootWMO, bool pPreciseVectorData);
+
+    private:
+        std::string filename;
+        char outfilename;
+};
+
+class WMOInstance
+{
+        static std::set<int> ids;
+    public:
+        std::string MapName;
+        int currx;
+        int curry;
+        WMOGroup* wmo;
+        Vec3D pos;
+        Vec3D pos2, pos3, rot;
+        uint32 indx, id, d2, d3;
+        int doodadset;
+
+        WMOInstance(MPQFile& f, const char* WmoInstName, uint32 mapID, uint32 tileX, uint32 tileY, FILE* pDirfile);
+
+        static void reset();
+};
+
+#endif
diff -Nuar clean-build/src/bindings/scriptdev2/include/sc_npc_teleport.cpp temp-build/src/bindings/scriptdev2/include/sc_npc_teleport.cpp
--- clean-build/src/bindings/scriptdev2/include/sc_npc_teleport.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/include/sc_npc_teleport.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,359 @@
+/**
+ * npc_teleport.cpp
+ * Based on code by Wilibald09
+ **/
+
+#include "precompiled.h"
+#include "sc_npc_teleport.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+const uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->isGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->isGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUIDLow() == m_data0;
+    }
+
+    error_log("Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {   
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        error_log("Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        error_log("Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            error_log("Invalid data0 (category: %u).", cat);
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        error_log("Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            error_log("Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        error_log("Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            error_log("Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        error_log("Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        error_log("Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        error_log("Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        error_log("Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            error_log("Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        error_log("Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+    }
+
+    error_log("Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(QueryResult *result)
+{
+    result = WorldDatabase.PQuery(
+        "SELECT C.`flag`, C.`data0`, C.`data1`, A.`cat_id`, C.`name` `namecat`,"
+            " D.`name` `namedest`, D.`pos_X`, D.`pos_Y`, D.`pos_Z`,"
+            " D.`orientation`, D.`map`, D.`level`, D.`cost`, A.`display_order`,"
+            " D.`say_on_departure`, D.`cast_on_arrival` " 
+        "FROM `npc_teleport_category` C, `npc_teleport_destination` D, "
+            " `npc_teleport_association` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY A.`cat_id`, A.`display_order`, `namedest`");
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+        outstring_log( "ScriptLib: Loading NPC Teleport Data...");
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+               fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetCppString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                  fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetCppString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+                fields[14].GetCppString(),  // Say on Departure
+                fields[15].GetUInt32(),     // Cast on Arrival
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        outstring_log("ScriptLib: >> Loaded %u NPC Teleport Locations", nbDest);
+    } else outstring_log("ScriptLib: >> Loaded 0 NPC Teleport Locations");
+    delete result;
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
+
diff -Nuar clean-build/src/bindings/scriptdev2/include/sc_npc_teleport.h temp-build/src/bindings/scriptdev2/include/sc_npc_teleport.h
--- clean-build/src/bindings/scriptdev2/include/sc_npc_teleport.h	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/include/sc_npc_teleport.h	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,146 @@
+/**
+ * npc_teleport.cpp
+ * Based on code by Wilibald09
+ **/
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+        std::string m_sayondeparture;
+        uint32      m_castonarrival;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+        
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        const uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(QueryResult *result);
+
+extern DatabaseType WorldDatabase;
+
+#endif
+
diff -Nuar clean-build/src/bindings/scriptdev2/ScriptMgr.cpp temp-build/src/bindings/scriptdev2/ScriptMgr.cpp
--- clean-build/src/bindings/scriptdev2/ScriptMgr.cpp	2014-08-02 06:54:02.000000000 -0400
+++ temp-build/src/bindings/scriptdev2/ScriptMgr.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -7,6 +7,7 @@
 #include "config.h"
 #include "Database/DatabaseEnv.h"
 #include "DBCStores.h"
+#include "sc_npc_teleport.h"
 #include "ObjectMgr.h"
 #include "ProgressBar.h"
 #include "../system/ScriptLoader.h"
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/item_phase1.cpp temp-build/src/bindings/scriptdev2/scripts/custom/item_phase1.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/item_phase1.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/item_phase1.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,28 @@
+/* ScriptData
+SDName: Item_Phase1
+SD%Complete: 100
+SDComment: Used to change player to phasemask 1
+SDCategory: Items
+EndScriptData */
+
+#include "precompiled.h"
+#include <cstring>
+
+bool ItemUse_item_phase1(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+    // Declare variables
+    uint32 phase = 1;
+    player->SetPhaseMask(phase, true);
+    return true;
+}
+
+void AddSC_item_phase1()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="item_phase1";
+    newscript->pItemUse = &ItemUse_item_phase1;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/item_phase2.cpp temp-build/src/bindings/scriptdev2/scripts/custom/item_phase2.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/item_phase2.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/item_phase2.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,28 @@
+/* ScriptData
+SDName: Item_Phase2
+SD%Complete: 100
+SDComment: Used to change player to phasemask 2
+SDCategory: Items
+EndScriptData */
+
+#include "precompiled.h"
+#include <cstring>
+
+bool ItemUse_item_phase2(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+    // Declare variables
+    uint32 phase = 2;
+    player->SetPhaseMask(phase, true);
+    return true;
+}
+
+void AddSC_item_phase2()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="item_phase2";
+    newscript->pItemUse = &ItemUse_item_phase2;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/item_phase4.cpp temp-build/src/bindings/scriptdev2/scripts/custom/item_phase4.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/item_phase4.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/item_phase4.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,28 @@
+/* ScriptData
+SDName: Item_Phase4
+SD%Complete: 100
+SDComment: Used to change player to phasemask 4
+SDCategory: Items
+EndScriptData */
+
+#include "precompiled.h"
+#include <cstring>
+
+bool ItemUse_item_phase4(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+    // Declare variables
+    uint32 phase = 4;
+    player->SetPhaseMask(phase, true);
+    return true;
+}
+
+void AddSC_item_phase4()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="item_phase4";
+    newscript->pItemUse = &ItemUse_item_phase4;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/item_summonnpc.cpp temp-build/src/bindings/scriptdev2/scripts/custom/item_summonnpc.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/item_summonnpc.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/item_summonnpc.cpp	2014-07-31 07:18:28.000000000 -0400
@@ -0,0 +1,62 @@
+/* ScriptData
+SDName: item_summonnpc
+SD%Complete: 100
+SDComment: Summon NPC
+SDCategory: Items
+EndScriptData */
+
+#include "precompiled.h"
+#include <cstring>
+
+bool ItemUse_item_summonnpc(Player* pPlayer, Item* pItem, const SpellCastTargets &pTargets)
+{
+
+    // Declare Variables
+    uint32 itemId = pItem->GetEntry();
+    uint32 npcId;
+    uint32 despawnSec;
+    extern DatabaseType WorldDatabase;
+
+if ((pPlayer->isInCombat()) || (!pPlayer->isAlive()))
+{
+      pPlayer->SendEquipError(EQUIP_ERR_NOT_IN_COMBAT, pItem, NULL);
+        return false;
+}
+
+if (pPlayer->IsMounted()) // Is player mounted
+{
+      pPlayer->SendEquipError(EQUIP_ERR_CANT_DO_RIGHT_NOW, pItem, NULL);
+        return true;
+}
+
+{
+        // Fetch the NPC Id
+        QueryResult *result = WorldDatabase.PQuery("SELECT `creature_entry`, `despawn` FROM `item_summonnpc` WHERE `item_entry` = '%i' LIMIT 1",itemId);
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        // Read NPC Id from the query result
+        npcId = fields[0].GetInt32();
+        // Read time before despawn
+        despawnSec = fields[1].GetUInt32() * 1000;
+        // Summon the NPC
+        pPlayer->SummonCreature(npcId,pPlayer->GetPositionX() ,pPlayer->GetPositionY()-2, pPlayer->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, despawnSec);
+        return true;
+    } else {
+        // Summons failed - show info in log
+        outstring_log ("Item_SummonNPC Failed: %i)",itemId);
+    }
+    delete result;
+}
+        return false;
+}
+void AddSC_item_summonnpc()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="item_summonnpc";
+    newscript->pItemUse = &ItemUse_item_summonnpc;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/item_teleport.cpp temp-build/src/bindings/scriptdev2/scripts/custom/item_teleport.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/item_teleport.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/item_teleport.cpp	2014-07-31 07:18:47.000000000 -0400
@@ -0,0 +1,50 @@
+/* ScriptData
+SDName: Item_Teleport
+SD%Complete: 100
+SDComment: Used for Teleport Item Scripts
+SDCategory: Items
+EndScriptData */
+
+#include "precompiled.h"
+#include <cstring>
+
+bool ItemUse_item_teleport(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+    // Declare variables
+    float x_pos, y_pos, z_pos, o_pos;
+    uint32 mapid;
+    uint32 itemId = _Item->GetEntry();
+    extern DatabaseType WorldDatabase;
+
+    // Fetch the coordinates
+    QueryResult *result = WorldDatabase.PQuery("SELECT `mapid`, `X_pos`, `Y_pos`, `Z_pos`, `orientation`  FROM `item_teleports` WHERE `entry` = '%i' LIMIT 1",itemId);
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        // Read coords from the query result
+        mapid = fields[0].GetInt32();
+        x_pos = fields[1].GetFloat();
+        y_pos = fields[2].GetFloat();
+        z_pos = fields[3].GetFloat();
+        o_pos = fields[4].GetFloat();
+        // Teleport the player and show info in log
+        player->TeleportTo(mapid, x_pos, y_pos, z_pos, o_pos);
+        outstring_log ("Teleport Activated: %i (m:%i x:%f y:%f z:%f o:%f)",itemId,mapid,x_pos,y_pos,z_pos,o_pos);
+        return true;
+    } else {
+        // Teleport failed - show info in log
+        outstring_log ("Teleport Failed: %i (m:%i x:%f y:%f z:%f o:%f)",itemId,mapid,x_pos,y_pos,z_pos,o_pos);
+    }
+    delete result;
+}
+
+void AddSC_item_teleport()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="item_teleport";
+    newscript->pItemUse = &ItemUse_item_teleport;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_areaguard.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_areaguard.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_areaguard.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_areaguard.cpp	2014-07-31 07:19:05.000000000 -0400
@@ -0,0 +1,131 @@
+#include "precompiled.h"
+
+struct npc_areaguardAI : public Scripted_NoMovementAI
+{
+    npc_areaguardAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+    {
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        pCreature->ApplySpellImmune(0, IMMUNITY_DAMAGE, SPELL_SCHOOL_NORMAL, true);
+        pCreature->ApplySpellImmune(0, IMMUNITY_DAMAGE, SPELL_SCHOOL_MASK_MAGIC, true);
+    }
+
+    void Reset(){}
+
+    void Aggro(Unit* /*pWho*/){}
+
+    void AttackStart(Unit* /*pWho*/){}
+
+    void MoveInLineOfSight(Unit *pWho, Creature* pCreature)
+    {
+
+        // Return if Distance is greater than maximum (65 ft) - saves data reads
+        if (!pCreature->IsWithinDist(pWho, 65.0f, false))
+            return;
+
+        extern DatabaseType WorldDatabase;
+        uint32 creatureID = pCreature->GetEntry();
+        uint32 guardType;
+        uint32 triggerDist;
+        uint32 reqValue1, reqValue2;
+        uint32 teleMap;
+        float teleX,teleY,teleZ,teleO;
+
+        QueryResult* result = WorldDatabase.PQuery("SELECT `guard_type`, `trigger_distance`, `req_value1`,`req_value2`,`tele_map`,`tele_x`,`tele_y`,`tele_z`,`tele_o` FROM `npc_areaguard` WHERE `creature_entry` = %i LIMIT 1",creatureID);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            guardType = fields[0].GetUInt32();
+            triggerDist = fields[1].GetFloat();
+            reqValue1 = fields[2].GetUInt32();
+            reqValue2 = fields[3].GetUInt32();
+            teleMap = fields[4].GetUInt32();
+            teleX = fields[5].GetFloat();
+            teleY = fields[6].GetFloat();
+            teleZ = fields[7].GetFloat();
+            teleO = fields[8].GetFloat();
+            delete result;
+        } else {
+            return;
+        }
+
+        if (!pWho || !pWho->IsInWorld())
+            return;
+
+        // Return if distance is greater than the trigger_distance
+        if (!pCreature->IsWithinDist(pWho, triggerDist, false))
+            return;
+
+        Player *pPlayer = pWho->GetCharmerOrOwnerPlayerOrPlayerItself();
+
+        // Return if player has GM flag on or is in process of teleport
+        if (!pPlayer || pPlayer->isGameMaster() || pPlayer->IsBeingTeleported())
+            return;
+
+        switch (guardType)
+        {
+            case 0:
+                // Action on all players without GM flag on
+                pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                break;
+            case 1:
+                {
+                // Action based on Team
+                if (reqValue1 == 1) // Alliance Required 
+                    if (pPlayer->GetTeam() != 469) // Player is Horde
+                        pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                if (reqValue1 == 2) // Horde Required
+                    if (pPlayer->GetTeam() != 67) // Player is Alliance
+                        pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+            case 2:
+                {
+                // Action based on GM Level
+                if (pPlayer->GetSession()->GetSecurity() < reqValue1)
+                    pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+            case 3:
+                {
+                // Action based on Player Level
+                if (pPlayer->getLevel() < reqValue1 || pPlayer->getLevel() > reqValue2)
+                    pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+            case 4:
+                {
+                // Action based on Guild ID
+                if (pPlayer->GetGuildId() != reqValue1)
+                    pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+            case 5:
+                {
+                // Action based on Player GUID
+                if (pPlayer->GetGUIDLow() != reqValue1)
+                    pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+        }
+ 
+        return;
+    }
+
+    void UpdateAI(const uint32 /*diff*/){}
+};
+
+CreatureAI* GetAI_npc_areaguard(Creature* pCreature)
+{
+    return new npc_areaguardAI(pCreature);
+}
+
+void AddSC_npc_areaguard()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "npc_areaguard";
+    newscript->GetAI = &GetAI_npc_areaguard;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_buff.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_buff.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_buff.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_buff.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,261 @@
+/* ScriptData
+SDName: NPC_Buff
+SD%Complete: 95
+SDComment: Buff Master
+SDCategory: NPC
+EndScriptData */
+
+#include "precompiled.h"
+
+bool GossipHello_NPC_Buff(Player *player, Creature *_Creature)
+{
+	// Main Menu for Alliance
+    if ( player->GetTeam() == ALLIANCE )
+	{
+	player->ADD_GOSSIP_ITEM( 7, "Small Spells ->", GOSSIP_SENDER_MAIN, 1000);
+        player->ADD_GOSSIP_ITEM( 7, "GM Spells ->", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM( 7, "Other Gifts ->", GOSSIP_SENDER_MAIN, 4000);
+	}
+	else // Main Menu for Horde
+	{
+	player->ADD_GOSSIP_ITEM( 7, "Small Spells ->", GOSSIP_SENDER_MAIN, 1000);
+        player->ADD_GOSSIP_ITEM( 7, "GM Spells ->", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM( 7, "Other Gifts ->", GOSSIP_SENDER_MAIN, 4000);
+	}
+
+	player->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness", GOSSIP_SENDER_MAIN, 5000);
+
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetObjectGuid());
+
+return true;
+}
+
+void SendDefaultMenu_NPC_Buff(Player *player, Creature *_Creature, uint32 action )
+{
+
+// Not allow in combat
+if(!player->getAttackers().empty())
+{
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+	return;
+}
+
+switch(action)
+{
+
+case 1000: //Small  Buff
+		player->ADD_GOSSIP_ITEM( 5, "Give me Mark of the Wild"                , GOSSIP_SENDER_MAIN, 1001);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Thorns"                          , GOSSIP_SENDER_MAIN, 1005);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Amplify Magic"                   , GOSSIP_SENDER_MAIN, 1010);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Arcane Intellect"                , GOSSIP_SENDER_MAIN, 1015);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Dampen Magic"                    , GOSSIP_SENDER_MAIN, 1025);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Kings"               , GOSSIP_SENDER_MAIN, 1030);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Might"               , GOSSIP_SENDER_MAIN, 1035);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Wisdom"              , GOSSIP_SENDER_MAIN, 1040);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Divine Spirit"                   , GOSSIP_SENDER_MAIN, 1045);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Power Word: Fortitude"           , GOSSIP_SENDER_MAIN, 1050);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Shadow Protection"               , GOSSIP_SENDER_MAIN, 1055);
+		player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetObjectGuid());
+break;
+
+case 3000: //GM  Buff
+		player->ADD_GOSSIP_ITEM( 5, "Give me Agamaggan's Agility"             , GOSSIP_SENDER_MAIN, 3001);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Agamaggan's Strength"            , GOSSIP_SENDER_MAIN, 3005);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Increased Stamina"               , GOSSIP_SENDER_MAIN, 3020);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Razorhide"                       , GOSSIP_SENDER_MAIN, 3025);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Rising Spirit"                   , GOSSIP_SENDER_MAIN, 3030);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Spirit of the Wind"              , GOSSIP_SENDER_MAIN, 3035);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Wisdom of Agamaggan"             , GOSSIP_SENDER_MAIN, 3040);
+		player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetObjectGuid());
+break;
+
+case 4000: //Player Tools
+		player->ADD_GOSSIP_ITEM( 5, "Give me Gold"                            , GOSSIP_SENDER_MAIN, 4001);
+		player->ADD_GOSSIP_ITEM( 5, "Give me Soul Shards"                     , GOSSIP_SENDER_MAIN, 4005);
+                player->ADD_GOSSIP_ITEM( 5, "Maximize my Skills"
+      , GOSSIP_SENDER_MAIN, 4007);
+		player->ADD_GOSSIP_ITEM( 5, "Heal Me, Please"                          , GOSSIP_SENDER_MAIN, 4010);
+		player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetObjectGuid());
+break;
+
+case 5005: //Back To Main Menu
+	// Main Menu for Alliance
+    if ( player->GetTeam() == ALLIANCE )
+	{
+	player->ADD_GOSSIP_ITEM( 7, "Small Spells ->", GOSSIP_SENDER_MAIN, 1000);
+        player->ADD_GOSSIP_ITEM( 7, "GM Spells ->", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM( 7, "Other Gifts ->", GOSSIP_SENDER_MAIN, 4000);
+	}
+	else // Main Menu for Horde
+	{
+	player->ADD_GOSSIP_ITEM( 7, "Small Spells ->", GOSSIP_SENDER_MAIN, 1000);
+        player->ADD_GOSSIP_ITEM( 7, "GM Spells ->", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM( 7, "Other Gifts ->", GOSSIP_SENDER_MAIN, 4000);
+	}
+
+	player->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness", GOSSIP_SENDER_MAIN, 5000);
+
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetObjectGuid());
+break;
+
+////////////////////////////////Small Buff////////////////////////////////////
+
+case 1001: // Give me Mark of the Wild
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,9885,false);
+break;
+
+case 1005: // Give me Thorns
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,26992,false);
+break;
+
+case 1010: // Give me Amplify Magic
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,33946,false);
+break;
+
+case 1015: // Give me Arcane Intellect
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,27126,false);
+break;
+
+case 1025: // Give me Dampen Magic
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,33944,false);
+break;
+
+case 1030: // Give me Blessing of Kings
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,20217,false);
+break;
+
+case 1035: // Give me Blessing of Might
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,19838,false);
+break;
+
+case 1040: // Give me Blessing of Wisdom
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,25290,false);
+break;
+
+case 1045: // Give me Divine Spirit
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,25312,false);
+break;
+
+case 1050: // Give me Power Word: Fortitude
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,10938,false);
+break;
+
+case 1055: // Give me Shadow Protection
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,25433,false);
+break;
+
+////////////////////////////////GM Buff///////////////////////////////////////
+
+case 3001: // Give me Agamaggan's Agility
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,17013,false);
+break;
+
+case 3005: // Give me Agamaggan's Strength
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,16612,false);
+break;
+
+case 3020: // Give me Increased Stamina
+    player->CLOSE_GOSSIP_MENU();
+    player->CastSpell(player,25661,false);
+break;
+
+case 3025: // Give me Razorhide
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,16610,false);
+break;
+
+case 3030: // Give me Rising Spirit
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,10767,false);
+break;
+
+case 3035: // Give me Spirit of the Wind
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,16618,false);
+break;
+
+case 3040: // Give me Wisdom of Agamaggan
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,7764,false);
+break;
+
+////////////////////////////////Player Tools//////////////////////////////////
+
+case 4001://Give me Gold
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,46642,false); // 5000 gold
+break;
+
+case 4005://Give me Soul Shards
+    player->CLOSE_GOSSIP_MENU();
+    player->CastSpell(player,24827,false);
+break;
+
+case 4007: // Update Skill to Max for Level      
+    player->CLOSE_GOSSIP_MENU();
+    player->UpdateSkillsToMaxSkillsForLevel();
+break;
+
+case 4010: // Heal me please
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,38588,false);
+break;
+
+case 5000://Remove Res Sickness
+	if(!player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS)) {
+		_Creature->MonsterWhisper("You are not suffering from resurrection sickness.", player);
+		GossipHello_NPC_Buff(player, _Creature);
+		return;
+	}
+
+	_Creature->CastSpell(player,38588,false); // Healing effect
+	player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+	player->CLOSE_GOSSIP_MENU();
+break;
+
+ player->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+
+
+bool GossipSelect_NPC_Buff(Player *player, Creature *_Creature, uint32 sender, uint32 action)
+{
+	// Main menu
+	if (sender == GOSSIP_SENDER_MAIN)
+	SendDefaultMenu_NPC_Buff( player, _Creature, action );
+
+return true;
+}
+
+void AddSC_npc_buff()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "npc_buff";
+    newscript->pGossipHello = &GossipHello_NPC_Buff;
+    newscript->pGossipSelect = &GossipSelect_NPC_Buff;
+    newscript->RegisterSelf();
+}
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_codebox.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_codebox.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_codebox.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_codebox.cpp	2014-07-31 07:19:26.000000000 -0400
@@ -0,0 +1,218 @@
+/* ScriptData
+SDName: NPC_Code_Codebox
+SD%Complete: 100
+SDComment: Makes an NPC give a gift if a valid code is entered
+SDCategory: NPCs
+EndScriptData */
+
+#include "precompiled.h"
+#include <cstring>
+
+#define C_GOSSIP_MENU 907
+#define D_ENTER_CODE "I have a code!"
+#define D_CANCEL_CODE "Nevermind..."
+#define SAY_INV_FULL "Your code is right, but you have no space in your bags!  Come back when you have some free space."
+#define SAY_EXPIRED "Sorry, your code has expired.  Come back when you have a valid one."
+#define SAY_INVALID "Sorry, your code is not valid.  Come back when you have a new one."
+#define SAY_GIVE_PRESENT "This is for you!  I hope you enjoy it."
+#define SAY_EXTRA_BUFF "How lucky you are!  You get an item and a buff!"
+#define SAY_GIVE_BUFF "Here is a special buff, just for you!"
+#define SAY_GOODBYE "Nice to see you!  Goodbye!"
+
+/*
+ Returns TRUE if the gift is given.
+ Returns FALSE if the code is wrong
+   or if the gift can't be given (i.e. full inventory).
+
+ ~elegos
+*/
+bool checkCode(Player *player, Creature *_Creature, const char* sCode)
+{
+    // Some variables declarations.
+    int32 item_id = 0;
+    int32 aura_id = 0;
+    uint32 quantity = 0;
+    int32 uses = 0;
+    bool check = false;
+
+    extern DatabaseType WorldDatabase;
+    uint32 creatureID = _Creature->GetEntry();
+
+    QueryResult *result = WorldDatabase.PQuery("SELECT `item_id`, `aura_id`, `quantity`, `uses`  FROM `npc_codebox_codes` WHERE `code` = '%s' AND npc_id = %i LIMIT 1",sCode,creatureID);
+    if(result)
+    {
+        check = true;
+        Field *fields = result->Fetch();
+
+        item_id = fields[0].GetInt32();
+        aura_id = fields[1].GetInt32();
+        quantity = fields[2].GetUInt32();
+        uses = fields[3].GetUInt32();
+
+        if(uses != 0)
+        {
+            if(item_id > 0)
+            {
+                ItemPosCountVec dest;
+                uint8 canStoreNewItem = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item_id, quantity);
+                if(canStoreNewItem == EQUIP_ERR_OK)
+                {
+                    Item *newItem = NULL;
+                    newItem = player->StoreNewItem(dest,item_id,quantity,true);
+                    player->SendNewItem(newItem,quantity,true,false);
+                }
+                else
+                {
+                    _Creature->MonsterWhisper(SAY_INV_FULL, player);
+                    check = false;
+                }
+            }
+            else if(item_id < 0)
+            {
+                uint32 id = item_id * -1;
+                uint32 num;
+                uint32 item;
+                QueryResult *items = WorldDatabase.PQuery("SELECT `item_id` FROM `npc_codebox_item_loot` WHERE `group_id` = '%i'",id);
+                if(items)
+                {
+                    num = rand()%items->GetRowCount();
+                    Field *i;
+                    uint32 count = 0;
+                    do
+                    {
+                        i = items->Fetch();
+                        item = i[0].GetUInt32();
+                        ++count;
+                    }while((count < num) && (items->NextRow()));
+                    ItemPosCountVec dest;
+                    uint8 canStoreNewItem = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item, quantity);
+                    if(canStoreNewItem == EQUIP_ERR_OK)
+                    {
+                        Item *newItem = NULL;
+                        newItem = player->StoreNewItem(dest,item,quantity,true);
+                        player->SendNewItem(newItem,quantity,true,false);
+                    }
+                    else
+                    {
+                        _Creature->MonsterWhisper(SAY_INV_FULL, player);
+                        check = false;
+                    }
+                }
+                delete items;
+            }
+            if(aura_id > 0 && check == true)
+            {
+                _Creature->CastSpell(player, aura_id, true);
+            }
+            else if(aura_id < 0 && check == true)
+            {
+                uint32 id = aura_id * -1;
+                uint32 num;
+                uint32 aura;
+                QueryResult *auras = WorldDatabase.PQuery("SELECT `aura_id` FROM `npc_codebox_aura_loot` WHERE `group_id` = '%i'",id);
+                if(auras)
+                {
+                    num = rand()%auras->GetRowCount();
+                    Field *a;
+                    uint32 count = 0;
+                    do
+                    {
+                        a = auras->Fetch();
+                        aura = a[0].GetUInt32();
+                        ++count;
+                    }while((count < num) && (auras->NextRow()));
+                    _Creature->CastSpell(player, aura, true);
+                }
+                delete auras;
+            }
+        }
+        else
+        {
+            check = false;
+            _Creature->MonsterWhisper(SAY_EXPIRED, player);
+        }
+    }
+    else
+    {
+        check = false;
+        _Creature->MonsterWhisper(SAY_INVALID, player);
+    }
+    delete result;
+
+
+    if(check == true)
+    {
+        if(uses > 0)
+        {
+            WorldDatabase.PExecute("UPDATE `npc_codebox_codes` SET `uses` = (`uses` - 1) WHERE `code` = '%s' AND `npc_id` = '%i' LIMIT 1",sCode, creatureID);
+        }
+        if(item_id != 0 && aura_id == 0)
+            _Creature->MonsterSay(SAY_GIVE_PRESENT, LANG_UNIVERSAL, NULL);
+        if(item_id != 0 && aura_id != 0)
+            _Creature->MonsterSay(SAY_EXTRA_BUFF, LANG_UNIVERSAL, NULL);
+        if(item_id == 0 && aura_id != 0)
+            _Creature->MonsterSay(SAY_GIVE_BUFF, LANG_UNIVERSAL, NULL);
+    }
+    return check;
+}
+
+//This function is called when the player opens the gossip menubool
+bool GossipHello_npc_codebox(Player *player, Creature *_Creature)
+{
+    int32 text_id = C_GOSSIP_MENU;
+    
+    extern DatabaseType WorldDatabase;
+    uint32 creatureID = _Creature->GetEntry();
+
+    QueryResult *result = WorldDatabase.PQuery("SELECT `npc_text_id` FROM `npc_codebox_text` WHERE npc_id = %i LIMIT 1",creatureID);
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        text_id = fields[0].GetInt32();
+    }
+    delete result;
+
+    player->ADD_GOSSIP_ITEM_EXTENDED(0, D_ENTER_CODE, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1, "", 0, true);
+    player->ADD_GOSSIP_ITEM(0, D_CANCEL_CODE, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+
+    player->PlayerTalkClass->SendGossipMenu(text_id,_Creature->GetObjectGuid());
+    return true;
+}
+
+//This function is called when the player clicks an option on the gossip menubool
+bool GossipSelect_npc_codebox(Player *player, Creature *_Creature, uint32 sender, uint32 action )
+{
+    if(action == GOSSIP_ACTION_INFO_DEF+2)
+    {
+        _Creature->MonsterSay(SAY_GOODBYE, LANG_UNIVERSAL, NULL); 
+        player->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+bool GossipSelectWithCode_npc_codebox( Player *player, Creature *_Creature, uint32 sender, uint32 action, const char* sCode )
+{
+    if(sender == GOSSIP_SENDER_MAIN)
+    {
+        if(action == GOSSIP_ACTION_INFO_DEF+1)
+        {
+            checkCode(player, _Creature, sCode);
+            player->CLOSE_GOSSIP_MENU();
+            return true;
+        }
+    }
+    return false;
+}
+
+void AddSC_npc_codebox()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="npc_codebox";
+    newscript->pGossipHello =           &GossipHello_npc_codebox;
+    newscript->pGossipSelect =          &GossipSelect_npc_codebox;
+    newscript->pGossipSelectWithCode =  &GossipSelectWithCode_npc_codebox;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_doorcodes.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_doorcodes.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_doorcodes.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_doorcodes.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,86 @@
+/*######
+## npc_doorcodes
+######*/
+
+// Based on an awesome script by Pixeel - TC2 Forums
+
+#include "precompiled.h"
+#include "ObjectMgr.h"
+#include "ScriptMgr.h"
+#include "Chat.h"
+
+bool verification1Code(Player *pPlayer, Creature *pCreature, const char* sCode)
+{
+    bool verification1 = false;
+
+    QueryResult *result = WorldDatabase.PQuery( "SELECT `secret`, `gameobject_entry`, `opentimesec`, `greeting` FROM `npc_doorcodes` WHERE `secret` = '%s' AND `creature_entry` = %u LIMIT 1", sCode, pCreature->GetEntry() );
+    
+    if(result)
+    {
+        Field *fields = result->Fetch();
+          verification1 = true;
+          uint32 targetGo = fields[1].GetUInt32();
+          std::string npcGreeting = fields[3].GetCppString();
+          GameObject* SecureDoor = GetClosestGameObjectWithEntry(pCreature, targetGo, 10.0f);
+            if (SecureDoor->getLootState() == GO_READY)
+            {
+                SecureDoor->UseDoorOrButton(fields[2].GetUInt32());
+                pCreature->MonsterSay( npcGreeting.c_str(), LANG_UNIVERSAL, NULL );
+            }
+    }
+    
+    if(!result)
+    {
+        verification1 = false;
+        pCreature->MonsterWhisper("That is not correct!  Be gone liar.", pPlayer);
+    }
+    delete result;
+    
+    return verification1;
+}
+
+bool GossipHello_npc_doorcodes(Player *pPlayer, Creature *pCreature)
+{
+    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(0, "I know the secret word.", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1, "", 0, true);
+    pPlayer->ADD_GOSSIP_ITEM(0, "I do not know the secret word.", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+
+    pPlayer->PlayerTalkClass->SendGossipMenu(91020,pCreature->GetObjectGuid());
+    return true;
+}
+
+bool GossipSelect_npc_doorcodes(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action )
+{
+    if(action == GOSSIP_ACTION_INFO_DEF+2)
+    {
+        pCreature->MonsterWhisper("Sorry, No one comes in without the secret word.", pPlayer);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+bool GossipSelectWithCode_npc_doorcodes( Player *player, Creature *pCreature, uint32 sender, uint32 action, const char* sCode )
+{
+    if(sender == GOSSIP_SENDER_MAIN)
+    {
+        if(action == GOSSIP_ACTION_INFO_DEF+1)
+        {
+            verification1Code(player, pCreature, sCode);
+            player->CLOSE_GOSSIP_MENU();
+            return true;
+        }
+    }
+    return false;
+}
+
+void AddSC_npc_doorcodes()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="npc_doorcodes";
+    newscript->pGossipHello =           &GossipHello_npc_doorcodes;
+    newscript->pGossipSelect =          &GossipSelect_npc_doorcodes;
+    newscript->pGossipSelectWithCode =  &GossipSelectWithCode_npc_doorcodes;
+    newscript->RegisterSelf();
+    
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_guildmaster.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_guildmaster.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_guildmaster.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_guildmaster.cpp	2014-07-31 07:19:56.000000000 -0400
@@ -0,0 +1,344 @@
+/* ScriptData
+SDName: GuildMaster
+SD%Complete: 95
+SDComment: Guild House Master
+SDCategory: NPC
+EndScriptData */
+
+#include "precompiled.h"
+#include "Config/Config.h"
+
+extern DatabaseType WorldDatabase;
+
+#define MSG_GOSSIP_TELE          "Teleport to Guild House"
+#define MSG_GOSSIP_NEXTPAGE      "Next -->"
+#define MSG_INCOMBAT             "You are in battle!"
+#define MSG_NOGUILDHOUSE         "Your guild does not have a Guild House."
+#define MSG_NOFREEGH             "Unfortunately, all the Guild Houses have been sold."
+#define MSG_ALREADYHAVEGH        "Sorry, but you already have a Guild House (%s)."
+#define MSG_NOTENOUGHMONEY       "You must have %u gold to buy a Guild House."
+#define MSG_GHOCCUPIED           "Unfortunately, this Guild House is already in use."
+#define MSG_CONGRATULATIONS      "Congratulations! You now own a Guild House."
+#define MSG_SOLD                 "You sold your Guild House. Here is %u in gold."
+#define MSG_NOTINGUILD           "You are not in a guild!"
+
+#define CODE_SELL                "SELL"
+#define MSG_CODEBOX_SELL         "Enter \"" CODE_SELL "\" to sell your Guild House."
+
+#define OFFSET_GH_ID_TO_ACTION   1500
+#define OFFSET_SHOWBUY_FROM      10000
+
+#define ACTION_TELE              1001
+#define ACTION_SHOW_BUYLIST      1002  //deprecated. Use (OFFSET_SHOWBUY_FROM + 0) instead
+#define ACTION_SELL_GUILDHOUSE   1003
+
+#define ICON_GOSSIP_BALOON       0
+#define ICON_GOSSIP_WING         2
+#define ICON_GOSSIP_BOOK         3
+#define ICON_GOSSIP_WHEEL1       4
+#define ICON_GOSSIP_WHEEL2       5
+#define ICON_GOSSIP_GOLD         6
+#define ICON_GOSSIP_BALOONDOTS   7
+#define ICON_GOSSIP_TABARD       8
+#define ICON_GOSSIP_XSWORDS      9
+
+#define GOSSIP_COUNT_MAX         10
+
+bool isPlayerGuildLeader(Player *player)
+{
+    return (player->GetRank() == 0) && (player->GetGuildId() != 0);
+}
+
+bool getGuildHouseCoords(uint32 guildId, float &x, float &y, float &z, uint32 &map)
+{
+    if (guildId == 0)
+    {
+        //if player has no guild
+        return false;
+    }
+
+    QueryResult *result = WorldDatabase.PQuery("SELECT `x`, `y`, `z`, `map` FROM `guild_houses` WHERE `guildId` = %u", guildId);
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        x = fields[0].GetFloat();
+        y = fields[1].GetFloat();
+        z = fields[2].GetFloat();
+        map = fields[3].GetUInt32();
+        delete result;
+        return true;
+    }
+    delete result;
+    return false;
+}
+
+void teleportPlayerToGuildHouse(Player *player, Creature *_creature)
+{
+    if (player->GetGuildId() == 0)
+    {
+        //if player has no guild
+        _creature->MonsterWhisper(MSG_NOTINGUILD, player);
+        return;
+    }
+
+    if (!player->getAttackers().empty())
+    {
+        //if player in combat
+        _creature->MonsterSay(MSG_INCOMBAT, LANG_UNIVERSAL, player);
+        return;
+    }
+
+    float x, y, z;
+    uint32 map;
+
+    if (getGuildHouseCoords(player->GetGuildId(), x, y, z, map))
+    {
+        //teleport player to the specified location
+        player->TeleportTo(map, x, y, z, 0.0f);
+    }
+    else
+        _creature->MonsterWhisper(MSG_NOGUILDHOUSE, player);
+
+}
+
+bool showBuyList(Player *player, Creature *_creature, uint32 showFromId = 0)
+{
+    //show not occupied guildhouses
+
+    QueryResult *result = WorldDatabase.PQuery("SELECT `id`, `comment` FROM `guild_houses` WHERE `guildId` = 0 AND `id` > %u ORDER BY `id` ASC LIMIT %u",
+        showFromId, GOSSIP_COUNT_MAX);
+
+    if (result)
+    {
+        uint32 guildhouseId = 0;
+        std::string comment = "";
+        do
+        {
+
+            Field *fields = result->Fetch();
+
+            guildhouseId = fields[0].GetInt32();
+            comment = fields[1].GetString();
+            
+            //send comment as a gossip item
+            //transmit guildhouseId in Action variable
+            player->ADD_GOSSIP_ITEM(ICON_GOSSIP_TABARD, comment, GOSSIP_SENDER_MAIN,
+                guildhouseId + OFFSET_GH_ID_TO_ACTION);
+
+        } while (result->NextRow());
+
+        if (result->GetRowCount() == GOSSIP_COUNT_MAX)
+        {
+            //assume that we have additional page
+            //add link to next GOSSIP_COUNT_MAX items
+            player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOONDOTS, MSG_GOSSIP_NEXTPAGE, GOSSIP_SENDER_MAIN, 
+                guildhouseId + OFFSET_SHOWBUY_FROM);
+        }
+
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetObjectGuid());
+
+        delete result;
+        return true;
+    } else
+    {
+        if (showFromId == 0)
+        {
+            //all guildhouses are occupied
+            _creature->MonsterWhisper(MSG_NOFREEGH, player);
+            player->CLOSE_GOSSIP_MENU();
+        } else
+        {
+            //this condition occurs when COUNT(guildhouses) % GOSSIP_COUNT_MAX == 0
+            //just show GHs from beginning
+            showBuyList(player, _creature, 0);
+        }
+    }
+
+    delete result;
+    return false;
+}
+
+bool isPlayerHasGuildhouse(Player *player, Creature *_creature, bool whisper = false)
+{
+
+    QueryResult *result = WorldDatabase.PQuery("SELECT `comment` FROM `guild_houses` WHERE `guildId` = %u",
+        player->GetGuildId());
+
+    if (result)
+    {
+        if (whisper)
+        {
+            //whisper to player "already have etc..."
+            Field *fields = result->Fetch();
+            char msg[100];
+            sprintf(msg, MSG_ALREADYHAVEGH, fields[0].GetString());
+            _creature->MonsterWhisper(msg, player);
+        }
+        delete result;
+        return true;
+    }
+    delete result;
+    return false;
+}
+
+void buyGuildhouse(Player *player, Creature *_creature, uint32 guildhouseId)
+{
+    uint32 buyprice = (sConfig.GetIntDefault("GuildMasterNPC.BuyPriceInGold",500)*10000);
+    if (player->GetMoney() < buyprice)
+    {
+        //show how much money player need to buy GH (in gold)
+        char msg[100];
+        sprintf(msg, MSG_NOTENOUGHMONEY, buyprice / 10000);
+        _creature->MonsterWhisper(msg, player);
+        return;
+    }
+
+    if (isPlayerHasGuildhouse(player, _creature, true))
+    {
+        //player already have GH
+        return;
+    }
+
+    //check if somebody already occupied this GH
+    QueryResult *result = WorldDatabase.PQuery("SELECT `id` FROM `guild_houses` WHERE `id` = %u AND `guildId` <> 0",
+        guildhouseId);
+
+    if (result)
+    {
+        _creature->MonsterWhisper(MSG_GHOCCUPIED, player);
+        delete result;
+        return;
+    }
+    delete result;
+
+    //update DB
+    QueryResult *result_updt = WorldDatabase.PQuery("UPDATE `guild_houses` SET `guildId` = %u WHERE `id` = %u",
+        player->GetGuildId(), guildhouseId);
+
+    player->ModifyMoney(-buyprice);
+    _creature->MonsterSay(MSG_CONGRATULATIONS, LANG_UNIVERSAL, player);
+    delete result; 
+}
+
+void sellGuildhouse(Player *player, Creature *_creature)
+{
+    uint32 sellprice = (sConfig.GetIntDefault("GuildMasterNPC.SellPriceInGold",400)*10000);
+    if (isPlayerHasGuildhouse(player, _creature))
+    {
+        QueryResult *result = WorldDatabase.PQuery("UPDATE `guild_houses` SET `guildId` = 0 WHERE `guildId` = %u",
+        player->GetGuildId());
+        
+        player->ModifyMoney(sellprice);
+
+        //display message e.g. "here your money etc."
+        char msg[100];
+        sprintf(msg, MSG_SOLD, sellprice / 10000);
+        _creature->MonsterWhisper(msg, player);
+        delete result;
+    }
+}
+
+bool GossipHello_npc_guildmaster(Player *player, Creature *_creature)
+{
+    player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOON, MSG_GOSSIP_TELE, 
+        GOSSIP_SENDER_MAIN, ACTION_TELE);
+
+    if (isPlayerGuildLeader(player))
+    {
+        uint8 buyEnabled = sConfig.GetIntDefault("GuildMasterNPC.BuyEnabled", 1);
+        if ( buyEnabled == 1 )
+        {
+            //show additional menu for guild leader
+            std::string buyGHGossip = sConfig.GetStringDefault("GuildMasterNPC.BuyGossip", "Buy a Guild House for 500 Gold");
+            player->ADD_GOSSIP_ITEM(ICON_GOSSIP_GOLD, buyGHGossip,
+                GOSSIP_SENDER_MAIN, ACTION_SHOW_BUYLIST);
+        }
+        if (isPlayerHasGuildhouse(player, _creature))
+        {
+            uint8 sellEnabled = sConfig.GetIntDefault("GuildMasterNPC.SellEnabled", 1);
+            if ( sellEnabled == 1 )
+            {
+                //and additional for guildhouse owner
+                std::string sellGHGossip = sConfig.GetStringDefault("GuildMasterNPC.SellGossip", "Sell your Guild House for 400 Gold");
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(ICON_GOSSIP_GOLD, sellGHGossip, GOSSIP_SENDER_MAIN, ACTION_SELL_GUILDHOUSE, MSG_CODEBOX_SELL, 0, true);
+            }
+        }
+    }
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetObjectGuid());
+    return true;
+}
+
+
+bool GossipSelect_npc_guildmaster(Player *player, Creature *_creature, uint32 sender, uint32 action )
+{
+    if (sender != GOSSIP_SENDER_MAIN)
+        return false;
+
+    switch (action)
+    {
+        case ACTION_TELE:
+            //teleport player to GH
+            player->CLOSE_GOSSIP_MENU();
+            teleportPlayerToGuildHouse(player, _creature);
+            break;
+        case ACTION_SHOW_BUYLIST:
+            //show list of GHs which currently not occupied
+            showBuyList(player, _creature);
+            break;
+        default:
+            if (action > OFFSET_SHOWBUY_FROM)
+            {
+                showBuyList(player, _creature, action - OFFSET_SHOWBUY_FROM);
+            } else if (action > OFFSET_GH_ID_TO_ACTION)
+            {
+                //player clicked on buy list
+                player->CLOSE_GOSSIP_MENU();
+                //get guildhouseId from action
+                //guildhouseId = action - OFFSET_GH_ID_TO_ACTION
+                buyGuildhouse(player, _creature, action - OFFSET_GH_ID_TO_ACTION);
+            }
+            break;
+    }
+    
+    return true;
+}
+
+bool GossipSelectWithCode_npc_guildmaster( Player *player, Creature *_creature,
+                                      uint32 sender, uint32 action, const char* sCode )
+{
+    if(sender == GOSSIP_SENDER_MAIN)
+    {
+        if(action == ACTION_SELL_GUILDHOUSE)
+        {
+            int i = -1;
+            try
+            {
+                //compare code
+                if (strlen(sCode) + 1 == sizeof CODE_SELL)
+                    i = strcmp(CODE_SELL, sCode);
+
+            } catch(char *str) {error_db_log(str);}
+
+            if (i == 0)
+            {
+                //right code
+                sellGuildhouse(player, _creature);
+            }
+            player->CLOSE_GOSSIP_MENU();
+            return true;
+        }
+    }
+    return false;
+}
+
+void AddSC_npc_guildmaster()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "npc_guildmaster";
+    newscript->pGossipHello = &GossipHello_npc_guildmaster;
+    newscript->pGossipSelect = &GossipSelect_npc_guildmaster;
+    newscript->pGossipSelectWithCode =  &GossipSelectWithCode_npc_guildmaster;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_heal.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_heal.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_heal.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_heal.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,91 @@
+/* ScriptData
+SDName: NPC_Heal
+SD%Complete: 100
+SDComment: Healer
+SDCategory: NPC
+EndScriptData */
+
+#include "precompiled.h"
+
+bool GossipHello_NPC_Heal(Player *player, Creature *_Creature)
+{
+	// Main Menu 
+       player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Might", GOSSIP_SENDER_MAIN, 1035);
+       player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Wisdom", GOSSIP_SENDER_MAIN, 1040);
+       player->ADD_GOSSIP_ITEM( 5, "Give me Power Word: Fortitude",GOSSIP_SENDER_MAIN, 1045);
+       player->ADD_GOSSIP_ITEM( 5, "Heal Me, Please", GOSSIP_SENDER_MAIN, 4010);
+       player->ADD_GOSSIP_ITEM( 5, "Remove Resurrect Sickness", GOSSIP_SENDER_MAIN, 5000);
+
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetObjectGuid());
+
+return true;
+}
+
+void SendDefaultMenu_NPC_Heal(Player *player, Creature *_Creature, uint32 action )
+{
+
+switch(action)
+{
+
+////////////////////////////Small Buff////////////////////////////////////////
+
+case 1035: // Give me Blessing of Might
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,19838,false);
+break;
+
+case 1040: // Give me Blessing of Wisdom
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,25290,false);
+break;
+
+case 1045: // Give me Power Word: Fortitude
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,10938,false);
+break;
+
+///////////////////////////Player Tools///////////////////////////////////////
+
+case 4010: // Heal me please
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,38588,false);
+break;
+
+case 5000://Remove Res Sickness
+	if(!player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS)) {
+		_Creature->MonsterWhisper("You do not have resurrection sickness.", player);
+		GossipHello_NPC_Heal(player, _Creature);
+		return;
+	}
+
+	_Creature->CastSpell(player,38588,false); // Healing effect
+	player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+	player->CLOSE_GOSSIP_MENU();
+break;
+
+ player->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+
+
+bool GossipSelect_NPC_Heal(Player *player, Creature *_Creature, uint32 sender, uint32 action)
+{
+	// Main menu
+	if (sender == GOSSIP_SENDER_MAIN)
+	SendDefaultMenu_NPC_Heal( player, _Creature, action );
+
+return true;
+}
+
+void AddSC_npc_heal()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "npc_heal";
+    newscript->pGossipHello = &GossipHello_NPC_Heal;
+    newscript->pGossipSelect = &GossipSelect_NPC_Heal;
+    newscript->RegisterSelf();
+}
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_prof.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_prof.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_prof.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_prof.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,320 @@
+/* ScriptData
+SDName: npc_prof
+SD%Complete: 100
+SDComment: Profession Master
+SDCategory: NPC
+EndScriptData */
+
+#include "precompiled.h"
+#include "Config/Config.h"
+
+bool GossipHello_ProfessionNPC(Player* pPlayer, Creature* pCreature)
+{
+	if(sConfig.GetBoolDefault("ProfessionNPC.OnlyGMs", false)) // If ProfessionNPC.OnlyGMs is enabled in conf
+		if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+		{
+			pCreature->MonsterWhisper("Sorry, I can only trade to game masters.", pPlayer);
+			return true;
+		}
+
+	bool EnableProfessions = sConfig.GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+	bool EnableSecondarySkills = sConfig.GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+
+	// Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+	{
+	// Check config if "Professions" is enabled or not
+	if(EnableProfessions)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Secondary Skills" is enabled or not
+	if(EnableSecondarySkills)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+	}
+	else // Main Menu for Horde
+	{
+	// Check config if "Professions" is enabled or not
+	if(EnableProfessions)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Secondary Skills" is enabled or not
+	if(EnableSecondarySkills)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+	}
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetObjectGuid());
+
+return true;
+}
+
+void SendDefaultMenu_ProfessionNPC(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->isInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+	return;
+}
+
+	bool EnableProfessions = sConfig.GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+	bool EnableSecondarySkills = sConfig.GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+
+//Money Check
+if (pPlayer->GetMoney() < (sConfig.GetIntDefault("ProfessionNPC.ProfessionNPC.SkillGoldCost",0)*10000))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+	return;
+}
+
+switch(uiAction)
+{
+
+case 1000: //Profession
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Alchemy."              , GOSSIP_SENDER_MAIN, 1001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Blacksmithing."        , GOSSIP_SENDER_MAIN, 1002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Enchanting."           , GOSSIP_SENDER_MAIN, 1003);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Engineering."          , GOSSIP_SENDER_MAIN, 1004);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Herbalism."            , GOSSIP_SENDER_MAIN, 1005);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Jewelcrafting."        , GOSSIP_SENDER_MAIN, 1007);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Leatherworking."       , GOSSIP_SENDER_MAIN, 1008);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Mining."               , GOSSIP_SENDER_MAIN, 1009);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Skinning."             , GOSSIP_SENDER_MAIN, 1010);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Tailoring."            , GOSSIP_SENDER_MAIN, 1011);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+	pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetObjectGuid());
+break;
+
+case 2000: //Secondary Skills
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Cooking."              , GOSSIP_SENDER_MAIN, 2001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "First Aid."            , GOSSIP_SENDER_MAIN, 2002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Fishing."              , GOSSIP_SENDER_MAIN, 2003);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+	pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetObjectGuid());
+break;
+
+case 3000: //Back To Main Menu
+	// Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+	{
+	// Check config if "Professions" is enabled or not
+	if(EnableProfessions)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Secondary Skills" is enabled or not
+	if(EnableSecondarySkills)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+	}
+	else // Main Menu for Horde
+	{
+	// Check config if "Professions" is enabled or not
+	if(EnableProfessions)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+	// Check config if "Secondary Skills" is enabled or not
+	if(EnableSecondarySkills)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+	}
+
+	pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetObjectGuid());
+break;
+
+//////////////////////////////////////////////////Professions///////////////////////////////////////////////////////////////
+
+case 1001: // Alchemy
+	if(!pPlayer->UpdateSkill(171,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(171,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1002: // Blacksmithing
+	if(!pPlayer->UpdateSkill(164,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(164,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1003: // Enchanting
+	if(!pPlayer->UpdateSkill(333,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(333,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1004: // Engineering
+	if(!pPlayer->UpdateSkill(202,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(202,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1005: // Herbalism
+	if(!pPlayer->UpdateSkill(182,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(182,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1007: // Jewelcrafting
+	if(!pPlayer->UpdateSkill(755,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(755,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1008: // Leatherworking
+	if(!pPlayer->UpdateSkill(165,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(165,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1009: // Mining
+	if(!pPlayer->UpdateSkill(186,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(186,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1010: // Skinning
+	if(!pPlayer->UpdateSkill(393,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(393,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1011: // Tailoring
+	if(!pPlayer->UpdateSkill(197,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(197,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+//////////////////////////////////////////////////Secondary Skills///////////////////////////////////////////////////////////////
+
+case 2001: // Cooking
+	if(!pPlayer->UpdateSkill(185,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(185,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2002: // First Aid
+	if(!pPlayer->UpdateSkill(129,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(129,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2003: // Fishing
+	if(!pPlayer->UpdateSkill(356,0))
+      {
+		pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+		GossipHello_ProfessionNPC(pPlayer, pCreature);
+		return;
+	}
+
+	pPlayer->UpdateSkill(356,(sConfig.GetIntDefault("ProfessionNPC.SkillPoints",0)));
+	pPlayer->ModifyMoney(-(sConfig.GetIntDefault("ProfessionNPC.SkillGoldCost",0)*10000));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+
+
+bool GossipSelect_ProfessionNPC(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+	// Main menu
+	if (uiSender == GOSSIP_SENDER_MAIN)
+	SendDefaultMenu_ProfessionNPC(pPlayer, pCreature, uiAction);
+
+return true;
+}
+
+void AddSC_npc_prof()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "npc_prof";
+    newscript->pGossipHello = &GossipHello_ProfessionNPC;
+    newscript->pGossipSelect = &GossipSelect_ProfessionNPC;
+    newscript->RegisterSelf();
+}
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_rename.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_rename.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_rename.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_rename.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,68 @@
+#include "precompiled.h"
+#include "Config/Config.h"
+
+enum ActNpcRename
+{
+    ACT_RENAME   = 1001,
+    ACT_CONFIRM  = 1002
+};
+
+#define GOSSIP_RENAME_HELLO        "I want to change my name and hide a terrible deed."
+#define GOSSIP_RENAME_CONFIRM      "Are you sure?"
+#define MSG_NOT_ENOUGH_MONEY       "Get out, you are wasting my time!  Come back if you can pay me!"
+#define MSG_COMPLETE_RENAME        "Done!  Now log out of the game and sign in again.  Your secret will die with you!"
+
+bool GossipHello_npc_rename(Player* pPlayer, Creature* pCreature)
+{
+    bool EnableRename = sConfig.GetBoolDefault("RenameNPC.Enable", true);
+
+    if (EnableRename)
+    {
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_RENAME_HELLO, GOSSIP_SENDER_MAIN, ACT_RENAME);
+        pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pCreature->GetObjectGuid());
+    }
+    return true;
+}
+
+bool GossipSelect_npc_rename(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    if (uiSender != GOSSIP_SENDER_MAIN)
+        return false;
+
+        uint32 RenameCost = sConfig.GetIntDefault("RenameNPC.CostInGold", 100);
+        uint32 RenameCopper = RenameCost * 10000;
+
+    switch (uiAction)
+    {
+        case ACT_RENAME:
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_RENAME_CONFIRM, GOSSIP_SENDER_MAIN, ACT_CONFIRM);
+            pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pCreature->GetObjectGuid());
+            break;
+        case ACT_CONFIRM:
+            if (pPlayer->GetMoney() < RenameCopper)
+            {
+                pCreature->MonsterWhisper(MSG_NOT_ENOUGH_MONEY, pPlayer);
+            } else {
+                pCreature->MonsterWhisper(MSG_COMPLETE_RENAME, pPlayer);
+                pPlayer->ModifyMoney(-RenameCopper);
+                pPlayer->SetAtLoginFlag(AT_LOGIN_RENAME);
+            }
+            pPlayer->CLOSE_GOSSIP_MENU();
+            break;
+        default: 
+            pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+void AddSC_npc_rename()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="npc_rename";
+    newscript->pGossipHello = &GossipHello_npc_rename;
+    newscript->pGossipSelect = &GossipSelect_npc_rename;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_rentalmount.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_rentalmount.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_rentalmount.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_rentalmount.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,66 @@
+#include "precompiled.h" 
+#include "Config/Config.h"
+
+#define MSG_GOSSIP_TEXT_1  "I would like to rent a mount." 
+#define MSG_GOSSIP_TEXT_2  "I would like to rent a very fast mount." 
+#define MSG_NOT_MONEY      "You do not have enough money." 
+#define MSG_MOUTED         "You already have a mount." 
+#define MOUNT_SPELL_ID_1   43899 
+#define MOUNT_SPELL_ID_2   43900 
+
+bool GossipHello_npc_rentalmount(Player *player, Creature *_creature) 
+{ 
+    player->ADD_GOSSIP_ITEM(4, MSG_GOSSIP_TEXT_1, GOSSIP_SENDER_MAIN, 1001); 
+    player->ADD_GOSSIP_ITEM(4, MSG_GOSSIP_TEXT_2, GOSSIP_SENDER_MAIN, 1002); 
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetObjectGuid()); 
+    return true; 
+} 
+
+bool GossipSelect_npc_rentalmount(Player *player, Creature *_creature, uint32 sender, uint32 action ) 
+{ 
+    if (sender != GOSSIP_SENDER_MAIN) 
+        return false; 
+
+    if (player->IsMounted()){ 
+        _creature->MonsterWhisper(MSG_MOUTED, player); 
+         return false; 
+    } 
+
+    uint32 slowprice = sConfig.GetIntDefault("RentalMountNPC.SlowPrice",100);
+    uint32 fastprice = sConfig.GetIntDefault("RentalMountNPC.FastPrice",500);
+
+    switch (action) 
+    { 
+    case 1001: 
+        if (player->GetMoney() < slowprice) 
+        { 
+            _creature->MonsterWhisper(MSG_NOT_MONEY, player); 
+        } else { 
+            player->CastSpell(player,MOUNT_SPELL_ID_1,false);
+            player->ModifyMoney(-slowprice); 
+        } 
+        break; 
+    case 1002: 
+        if (player->GetMoney() < fastprice) 
+        { 
+            _creature->MonsterWhisper(MSG_NOT_MONEY, player); 
+        } else { 
+            player->CastSpell(player,MOUNT_SPELL_ID_2,false);
+            player->ModifyMoney(-fastprice); 
+        } 
+        break; 
+    } 
+    player->CLOSE_GOSSIP_MENU();
+    return true; 
+} 
+
+void AddSC_npc_rentalmount() 
+{ 
+     Script *newscript; 
+     newscript = new Script; 
+     newscript->Name = "npc_rentalmount"; 
+     newscript->pGossipHello = &GossipHello_npc_rentalmount; 
+     newscript->pGossipSelect = &GossipSelect_npc_rentalmount; 
+     newscript->RegisterSelf(); 
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/scripts/custom/npc_teleport.cpp temp-build/src/bindings/scriptdev2/scripts/custom/npc_teleport.cpp
--- clean-build/src/bindings/scriptdev2/scripts/custom/npc_teleport.cpp	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/src/bindings/scriptdev2/scripts/custom/npc_teleport.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -0,0 +1,218 @@
+/**
+ * npc_teleport.cpp
+ * Based on code by Wilibald09
+ **/
+
+#include "precompiled.h"
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            10
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+using namespace nsNpcTel;
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "g");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "s");
+        Str += "pc";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Creature * const creature, Player * const player, 
+                  const uint16 &map, const float &X, const float &Y,
+                  const float &Z, const float &orient,
+                  const uint32 &cast_on_arrival)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+        if ( cast_on_arrival > 0 )
+            creature->CastSpell(player, cast_on_arrival, true);
+
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->isGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetObjectGuid());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetObjectGuid());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->isGameMaster()) 
+        {
+            std::string msg ("You do not meet the level requirement. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->MonsterWhisper(msg.c_str(), player);
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->isGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->MonsterWhisper(msg.c_str(), player);
+            return;
+        }
+
+        if (!player->isGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        std::string saydepart = dest.m_sayondeparture;
+        creature->MonsterSay( saydepart.c_str(), LANG_UNIVERSAL, NULL );
+
+        Teleport(creature, player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient, dest.m_castonarrival);
+    }
+}
+
+bool GossipHello_npc_teleport(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->isInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("You are in combat!", player);
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool GossipSelect_npc_teleport(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    switch(sender) 
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        GossipHello_npc_teleport(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+
+
+void AddSC_npc_teleport()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="npc_teleport";
+    newscript->pGossipHello =  &GossipHello_npc_teleport;
+    newscript->pGossipSelect = &GossipSelect_npc_teleport;
+    newscript->RegisterSelf();
+}
+
diff -Nuar clean-build/src/bindings/scriptdev2/system/ScriptLoader.cpp temp-build/src/bindings/scriptdev2/system/ScriptLoader.cpp
--- clean-build/src/bindings/scriptdev2/system/ScriptLoader.cpp	2014-08-02 06:54:02.000000000 -0400
+++ temp-build/src/bindings/scriptdev2/system/ScriptLoader.cpp	2014-08-01 21:07:27.000000000 -0400
@@ -3,11 +3,27 @@
 * Please see the included DOCS/LICENSE.TXT for more information */
 
 #include "precompiled.h"
+#include "sc_npc_teleport.h"
 
 // battlegrounds
 extern void AddSC_battleground();
 
 // custom
+extern void AddSC_item_phase1();
+extern void AddSC_item_phase2();
+extern void AddSC_item_phase4();
+extern void AddSC_item_summonnpc();
+extern void AddSC_item_teleport();
+extern void AddSC_npc_areaguard();
+extern void AddSC_npc_buff();
+extern void AddSC_npc_codebox();
+extern void AddSC_npc_doorcodes();
+extern void AddSC_npc_guildmaster();
+extern void AddSC_npc_heal();
+extern void AddSC_npc_prof();
+extern void AddSC_npc_rename();
+extern void AddSC_npc_rentalmount();
+extern void AddSC_npc_teleport();
 
 // examples
 extern void AddSC_example_creature();
@@ -471,6 +487,24 @@
     AddSC_battleground();
 
     // custom
+    QueryResult *result;
+    LoadNpcTele(result);
+    delete result;
+    AddSC_item_phase1();
+    AddSC_item_phase2();
+    AddSC_item_phase4();
+    AddSC_item_summonnpc();
+    AddSC_item_teleport();
+    AddSC_npc_areaguard();
+    AddSC_npc_buff();
+    AddSC_npc_codebox();
+    AddSC_npc_doorcodes();
+    AddSC_npc_guildmaster();
+    AddSC_npc_heal();
+    AddSC_npc_prof();
+    AddSC_npc_rename();
+    AddSC_npc_rentalmount();
+    AddSC_npc_teleport();
 
     // examples
     AddSC_example_creature();
diff -Nuar clean-build/src/game/AchievementMgr.cpp temp-build/src/game/AchievementMgr.cpp
--- clean-build/src/game/AchievementMgr.cpp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/AchievementMgr.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -1610,7 +1610,7 @@
                 break;
             }
             case ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL:
-                change = GetPlayer()->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS);
+                change = GetPlayer()->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
                 progressType = PROGRESS_HIGHEST;
                 break;
             case ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS:
diff -Nuar clean-build/src/game/Chat.cpp temp-build/src/game/Chat.cpp
--- clean-build/src/game/Chat.cpp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/Chat.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -830,6 +830,11 @@
         { "gearscore",      SEC_ADMINISTRATOR,  false, &ChatHandler::HandleShowGearScoreCommand,       "", NULL },
         { "mmap",           SEC_GAMEMASTER,     false, NULL,                                           "", mmapCommandTable },
 
+        // system command
+
+        { "system",         SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleSystemCommand,              "", NULL },
+
+
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
diff -Nuar clean-build/src/game/Chat.h temp-build/src/game/Chat.h
--- clean-build/src/game/Chat.h	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/Chat.h	2014-07-31 07:17:23.000000000 -0400
@@ -632,6 +632,9 @@
         //! Development Commands
         bool HandleSaveAllCommand(char* args);
 
+        // system command
+        bool HandleSystemCommand(char * args);
+
         Player*   getSelectedPlayer();
         Creature* getSelectedCreature();
         Unit*     getSelectedUnit();
diff -Nuar clean-build/src/game/GameObject.cpp temp-build/src/game/GameObject.cpp
--- clean-build/src/game/GameObject.cpp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/GameObject.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -1191,6 +1191,41 @@
             {
                 Player* player = (Player*)user;
 
+                // GameObject Teleports
+                uint32 go_guid, mapidt, phaset, required_level;
+                float xt,yt,zt,orientationt;
+
+                QueryResult *result = NULL;
+                std::ostringstream qry;
+                qry << "SELECT * FROM gameobject_teleports WHERE entry = " << info->id;
+                result = WorldDatabase.Query(qry.str( ).c_str( ));
+                if(result != NULL)
+                {
+                    Field *fields = result->Fetch();
+                    required_level = fields[6].GetInt32();
+
+                    if ((required_level == 0) || (required_level <= player->getLevel()))
+                    {
+                        go_guid = fields[0].GetUInt32();
+                        mapidt = fields[1].GetUInt32();
+                        xt = fields[2].GetFloat();
+                        yt = fields[3].GetFloat();
+                        zt = fields[4].GetFloat();
+                        orientationt = fields[5].GetFloat();
+                        phaset = fields[7].GetUInt32();
+
+                        player->TeleportTo(mapidt, xt, yt, zt, orientationt, TELE_TO_NOT_LEAVE_TRANSPORT | TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET);
+                        sLog.outString("GO Teleport Activated: %u,%u,%f,%f,%f,%f,%u", go_guid, mapidt, xt, xt, zt, orientationt, phaset);
+                        if (phaset > 0)
+                        {
+                            // Modify player phase
+                            player->SetPhaseMask(phaset, true);
+                        }
+                    }
+                delete result;
+                }
+                // End - GameObject Teleports
+
                 if (info->goober.pageId)                    // show page...
                 {
                     WorldPacket data(SMSG_GAMEOBJECT_PAGETEXT, 8);
diff -Nuar clean-build/src/game/Level3.cpp temp-build/src/game/Level3.cpp
--- clean-build/src/game/Level3.cpp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/Level3.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -4968,7 +4968,7 @@
 
     target->SetHonorPoints(0);
     target->SetUInt32Value(PLAYER_FIELD_KILLS, 0);
-    target->SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS, 0);
+    target->SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 0);
     target->SetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, 0);
     target->SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, 0);
     target->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
@@ -7184,3 +7184,47 @@
 
     return true;
 }
+
+bool ChatHandler::HandleSystemCommand(char* args)
+{
+
+    if (!*args)
+        return false;
+
+    char* cmdname  = strtok((char*)args, " ");
+
+    QueryResult *result = WorldDatabase.PQuery("SELECT command_exec FROM command_external WHERE command_name = '%s'", cmdname);
+
+    if (!result)
+    {
+        SendSysMessage("System Command failed to execute.");
+        return true;
+    }
+
+    Field *fields = result->Fetch();
+    std::string syscommand = fields[0].GetCppString();
+
+    char *sysexec = (char*)syscommand.c_str();
+
+    PSendSysMessage("Executing command: %s",syscommand.c_str());
+
+    FILE *fpipe;
+    char line[256];
+
+    if ( !(fpipe = (FILE*)popen(sysexec,"r")) )
+    {  
+        SendSysMessage("System Command failed to execute.");
+        return true;
+    }
+
+    while ( fgets( line, sizeof line, fpipe))
+    {
+        PSendSysMessage("  %s", line);
+    }
+    pclose(fpipe);
+
+    delete result;
+
+    return true;
+}
+
diff -Nuar clean-build/src/game/MiscHandler.cpp temp-build/src/game/MiscHandler.cpp
--- clean-build/src/game/MiscHandler.cpp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/MiscHandler.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -1112,7 +1112,7 @@
     data << uint32(player->GetUInt32Value(PLAYER_FIELD_KILLS));
     data << uint32(player->GetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION));
     data << uint32(player->GetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION));
-    data << uint32(player->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS));
+    data << uint32(player->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
     SendPacket(&data);
 }
 
diff -Nuar clean-build/src/game/playerbot/PlayerbotMgr.cpp temp-build/src/game/playerbot/PlayerbotMgr.cpp
--- clean-build/src/game/playerbot/PlayerbotMgr.cpp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/playerbot/PlayerbotMgr.cpp	2014-07-31 07:17:24.000000000 -0400
@@ -288,12 +288,14 @@
         // such as inventory that can be equipped
     case CMSG_INSPECT:
         {
+            /* >>> Moved to textemote /curious - was too annoying
             WorldPacket p(packet);
             p.rpos(0); // reset reader
             ObjectGuid guid;
             p >> guid;
             Player* const bot = GetPlayerBot(guid);
             if (bot) bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+            */
             return;
         }
 
@@ -379,6 +381,15 @@
                     return;
                 }
 
+
+            // emote to show inventory that can be equipped
+            case TEXTEMOTE_CURIOUS:
+                {
+                    Player* const bot = GetPlayerBot(m_master->GetSelectionGuid());
+                    if (bot) 
+                        bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+                }
+
                 // emote to attack selected target
             case TEXTEMOTE_POINT:
                 {
diff -Nuar clean-build/src/game/Player.cpp temp-build/src/game/Player.cpp
--- clean-build/src/game/Player.cpp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/Player.cpp	2014-07-31 07:17:23.000000000 -0400
@@ -716,7 +716,7 @@
     SetUInt32Value(PLAYER_CHOSEN_TITLE, 0);
 
     SetUInt32Value(PLAYER_FIELD_KILLS, 0);
-    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS, 0);
+    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 0);
     SetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, 0);
     SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, 0);
 
@@ -6552,6 +6552,7 @@
 
     ObjectGuid victim_guid;
     uint32 victim_rank = 0;
+    uint32 rank_diff = 0;
 
     // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
     UpdateHonorFields();
@@ -6582,20 +6583,52 @@
                 //  [15..28] Horde honor titles and player name
                 //  [29..38] Other title and player name
                 //  [39+]    Nothing
-                uint32 victim_title = pVictim->GetUInt32Value(PLAYER_CHOSEN_TITLE);
+                // PLAYER__FIELD_KNOWN_TITLES describe which titles player can use, 
+                // so we must find biggest pvp title , even for killer to find extra honor value
+                uint32 vtitle = pVictim->GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES);
+                uint32 victim_title = 0;
+                uint32 ktitle = GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES);
+                uint32 killer_title = 0;
+                if(PLAYER_TITLE_MASK_ALL_PVP & ktitle)
+                {
+                    for(int i = ((GetTeam() == ALLIANCE) ? 1:HKRANKMAX);i!=((GetTeam() == ALLIANCE) ? HKRANKMAX : (2*HKRANKMAX-1));i++)
+                    {
+                        if(ktitle & (1<<i))
+                            killer_title = i;
+                    }
+                }
+                if(PLAYER_TITLE_MASK_ALL_PVP & vtitle)
+                {
+                    for(int i = ((pVictim->GetTeam() == ALLIANCE) ? 1:HKRANKMAX);i!=((pVictim->GetTeam() == ALLIANCE) ? HKRANKMAX : (2*HKRANKMAX-1));i++)
+                    {
+                        if(vtitle & (1<<i))
+                            victim_title = i;
+                    }
+                }
+
                 // Get Killer titles, CharTitlesEntry::bit_index
+
                 // Ranks:
                 //  title[1..14]  -> rank[5..18]
                 //  title[15..28] -> rank[5..18]
                 //  title[other]  -> 0
                 if (victim_title == 0)
                     victim_guid.Clear();                    // Don't show HK: <rank> message, only log.
-                else if (victim_title < 15)
+                else if (victim_title < HKRANKMAX)
                     victim_rank = victim_title + 4;
-                else if (victim_title < 29)
+                else if (victim_title < (2*HKRANKMAX-1))
                     victim_rank = victim_title - 14 + 4;
                 else
                     victim_guid.Clear();                    // Don't show HK: <rank> message, only log.
+
+                // now find rank difference
+                if (killer_title == 0 && victim_rank>4)
+                    rank_diff = victim_rank - 4;  
+                else if (killer_title < HKRANKMAX)
+                    rank_diff = (victim_rank>(killer_title + 4))? (victim_rank - (killer_title + 4)) : 0;
+                else if (killer_title < (2*HKRANKMAX-1))
+                    rank_diff = (victim_rank>(killer_title - (HKRANKMAX-1) +4))? (victim_rank - (killer_title - (HKRANKMAX-1) + 4)) : 0;
+
             }
 
             k_grey = MaNGOS::XP::GetGrayLevel(k_level);
@@ -6609,14 +6642,16 @@
 
             honor = ((f * diff_level * (190 + v_rank * 10)) / 6);
             honor *= float(k_level) / 70.0f;                // factor of dependence on levels of the killer
+            honor *= 1 + sWorld.getConfig(CONFIG_FLOAT_RATE_PVP_RANK_EXTRA_HONOR)*(((float)rank_diff) / 10.0f);
 
             // count the number of playerkills in one day
             ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
             // and those in a lifetime
-            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS, 1, true);
+            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS, pVictim->getClass());
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, pVictim->getRace());
+            UpdateKnownTitles();
         }
         else
         {
@@ -6675,6 +6710,30 @@
     SetUInt32Value(PLAYER_FIELD_ARENA_CURRENCY, value);
 }
 
+void Player::UpdateKnownTitles()
+{
+    uint32 new_title = 0;
+    uint32 honor_kills = GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
+    uint32 old_title = GetUInt32Value(PLAYER_CHOSEN_TITLE);
+    RemoveFlag64(PLAYER__FIELD_KNOWN_TITLES,PLAYER_TITLE_MASK_ALL_PVP);
+    if(honor_kills < 0)
+        return;
+    bool max_rank = ((honor_kills >= sWorld.pvp_ranks[HKRANKMAX-1]) ? true : false);
+    for(int i = HKRANK01; i != HKRANKMAX; ++i)
+    {
+        if(honor_kills < sWorld.pvp_ranks[i] || (max_rank))
+        {
+            new_title = ((max_rank) ? (HKRANKMAX-1) : (i-1));
+            if(new_title > 0)
+                new_title += ((GetTeam() == ALLIANCE) ? 0 : (HKRANKMAX-1));
+            break;
+        }
+    }
+    SetFlag64(PLAYER__FIELD_KNOWN_TITLES,uint64(1) << new_title);
+    if(old_title > 0 && old_title < (2*HKRANKMAX-1) && new_title > old_title)
+        SetUInt32Value(PLAYER_CHOSEN_TITLE,new_title);
+}
+
 void Player::ModifyHonorPoints(int32 value)
 {
     int32 newValue = (int32)GetHonorPoints() + value;
@@ -15500,7 +15559,7 @@
 
     SetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, fields[41].GetUInt32());
     SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, fields[42].GetUInt32());
-    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS, fields[43].GetUInt32());
+    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, fields[43].GetUInt32());
     SetUInt16Value(PLAYER_FIELD_KILLS, 0, fields[44].GetUInt16());
     SetUInt16Value(PLAYER_FIELD_KILLS, 1, fields[45].GetUInt16());
 
@@ -17288,7 +17347,7 @@
 
     uberInsert.addUInt32(GetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION));
 
-    uberInsert.addUInt32(GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS));
+    uberInsert.addUInt32(GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
 
     uberInsert.addUInt16(GetUInt16Value(PLAYER_FIELD_KILLS, 0));
 
diff -Nuar clean-build/src/game/Player.h temp-build/src/game/Player.h
--- clean-build/src/game/Player.h	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/Player.h	2014-07-31 07:17:23.000000000 -0400
@@ -432,6 +432,27 @@
     PLAYER_FLAGS_XP_USER_DISABLED       = 0x02000000,
 };
 
+#define PLAYER_TITLE_MASK_ALLIANCE_PVP             \
+    ( PLAYER_TITLE_PRIVATE | PLAYER_TITLE_CORPORAL |  \
+      PLAYER_TITLE_SERGEANT_A | PLAYER_TITLE_MASTER_SERGEANT | \
+      PLAYER_TITLE_SERGEANT_MAJOR | PLAYER_TITLE_KNIGHT | \
+      PLAYER_TITLE_KNIGHT_LIEUTENANT | PLAYER_TITLE_KNIGHT_CAPTAIN | \
+      PLAYER_TITLE_KNIGHT_CHAMPION | PLAYER_TITLE_LIEUTENANT_COMMANDER | \
+      PLAYER_TITLE_COMMANDER | PLAYER_TITLE_MARSHAL | \
+      PLAYER_TITLE_FIELD_MARSHAL | PLAYER_TITLE_GRAND_MARSHAL )
+
+#define PLAYER_TITLE_MASK_HORDE_PVP                           \
+    ( PLAYER_TITLE_SCOUT | PLAYER_TITLE_GRUNT |  \
+      PLAYER_TITLE_SERGEANT_H | PLAYER_TITLE_SENIOR_SERGEANT | \
+      PLAYER_TITLE_FIRST_SERGEANT | PLAYER_TITLE_STONE_GUARD | \
+      PLAYER_TITLE_BLOOD_GUARD | PLAYER_TITLE_LEGIONNAIRE | \
+      PLAYER_TITLE_CENTURION | PLAYER_TITLE_CHAMPION | \
+      PLAYER_TITLE_LIEUTENANT_GENERAL | PLAYER_TITLE_GENERAL | \
+      PLAYER_TITLE_WARLORD | PLAYER_TITLE_HIGH_WARLORD )
+
+#define PLAYER_TITLE_MASK_ALL_PVP  \
+    ( PLAYER_TITLE_MASK_ALLIANCE_PVP | PLAYER_TITLE_MASK_HORDE_PVP )
+
 // used for PLAYER__FIELD_KNOWN_TITLES field (uint64), (1<<bit_index) without (-1)
 // can't use enum for uint64 values
 #define PLAYER_TITLE_DISABLED              UI64LIT(0x0000000000000000)
@@ -1944,6 +1965,7 @@
         void ModifyArenaPoints(int32 value);
 
         uint32 GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot);
+        void UpdateKnownTitles();
 
         // End of PvP System
 
diff -Nuar clean-build/src/game/UpdateFields.h temp-build/src/game/UpdateFields.h
--- clean-build/src/game/UpdateFields.h	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/UpdateFields.h	2014-07-31 07:17:24.000000000 -0400
@@ -375,7 +375,7 @@
     PLAYER_FIELD_KILLS                        = UNIT_END + 0x0435, // Size: 1, Type: TWO_SHORT, Flags: PRIVATE
     PLAYER_FIELD_TODAY_CONTRIBUTION           = UNIT_END + 0x0436, // Size: 1, Type: INT, Flags: PRIVATE
     PLAYER_FIELD_YESTERDAY_CONTRIBUTION       = UNIT_END + 0x0437, // Size: 1, Type: INT, Flags: PRIVATE
-    PLAYER_FIELD_LIFETIME_HONORBALE_KILLS     = UNIT_END + 0x0438, // Size: 1, Type: INT, Flags: PRIVATE
+    PLAYER_FIELD_LIFETIME_HONORABLE_KILLS     = UNIT_END + 0x0438, // Size: 1, Type: INT, Flags: PRIVATE
     PLAYER_FIELD_BYTES2                       = UNIT_END + 0x0439, // Size: 1, Type: 6, Flags: PRIVATE
     PLAYER_FIELD_WATCHED_FACTION_INDEX        = UNIT_END + 0x043A, // Size: 1, Type: INT, Flags: PRIVATE
     PLAYER_FIELD_COMBAT_RATING_1              = UNIT_END + 0x043B, // Size: 25, Type: INT, Flags: PRIVATE
diff -Nuar clean-build/src/game/World.cpp temp-build/src/game/World.cpp
--- clean-build/src/game/World.cpp	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/World.cpp	2014-07-31 07:17:24.000000000 -0400
@@ -604,6 +604,19 @@
 
     setConfigMinMax(CONFIG_UINT32_START_HONOR_POINTS, "StartHonorPoints", 0, 0, getConfig(CONFIG_UINT32_MAX_HONOR_POINTS));
 
+    setConfig(CONFIG_FLOAT_RATE_PVP_RANK_EXTRA_HONOR, "PvPRank.Rate.ExtraHonor", 1);
+    std::string s_pvp_ranks = sConfig.GetStringDefault("PvPRank.HKPerRank", "1,5,10,20,30,40,50,60,70,75,80,85,90,100");
+    char *c_pvp_ranks = const_cast<char*>(s_pvp_ranks.c_str());
+    for (int i = 0; i !=HKRANKMAX; i++)
+    {
+        if(i==0)
+            pvp_ranks[0] = 0;
+        else if(i==1)
+            pvp_ranks[1] = atoi(strtok (c_pvp_ranks, ","));
+        else
+            pvp_ranks[i] = atoi(strtok (NULL, ","));
+    }
+
     setConfig(CONFIG_UINT32_MAX_ARENA_POINTS, "MaxArenaPoints", 5000);
 
     setConfigMinMax(CONFIG_UINT32_START_ARENA_POINTS, "StartArenaPoints", 0, 0, getConfig(CONFIG_UINT32_MAX_ARENA_POINTS));
diff -Nuar clean-build/src/game/World.h temp-build/src/game/World.h
--- clean-build/src/game/World.h	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/game/World.h	2014-07-31 07:17:24.000000000 -0400
@@ -278,6 +278,7 @@
     CONFIG_FLOAT_THREAT_RADIUS,
     CONFIG_FLOAT_GHOST_RUN_SPEED_WORLD,
     CONFIG_FLOAT_GHOST_RUN_SPEED_BG,
+    CONFIG_FLOAT_RATE_PVP_RANK_EXTRA_HONOR,
     CONFIG_FLOAT_VALUE_COUNT
 };
 
@@ -363,6 +364,26 @@
     SESSION_ENABLE_CAIS     = 0x80,
 };
 
+enum HonorKillPvPRank
+{
+    HKRANK00,
+    HKRANK01,
+    HKRANK02,
+    HKRANK03,
+    HKRANK04,
+    HKRANK05,
+    HKRANK06,
+    HKRANK07,
+    HKRANK08,
+    HKRANK09,
+    HKRANK10,
+    HKRANK11,
+    HKRANK12,
+    HKRANK13,
+    HKRANK14,
+    HKRANKMAX
+};
+
 /// Type of server, this is values from second column of Cfg_Configs.dbc (1.12.1 have another numeration)
 enum RealmType
 {
@@ -526,6 +547,8 @@
         void SendZoneUnderAttackMessage(uint32 zoneId, Team team);
         void SendDefenseMessage(uint32 zoneId, int32 textId);
 
+        uint32 pvp_ranks[HKRANKMAX];
+
         /// Are we in the middle of a shutdown?
         bool IsShutdowning() const { return m_ShutdownTimer > 0; }
         void ShutdownServ(uint32 time, uint32 options, uint8 exitcode);
diff -Nuar clean-build/src/mangosd/mangosd.conf.dist.in temp-build/src/mangosd/mangosd.conf.dist.in
--- clean-build/src/mangosd/mangosd.conf.dist.in	2014-08-02 06:53:51.000000000 -0400
+++ temp-build/src/mangosd/mangosd.conf.dist.in	2014-07-31 07:17:24.000000000 -0400
@@ -1397,6 +1397,20 @@
 #         Modifies the speed of player's ghosts, removed upon reviving, not permanent/saved, in non-BG and BG maps
 #         Default: 1.0 (normal speed)
 #
+#    PvPRank.Rate.ExtraHonor
+#    Rate of honor bonus for killing higher PVP ranked players
+#    Default: 
+#        1 - 10% more honor per RANK difference
+#        2 - 20%
+#        0 - off
+#
+#    PvPRank.HKPerRank
+#    Honor Kills needed for each rank, use "," between values.
+#    Whole string must be enclosed with " "
+#    Always specify 14 values, for 14 ranks
+#    Default: 
+#        "1,5,10,20,30,40,50,60,70,75,80,85,90,100"
+#
 ###################################################################################################################
 
 Rate.Health = 1
@@ -1460,6 +1474,8 @@
 Death.Bones.BattlegroundOrArena = 1
 Death.Ghost.RunSpeed.World = 1.0
 Death.Ghost.RunSpeed.Battleground = 1.0
+PvPRank.Rate.ExtraHonor = 1
+PvPRank.HKPerRank = "1,5,10,20,30,40,50,60,70,75,80,85,90,100"
 
 ###################################################################################################################
 # BATTLEGROUND CONFIG
@@ -1712,3 +1728,97 @@
 CharDelete.Method = 0
 CharDelete.MinLevel = 0
 CharDelete.KeepDays = 30
+
+###############################################################################
+# CUSTOM SERVER OPTIONS
+#
+#    GuildMasterNPC.BuyEnabled
+#        Allow players to buy Guild Houses.
+#        Default: 1 (Yes)
+#                 0 (No)
+#
+#    GuildMasterNPC.BuyGossip
+#        Text for buy menu option (good idea to include price)
+#        Default: "Buy a Guild House for 500 Gold"
+#
+#    GuildMasterNPC.BuyPriceInGold
+#        Amount in gold needed to purchase a guild house.
+#        Default: 500 (Gold)
+#
+#    GuildMasterNPC.SellEnabled
+#        Allow players to sell Guild Houses.
+#        Default: 1 (Yes)
+#                 0 (No)
+#
+#    GuildMasterNPC.SellGossip
+#        Text for sell menu option (good idea to include price)
+#        Default: "Sell your Guild House for 400 Gold"
+#
+#    GuildMasterNPC.SellPriceInGold
+#        Amount of gold given to player when selling guild house.
+#        Default: 400 (Gold)
+#
+#   RenameNPC.Enable
+#       Enable the Rename NPC.
+#       Default: 1 - Enabled
+#                0 (Disabled)
+#
+#   RenameNPC.CostInGold
+#       Cost to rename character in gold.
+#       Default: 100
+#
+#    RentalMountNPC.SlowPrice
+#        Price in copper for regular mount.
+#        Default: 100 (1 silver)
+#
+#    RentalMountNPC.FastPrice
+#        Price in copper for swift mount.
+#        Default: 500 (5 silver)
+#
+# ProfessionNPC custom config options
+#
+#    ProfessionNPC.OnlyGMs
+#        players are not allowed to use the NPC if this is enabled
+#        Default: 0 - disable
+#                 1 - enable
+#
+#    ProfessionNPC.EnableProfessions
+#        An option will be added to the gossip menu to up your Professions
+#        Default: 1 - enable
+#                 0 - disable
+#
+#    ProfessionNPC.EnableSecondarySkills
+#        An option will be added to the gossip menu to up your SecondarySkills
+#        Default: 1 - enable
+#                 0 - disable
+#
+#    ProfessionNPC.SkillPoints
+#        An option will be added to the gossip menu for SkillPoints you get
+#        from the npc. Make sure to change the SkillPoints number you want the
+#        npc to sell.
+#        Default: 5 - SkillPoints
+#
+#    ProfessionNPC.SkillGoldCost
+#        An option will be added to the gossip menu for SkillPoints Cost.  The
+#        amount is in gold.
+#        Default: 2 - 2 Gold
+#
+###############################################################################
+ 
+GuildMasterNPC.BuyEnabled = 1
+GuildMasterNPC.BuyGossip = "Buy a Guild House for 500 Gold"
+GuildMasterNPC.BuyPriceInGold = 500
+GuildMasterNPC.SellEnabled = 1
+GuildMasterNPC.SellGossip = "Sell your GuildHouse for 400 Gold"
+GuildMasterNPC.SellPriceInGold = 400
+RenameNPC.Enable = 1
+RenameNPC.CostInGold = 100
+RentalMountNPC.SlowPrice = 100
+RentalMountNPC.FastPrice = 500
+ProfessionNPC.OnlyGMs = 0
+ProfessionNPC.EnableProfessions = 1
+ProfessionNPC.EnableSecondarySkills = 1
+ProfessionNPC.SkillPoints = 5
+ProfessionNPC.SkillGoldCost = 2
+
+
diff -Nuar clean-build/versions.txt temp-build/versions.txt
--- clean-build/versions.txt	1969-12-31 19:00:00.000000000 -0500
+++ temp-build/versions.txt	2014-07-31 07:17:24.000000000 -0400
@@ -0,0 +1,23 @@
+Codebase Versions
+
+Portal Current:
+Commit: eeb5a5cebbc850a0ca2af4983134b69f99e199ce
+Date  : Mon Jun 9 00:12:07 2014 +0100
+Base  : CMaNGOS 12669 (https://github.com/cmangos/mangos-wotlk.git)
+Repo  : https://github.com/blueboy/portal.git
+
+ScriptDev2 Current:
+Commit: b75eeb15e1472b15341167295d22b1635d1999cf
+Date  : Sun Jun 22 22:19:57 2014 +0200
+Repo  : https://github.com/scriptdev2/scriptdev2.git
+
+UnifiedDB Current:
+Commit: r406
+Date  : 2013-04-07 14:58:48 -0400
+Repo  : https://svn.code.sf.net/p/unifieddb/code/trunk
+
+ACID Current:
+Commit: bd0f8f0b26afc1d1c3e37f4fda76dfdbe61b1ef6
+Date  : Mon Jul 14 00:21:45 2014 +0300
+Repo  : https://github.com/scriptdev2/acid.git
+
